{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _d3Array = require(\"d3-array\");\n\nvar _d3Collection = require(\"d3-collection\");\n\nvar _d3Scale = require(\"d3-scale\");\n\nvar _GenericChartComponent = require(\"../GenericChartComponent\");\n\nvar _GenericChartComponent2 = _interopRequireDefault(_GenericChartComponent);\n\nvar _GenericComponent = require(\"../GenericComponent\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar VolumeProfileSeries = function (_Component) {\n  _inherits(VolumeProfileSeries, _Component);\n\n  function VolumeProfileSeries(props) {\n    _classCallCheck(this, VolumeProfileSeries);\n\n    var _this = _possibleConstructorReturn(this, (VolumeProfileSeries.__proto__ || Object.getPrototypeOf(VolumeProfileSeries)).call(this, props));\n\n    _this.renderSVG = _this.renderSVG.bind(_this);\n    _this.drawOnCanvas = _this.drawOnCanvas.bind(_this);\n    return _this;\n  }\n\n  _createClass(VolumeProfileSeries, [{\n    key: \"drawOnCanvas\",\n    value: function drawOnCanvas(ctx, moreProps) {\n      var xAccessor = moreProps.xAccessor,\n          width = moreProps.width;\n\n      var _helper = helper(this.props, moreProps, xAccessor, width),\n          rects = _helper.rects,\n          sessionBg = _helper.sessionBg;\n\n      _drawOnCanvas(ctx, this.props, rects, sessionBg);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      return _react2.default.createElement(_GenericChartComponent2.default, {\n        svgDraw: this.renderSVG,\n        canvasDraw: this.drawOnCanvas,\n        canvasToDraw: _GenericComponent.getAxisCanvas,\n        drawOn: [\"pan\"]\n      });\n    }\n  }, {\n    key: \"renderSVG\",\n    value: function renderSVG(moreProps) {\n      var _props = this.props,\n          className = _props.className,\n          opacity = _props.opacity;\n      var _props2 = this.props,\n          showSessionBackground = _props2.showSessionBackground,\n          sessionBackGround = _props2.sessionBackGround,\n          sessionBackGroundOpacity = _props2.sessionBackGroundOpacity;\n      var xAccessor = moreProps.xAccessor,\n          width = moreProps.width;\n\n      var _helper2 = helper(this.props, moreProps, xAccessor, width),\n          rects = _helper2.rects,\n          sessionBg = _helper2.sessionBg;\n\n      var sessionBgSvg = showSessionBackground ? sessionBg.map(function (d, idx) {\n        return _react2.default.createElement(\"rect\", _extends({\n          key: idx\n        }, d, {\n          opacity: sessionBackGroundOpacity,\n          fill: sessionBackGround\n        }));\n      }) : null;\n      return _react2.default.createElement(\"g\", {\n        className: className\n      }, sessionBgSvg, rects.map(function (d, i) {\n        return _react2.default.createElement(\"g\", {\n          key: i\n        }, _react2.default.createElement(\"rect\", {\n          x: d.x,\n          y: d.y,\n          width: d.w1,\n          height: d.height,\n          fill: d.fill1,\n          stroke: d.stroke1,\n          fillOpacity: opacity\n        }), _react2.default.createElement(\"rect\", {\n          x: d.x + d.w1,\n          y: d.y,\n          width: d.w2,\n          height: d.height,\n          fill: d.fill2,\n          stroke: d.stroke2,\n          fillOpacity: opacity\n        }));\n      }));\n    }\n  }]);\n\n  return VolumeProfileSeries;\n}(_react.Component);\n\nVolumeProfileSeries.propTypes = {\n  className: _propTypes2.default.string,\n  opacity: _propTypes2.default.number,\n  showSessionBackground: _propTypes2.default.bool,\n  sessionBackGround: _propTypes2.default.string,\n  sessionBackGroundOpacity: _propTypes2.default.number\n};\nVolumeProfileSeries.defaultProps = {\n  className: \"line \",\n  bins: 20,\n  opacity: 0.5,\n  maxProfileWidthPercent: 50,\n  fill: function fill(_ref) {\n    var type = _ref.type;\n    return type === \"up\" ? \"#6BA583\" : \"#FF0000\";\n  },\n  stroke: \"#FFFFFF\",\n  showSessionBackground: false,\n  sessionBackGround: \"#4682B4\",\n  sessionBackGroundOpacity: 0.3,\n  source: function source(d) {\n    return d.close;\n  },\n  volume: function volume(d) {\n    return d.volume;\n  },\n  absoluteChange: function absoluteChange(d) {\n    return d.absoluteChange;\n  },\n  bySession: false,\n\n  /* eslint-disable no-unused-vars */\n  sessionStart: function sessionStart(_ref2) {\n    var d = _ref2.d,\n        i = _ref2.i,\n        plotData = _ref2.plotData;\n    return i > 0 && plotData[i - 1].date.getMonth() !== d.date.getMonth();\n  },\n\n  /* eslint-enable no-unused-vars */\n  orient: \"left\",\n  // // fill: ({ type }) => { var c = type === \"up\" ? \"#6BA583\" : \"#FF0000\"; console.log(type, c); return c },\n  // stroke: ({ type }) =>  type === \"up\" ? \"#6BA583\" : \"#FF0000\",\n  // stroke: \"none\",\n  partialStartOK: true,\n  partialEndOK: true\n};\n\nfunction helper(props, moreProps, xAccessor, width) {\n  var realXScale = moreProps.xScale,\n      yScale = moreProps.chartConfig.yScale,\n      plotData = moreProps.plotData;\n  var sessionStart = props.sessionStart,\n      bySession = props.bySession,\n      partialStartOK = props.partialStartOK,\n      partialEndOK = props.partialEndOK;\n  var bins = props.bins,\n      maxProfileWidthPercent = props.maxProfileWidthPercent,\n      source = props.source,\n      volume = props.volume,\n      absoluteChange = props.absoluteChange,\n      orient = props.orient,\n      fill = props.fill,\n      stroke = props.stroke;\n  var sessionBuilder = (0, _utils.accumulatingWindow)().discardTillStart(!partialStartOK).discardTillEnd(!partialEndOK).accumulateTill(function (d, i) {\n    return sessionStart(_extends({\n      d: d,\n      i: i\n    }, moreProps));\n  }).accumulator(_utils.identity);\n  var dx = plotData.length > 1 ? realXScale(xAccessor(plotData[1])) - realXScale(xAccessor((0, _utils.head)(plotData))) : 0;\n  var sessions = bySession ? sessionBuilder(plotData) : [plotData];\n  var allRects = sessions.map(function (session) {\n    var begin = bySession ? realXScale(xAccessor((0, _utils.head)(session))) : 0;\n    var finish = bySession ? realXScale(xAccessor((0, _utils.last)(session))) : width;\n    var sessionWidth = finish - begin + dx; // console.log(session)\n\n    /* var histogram = d3.layout.histogram()\n    \t\t.value(source)\n    \t\t.bins(bins);*/\n\n    var histogram2 = (0, _d3Array.histogram)() // .domain(xScale.domain())\n    .value(source).thresholds(bins); // console.log(bins, histogram(session))\n    // console.log(bins, histogram2(session))\n\n    var rollup = (0, _d3Collection.nest)().key(function (d) {\n      return d.direction;\n    }).sortKeys(orient === \"right\" ? _d3Array.descending : _d3Array.ascending).rollup(function (leaves) {\n      return (0, _d3Array.sum)(leaves, function (d) {\n        return d.volume;\n      });\n    });\n    var values = histogram2(session); // console.log(\"values\", values)\n\n    var volumeInBins = values.map(function (arr) {\n      return arr.map(function (d) {\n        return absoluteChange(d) > 0 ? {\n          direction: \"up\",\n          volume: volume(d)\n        } : {\n          direction: \"down\",\n          volume: volume(d)\n        };\n      });\n    }).map(function (arr) {\n      return rollup.entries(arr);\n    }); // console.log(\"volumeInBins\", volumeInBins)\n\n    var volumeValues = volumeInBins.map(function (each) {\n      return (0, _d3Array.sum)(each.map(function (d) {\n        return d.value;\n      }));\n    }); // console.log(\"volumeValues\", volumeValues)\n\n    var base = function base(xScale) {\n      return (0, _utils.head)(xScale.range());\n    };\n\n    var _ref3 = orient === \"right\" ? [begin, begin + sessionWidth * maxProfileWidthPercent / 100] : [finish, finish - sessionWidth * (100 - maxProfileWidthPercent) / 100],\n        _ref4 = _slicedToArray(_ref3, 2),\n        start = _ref4[0],\n        end = _ref4[1];\n\n    var xScale = (0, _d3Scale.scaleLinear)().domain([0, (0, _d3Array.max)(volumeValues)]).range([start, end]); // console.log(xScale.domain())\n\n    var totalVolumes = volumeInBins.map(function (volumes) {\n      var totalVolume = (0, _d3Array.sum)(volumes, function (d) {\n        return d.value;\n      });\n      var totalVolumeX = xScale(totalVolume);\n      var width = base(xScale) - totalVolumeX;\n      var x = width < 0 ? totalVolumeX + width : totalVolumeX;\n      var ws = volumes.map(function (d) {\n        return {\n          type: d.key,\n          width: d.value * Math.abs(width) / totalVolume\n        };\n      });\n      return {\n        x: x,\n        ws: ws,\n        totalVolumeX: totalVolumeX\n      };\n    }); // console.log(\"totalVolumes\", totalVolumes)\n\n    var rects = (0, _d3Array.zip)(values, totalVolumes).map(function (_ref5) {\n      var _ref6 = _slicedToArray(_ref5, 2),\n          d = _ref6[0],\n          _ref6$ = _ref6[1],\n          x = _ref6$.x,\n          ws = _ref6$.ws;\n\n      var w1 = ws[0] || {\n        type: \"up\",\n        width: 0\n      };\n      var w2 = ws[1] || {\n        type: \"down\",\n        width: 0\n      };\n      return {\n        // y: yScale(d.x + d.dx),\n        y: yScale(d.x1),\n        // height: yScale(d.x - d.dx) - yScale(d.x),\n        height: yScale(d.x1) - yScale(d.x0),\n        x: x,\n        width: width,\n        w1: w1.width,\n        w2: w2.width,\n        stroke1: (0, _utils.functor)(stroke)(w1),\n        stroke2: (0, _utils.functor)(stroke)(w2),\n        fill1: (0, _utils.functor)(fill)(w1),\n        fill2: (0, _utils.functor)(fill)(w2)\n      };\n    }); // console.log(\"rects\", rects)\n\n    var sessionBg = {\n      x: begin,\n      y: (0, _utils.last)(rects).y,\n      height: (0, _utils.head)(rects).y - (0, _utils.last)(rects).y + (0, _utils.head)(rects).height,\n      width: sessionWidth\n    };\n    return {\n      rects: rects,\n      sessionBg: sessionBg\n    };\n  });\n  return {\n    rects: (0, _d3Array.merge)(allRects.map(function (d) {\n      return d.rects;\n    })),\n    sessionBg: allRects.map(function (d) {\n      return d.sessionBg;\n    })\n  };\n}\n\nfunction _drawOnCanvas(ctx, props, rects, sessionBg) {\n  var opacity = props.opacity,\n      sessionBackGround = props.sessionBackGround,\n      sessionBackGroundOpacity = props.sessionBackGroundOpacity,\n      showSessionBackground = props.showSessionBackground; // var { rects, sessionBg } = helper(props, xScale, yScale, plotData);\n\n  if (showSessionBackground) {\n    ctx.fillStyle = (0, _utils.hexToRGBA)(sessionBackGround, sessionBackGroundOpacity);\n    sessionBg.forEach(function (each) {\n      var x = each.x,\n          y = each.y,\n          height = each.height,\n          width = each.width;\n      ctx.beginPath();\n      ctx.rect(x, y, width, height);\n      ctx.closePath();\n      ctx.fill();\n    });\n  }\n\n  rects.forEach(function (each) {\n    var x = each.x,\n        y = each.y,\n        height = each.height,\n        w1 = each.w1,\n        w2 = each.w2,\n        stroke1 = each.stroke1,\n        stroke2 = each.stroke2,\n        fill1 = each.fill1,\n        fill2 = each.fill2;\n\n    if (w1 > 0) {\n      ctx.fillStyle = (0, _utils.hexToRGBA)(fill1, opacity);\n      if (stroke1 !== \"none\") ctx.strokeStyle = stroke1;\n      ctx.beginPath();\n      ctx.rect(x, y, w1, height);\n      ctx.closePath();\n      ctx.fill();\n      if (stroke1 !== \"none\") ctx.stroke();\n    }\n\n    if (w2 > 0) {\n      ctx.fillStyle = (0, _utils.hexToRGBA)(fill2, opacity);\n      if (stroke2 !== \"none\") ctx.strokeStyle = stroke2;\n      ctx.beginPath();\n      ctx.rect(x + w1, y, w2, height);\n      ctx.closePath();\n      ctx.fill();\n      if (stroke2 !== \"none\") ctx.stroke();\n    }\n  });\n}\n\nexports.default = VolumeProfileSeries;","map":null,"metadata":{},"sourceType":"script"}