{"ast":null,"code":"var _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nfunction _objectWithoutProperties(obj, keys) {\n  var target = {};\n\n  for (var i in obj) {\n    if (keys.indexOf(i) >= 0) continue;\n    if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;\n    target[i] = obj[i];\n  }\n\n  return target;\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nimport React, { Component } from \"react\";\nimport PropTypes from \"prop-types\";\nimport { extent as d3Extent, min, max } from \"d3-array\";\nimport { head, last, isDefined, isNotDefined, clearCanvas, shallowEqual, identity, noop, functor, getLogger } from \"./utils\";\n/* eslint-disable no-unused-vars */\n\nimport { mouseBasedZoomAnchor, lastVisibleItemBasedZoomAnchor, rightDomainBasedZoomAnchor } from \"./utils/zoomBehavior\";\n/* eslint-enable no-unused-vars */\n\nimport { getNewChartConfig, getChartConfigWithUpdatedYScales, getCurrentCharts, getCurrentItem } from \"./utils/ChartDataUtil\";\nimport EventCapture from \"./EventCapture\";\nimport CanvasContainer from \"./CanvasContainer\";\nimport evaluator from \"./scale/evaluator\";\nvar log = getLogger(\"ChartCanvas\");\nvar CANDIDATES_FOR_RESET = [\"seriesName\"];\n\nfunction shouldResetChart(thisProps, nextProps) {\n  return !CANDIDATES_FOR_RESET.every(function (key) {\n    var result = shallowEqual(thisProps[key], nextProps[key]); // console.log(key, result);\n\n    return result;\n  });\n}\n\nfunction getCursorStyle() {\n  var tooltipStyle = \"\\n\\t.react-stockcharts-grabbing-cursor {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: -moz-grabbing;\\n\\t\\tcursor: -webkit-grabbing;\\n\\t\\tcursor: grabbing;\\n\\t}\\n\\t.react-stockcharts-crosshair-cursor {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: crosshair;\\n\\t}\\n\\t.react-stockcharts-tooltip-hover {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-stockcharts-avoid-interaction {\\n\\t\\tpointer-events: none;\\n\\t}\\n\\t.react-stockcharts-enable-interaction {\\n\\t\\tpointer-events: all;\\n\\t}\\n\\t.react-stockcharts-tooltip {\\n\\t\\tpointer-events: all;\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-stockcharts-default-cursor {\\n\\t\\tcursor: default;\\n\\t}\\n\\t.react-stockcharts-move-cursor {\\n\\t\\tcursor: move;\\n\\t}\\n\\t.react-stockcharts-pointer-cursor {\\n\\t\\tcursor: pointer;\\n\\t}\\n\\t.react-stockcharts-ns-resize-cursor {\\n\\t\\tcursor: ns-resize;\\n\\t}\\n\\t.react-stockcharts-ew-resize-cursor {\\n\\t\\tcursor: ew-resize;\\n\\t}\";\n  return React.createElement(\"style\", {\n    type: \"text/css\"\n  }, tooltipStyle);\n}\n\nfunction getDimensions(props) {\n  return {\n    height: props.height - props.margin.top - props.margin.bottom,\n    width: props.width - props.margin.left - props.margin.right\n  };\n}\n\nfunction getXScaleDirection(flipXScale) {\n  return flipXScale ? -1 : 1;\n}\n\nfunction calculateFullData(props) {\n  var fullData = props.data,\n      plotFull = props.plotFull,\n      xScale = props.xScale,\n      clamp = props.clamp,\n      pointsPerPxThreshold = props.pointsPerPxThreshold,\n      flipXScale = props.flipXScale;\n  var xAccessor = props.xAccessor,\n      displayXAccessor = props.displayXAccessor,\n      minPointsPerPxThreshold = props.minPointsPerPxThreshold;\n  var useWholeData = isDefined(plotFull) ? plotFull : xAccessor === identity;\n\n  var _evaluator = evaluator({\n    xScale: xScale,\n    useWholeData: useWholeData,\n    clamp: clamp,\n    pointsPerPxThreshold: pointsPerPxThreshold,\n    minPointsPerPxThreshold: minPointsPerPxThreshold,\n    flipXScale: flipXScale\n  }),\n      filterData = _evaluator.filterData;\n\n  return {\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor || xAccessor,\n    xScale: xScale.copy(),\n    fullData: fullData,\n    filterData: filterData\n  };\n}\n\nfunction resetChart(props) {\n  var firstCalculation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (process.env.NODE_ENV !== \"production\") {\n    if (!firstCalculation) log(\"CHART RESET\");\n  }\n\n  var state = calculateState(props);\n  var xAccessor = state.xAccessor,\n      displayXAccessor = state.displayXAccessor,\n      fullData = state.fullData;\n  var initialPlotData = state.plotData,\n      xScale = state.xScale;\n  var postCalculator = props.postCalculator,\n      children = props.children;\n  var plotData = postCalculator(initialPlotData);\n  var dimensions = getDimensions(props);\n  var chartConfig = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children), {\n    plotData: plotData,\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData\n  }, xScale.domain());\n  return _extends({}, state, {\n    xScale: xScale,\n    plotData: plotData,\n    chartConfig: chartConfig\n  });\n}\n\nfunction updateChart(newState, initialXScale, props, lastItemWasVisible, initialChartConfig) {\n  var fullData = newState.fullData,\n      xScale = newState.xScale,\n      xAccessor = newState.xAccessor,\n      displayXAccessor = newState.displayXAccessor,\n      filterData = newState.filterData;\n  var lastItem = last(fullData);\n\n  var _initialXScale$domain = initialXScale.domain(),\n      _initialXScale$domain2 = _slicedToArray(_initialXScale$domain, 2),\n      start = _initialXScale$domain2[0],\n      end = _initialXScale$domain2[1];\n\n  if (process.env.NODE_ENV !== \"production\") {\n    log(\"TRIVIAL CHANGE\");\n  }\n\n  var postCalculator = props.postCalculator,\n      children = props.children,\n      padding = props.padding,\n      flipXScale = props.flipXScale;\n  var maintainPointsPerPixelOnResize = props.maintainPointsPerPixelOnResize;\n  var direction = getXScaleDirection(flipXScale);\n  var dimensions = getDimensions(props);\n  var updatedXScale = setXRange(xScale, dimensions, padding, direction); // console.log(\"lastItemWasVisible =\", lastItemWasVisible, end, xAccessor(lastItem), end >= xAccessor(lastItem));\n\n  var initialPlotData = void 0;\n\n  if (!lastItemWasVisible || end >= xAccessor(lastItem)) {\n    // resize comes here...\n    var _initialXScale$range = initialXScale.range(),\n        _initialXScale$range2 = _slicedToArray(_initialXScale$range, 2),\n        rangeStart = _initialXScale$range2[0],\n        rangeEnd = _initialXScale$range2[1];\n\n    var _updatedXScale$range = updatedXScale.range(),\n        _updatedXScale$range2 = _slicedToArray(_updatedXScale$range, 2),\n        newRangeStart = _updatedXScale$range2[0],\n        newRangeEnd = _updatedXScale$range2[1];\n\n    var newDomainExtent = (newRangeEnd - newRangeStart) / (rangeEnd - rangeStart) * (end - start);\n    var newStart = maintainPointsPerPixelOnResize ? end - newDomainExtent : start;\n    var lastItemX = initialXScale(xAccessor(lastItem)); // console.log(\"pointsPerPixel => \", newStart, start, end, updatedXScale(end));\n\n    var response = filterData(fullData, [newStart, end], xAccessor, updatedXScale, {\n      fallbackStart: start,\n      fallbackEnd: {\n        lastItem: lastItem,\n        lastItemX: lastItemX\n      }\n    });\n    initialPlotData = response.plotData;\n    updatedXScale.domain(response.domain); // console.log(\"HERE!!!!!\", start, end);\n  } else if (lastItemWasVisible && end < xAccessor(lastItem)) {\n    // this is when a new item is added and last item was visible\n    // so slide over and show the new item also\n    // get plotData between [xAccessor(l) - (end - start), xAccessor(l)] and DO change the domain\n    var dx = initialXScale(xAccessor(lastItem)) - initialXScale.range()[1];\n\n    var _initialXScale$range$ = initialXScale.range().map(function (x) {\n      return x + dx;\n    }).map(initialXScale.invert),\n        _initialXScale$range$2 = _slicedToArray(_initialXScale$range$, 2),\n        _newStart = _initialXScale$range$2[0],\n        newEnd = _initialXScale$range$2[1];\n\n    var _response = filterData(fullData, [_newStart, newEnd], xAccessor, updatedXScale);\n\n    initialPlotData = _response.plotData;\n    updatedXScale.domain(_response.domain); // if last item was visible, then shift\n  } // plotData = getDataOfLength(fullData, showingInterval, plotData.length)\n\n\n  var plotData = postCalculator(initialPlotData);\n  var chartConfig = getChartConfigWithUpdatedYScales(getNewChartConfig(dimensions, children, initialChartConfig), {\n    plotData: plotData,\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData\n  }, updatedXScale.domain());\n  return {\n    xScale: updatedXScale,\n    xAccessor: xAccessor,\n    chartConfig: chartConfig,\n    plotData: plotData,\n    fullData: fullData,\n    filterData: filterData\n  };\n}\n\nfunction calculateState(props) {\n  var inputXAccesor = props.xAccessor,\n      xExtentsProp = props.xExtents,\n      data = props.data,\n      padding = props.padding,\n      flipXScale = props.flipXScale;\n\n  if (process.env.NODE_ENV !== \"production\" && isDefined(props.xScale.invert)) {\n    for (var i = 1; i < data.length; i++) {\n      var prev = data[i - 1];\n      var curr = data[i];\n\n      if (inputXAccesor(prev) > inputXAccesor(curr)) {\n        throw new Error(\"'data' is not sorted on 'xAccessor', send 'data' sorted in ascending order of 'xAccessor'\");\n      }\n    }\n  }\n\n  var direction = getXScaleDirection(flipXScale);\n  var dimensions = getDimensions(props);\n  var extent = typeof xExtentsProp === \"function\" ? xExtentsProp(data) : d3Extent(xExtentsProp.map(function (d) {\n    return functor(d);\n  }).map(function (each) {\n    return each(data, inputXAccesor);\n  }));\n\n  var _calculateFullData = calculateFullData(props),\n      xAccessor = _calculateFullData.xAccessor,\n      displayXAccessor = _calculateFullData.displayXAccessor,\n      xScale = _calculateFullData.xScale,\n      fullData = _calculateFullData.fullData,\n      filterData = _calculateFullData.filterData;\n\n  var updatedXScale = setXRange(xScale, dimensions, padding, direction);\n\n  var _filterData = filterData(fullData, extent, inputXAccesor, updatedXScale),\n      plotData = _filterData.plotData,\n      domain = _filterData.domain;\n\n  if (process.env.NODE_ENV !== \"production\" && plotData.length <= 1) {\n    throw new Error(\"Showing \" + plotData.length + \" datapoints, review the 'xExtents' prop of ChartCanvas\");\n  }\n\n  return {\n    plotData: plotData,\n    xScale: updatedXScale.domain(domain),\n    xAccessor: xAccessor,\n    displayXAccessor: displayXAccessor,\n    fullData: fullData,\n    filterData: filterData\n  };\n}\n\nfunction setXRange(xScale, dimensions, padding) {\n  var direction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n\n  if (xScale.rangeRoundPoints) {\n    if (isNaN(padding)) throw new Error(\"padding has to be a number for ordinal scale\");\n    xScale.rangeRoundPoints([0, dimensions.width], padding);\n  } else if (xScale.padding) {\n    if (isNaN(padding)) throw new Error(\"padding has to be a number for ordinal scale\");\n    xScale.range([0, dimensions.width]);\n    xScale.padding(padding / 2);\n  } else {\n    var _ref = isNaN(padding) ? padding : {\n      left: padding,\n      right: padding\n    },\n        left = _ref.left,\n        right = _ref.right;\n\n    if (direction > 0) {\n      xScale.range([left, dimensions.width - right]);\n    } else {\n      xScale.range([dimensions.width - right, left]);\n    }\n  }\n\n  return xScale;\n}\n\nfunction pinchCoordinates(pinch) {\n  var touch1Pos = pinch.touch1Pos,\n      touch2Pos = pinch.touch2Pos;\n  return {\n    topLeft: [Math.min(touch1Pos[0], touch2Pos[0]), Math.min(touch1Pos[1], touch2Pos[1])],\n    bottomRight: [Math.max(touch1Pos[0], touch2Pos[0]), Math.max(touch1Pos[1], touch2Pos[1])]\n  };\n}\n\nvar ChartCanvas = function (_Component) {\n  _inherits(ChartCanvas, _Component);\n\n  function ChartCanvas() {\n    _classCallCheck(this, ChartCanvas);\n\n    var _this = _possibleConstructorReturn(this, (ChartCanvas.__proto__ || Object.getPrototypeOf(ChartCanvas)).call(this));\n\n    _this.getDataInfo = _this.getDataInfo.bind(_this);\n    _this.getCanvasContexts = _this.getCanvasContexts.bind(_this);\n    _this.handleMouseMove = _this.handleMouseMove.bind(_this);\n    _this.handleMouseEnter = _this.handleMouseEnter.bind(_this);\n    _this.handleMouseLeave = _this.handleMouseLeave.bind(_this);\n    _this.handleZoom = _this.handleZoom.bind(_this);\n    _this.handlePinchZoom = _this.handlePinchZoom.bind(_this);\n    _this.handlePinchZoomEnd = _this.handlePinchZoomEnd.bind(_this);\n    _this.handlePan = _this.handlePan.bind(_this);\n    _this.handlePanEnd = _this.handlePanEnd.bind(_this);\n    _this.handleClick = _this.handleClick.bind(_this);\n    _this.handleMouseDown = _this.handleMouseDown.bind(_this);\n    _this.handleDoubleClick = _this.handleDoubleClick.bind(_this);\n    _this.handleContextMenu = _this.handleContextMenu.bind(_this);\n    _this.handleDragStart = _this.handleDragStart.bind(_this);\n    _this.handleDrag = _this.handleDrag.bind(_this);\n    _this.handleDragEnd = _this.handleDragEnd.bind(_this);\n    _this.panHelper = _this.panHelper.bind(_this);\n    _this.pinchZoomHelper = _this.pinchZoomHelper.bind(_this);\n    _this.xAxisZoom = _this.xAxisZoom.bind(_this);\n    _this.yAxisZoom = _this.yAxisZoom.bind(_this);\n    _this.resetYDomain = _this.resetYDomain.bind(_this);\n    _this.calculateStateForDomain = _this.calculateStateForDomain.bind(_this);\n    _this.generateSubscriptionId = _this.generateSubscriptionId.bind(_this);\n    _this.draw = _this.draw.bind(_this);\n    _this.redraw = _this.redraw.bind(_this);\n    _this.getAllPanConditions = _this.getAllPanConditions.bind(_this);\n    _this.subscriptions = [];\n    _this.subscribe = _this.subscribe.bind(_this);\n    _this.unsubscribe = _this.unsubscribe.bind(_this);\n    _this.amIOnTop = _this.amIOnTop.bind(_this);\n    _this.saveEventCaptureNode = _this.saveEventCaptureNode.bind(_this);\n    _this.saveCanvasContainerNode = _this.saveCanvasContainerNode.bind(_this);\n    _this.setCursorClass = _this.setCursorClass.bind(_this);\n    _this.getMutableState = _this.getMutableState.bind(_this); // this.canvasDrawCallbackList = [];\n\n    _this.interactiveState = [];\n    _this.panInProgress = false;\n    _this.state = {};\n    _this.mutableState = {};\n    _this.lastSubscriptionId = 0;\n    return _this;\n  }\n\n  _createClass(ChartCanvas, [{\n    key: \"saveEventCaptureNode\",\n    value: function saveEventCaptureNode(node) {\n      this.eventCaptureNode = node;\n    }\n  }, {\n    key: \"saveCanvasContainerNode\",\n    value: function saveCanvasContainerNode(node) {\n      this.canvasContainerNode = node;\n    }\n  }, {\n    key: \"getMutableState\",\n    value: function getMutableState() {\n      return this.mutableState;\n    }\n  }, {\n    key: \"getDataInfo\",\n    value: function getDataInfo() {\n      return _extends({}, this.state, {\n        fullData: this.fullData\n      });\n    }\n  }, {\n    key: \"getCanvasContexts\",\n    value: function getCanvasContexts() {\n      if (this.canvasContainerNode) {\n        return this.canvasContainerNode.getCanvasContexts();\n      }\n    }\n  }, {\n    key: \"generateSubscriptionId\",\n    value: function generateSubscriptionId() {\n      this.lastSubscriptionId++;\n      return this.lastSubscriptionId;\n    }\n  }, {\n    key: \"clearBothCanvas\",\n    value: function clearBothCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.axes) {\n        clearCanvas([canvases.axes, // canvases.hover,\n        canvases.mouseCoord], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"clearMouseCanvas\",\n    value: function clearMouseCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.mouseCoord) {\n        clearCanvas([canvases.mouseCoord], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"clearThreeCanvas\",\n    value: function clearThreeCanvas() {\n      var canvases = this.getCanvasContexts();\n\n      if (canvases && canvases.axes) {\n        clearCanvas([canvases.axes, // canvases.hover,\n        canvases.mouseCoord, canvases.bg], this.props.ratio);\n      }\n    }\n  }, {\n    key: \"subscribe\",\n    value: function subscribe(id, rest) {\n      var _rest$getPanCondition = rest.getPanConditions,\n          getPanConditions = _rest$getPanCondition === undefined ? functor({\n        draggable: false,\n        panEnabled: true\n      }) : _rest$getPanCondition;\n      this.subscriptions = this.subscriptions.concat(_extends({\n        id: id\n      }, rest, {\n        getPanConditions: getPanConditions\n      }));\n    }\n  }, {\n    key: \"unsubscribe\",\n    value: function unsubscribe(id) {\n      this.subscriptions = this.subscriptions.filter(function (each) {\n        return each.id !== id;\n      });\n    }\n  }, {\n    key: \"getAllPanConditions\",\n    value: function getAllPanConditions() {\n      return this.subscriptions.map(function (each) {\n        return each.getPanConditions();\n      });\n    }\n  }, {\n    key: \"setCursorClass\",\n    value: function setCursorClass(className) {\n      if (this.eventCaptureNode != null) {\n        this.eventCaptureNode.setCursorClass(className);\n      }\n    }\n  }, {\n    key: \"amIOnTop\",\n    value: function amIOnTop(id) {\n      var dragableComponents = this.subscriptions.filter(function (each) {\n        return each.getPanConditions().draggable;\n      });\n      return dragableComponents.length > 0 && last(dragableComponents).id === id;\n    }\n  }, {\n    key: \"handleContextMenu\",\n    value: function handleContextMenu(mouseXY, e) {\n      var _state = this.state,\n          xAccessor = _state.xAccessor,\n          chartConfig = _state.chartConfig,\n          plotData = _state.plotData,\n          xScale = _state.xScale;\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      this.triggerEvent(\"contextmenu\", {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      }, e);\n    }\n  }, {\n    key: \"calculateStateForDomain\",\n    value: function calculateStateForDomain(newDomain) {\n      var _state2 = this.state,\n          xAccessor = _state2.xAccessor,\n          displayXAccessor = _state2.displayXAccessor,\n          initialXScale = _state2.xScale,\n          initialChartConfig = _state2.chartConfig,\n          initialPlotData = _state2.plotData;\n      var filterData = this.state.filterData;\n      var fullData = this.fullData;\n      var postCalculator = this.props.postCalculator;\n\n      var _filterData2 = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      }),\n          beforePlotData = _filterData2.plotData,\n          domain = _filterData2.domain;\n\n      var plotData = postCalculator(beforePlotData);\n      var updatedScale = initialXScale.copy().domain(domain);\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain());\n      return {\n        xScale: updatedScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      };\n    }\n  }, {\n    key: \"pinchZoomHelper\",\n    value: function pinchZoomHelper(initialPinch, finalPinch) {\n      var initialPinchXScale = initialPinch.xScale;\n      var _state3 = this.state,\n          initialXScale = _state3.xScale,\n          initialChartConfig = _state3.chartConfig,\n          initialPlotData = _state3.plotData,\n          xAccessor = _state3.xAccessor,\n          displayXAccessor = _state3.displayXAccessor;\n      var filterData = this.state.filterData;\n      var fullData = this.fullData;\n      var postCalculator = this.props.postCalculator;\n\n      var _pinchCoordinates = pinchCoordinates(initialPinch),\n          iTL = _pinchCoordinates.topLeft,\n          iBR = _pinchCoordinates.bottomRight;\n\n      var _pinchCoordinates2 = pinchCoordinates(finalPinch),\n          fTL = _pinchCoordinates2.topLeft,\n          fBR = _pinchCoordinates2.bottomRight;\n\n      var e = initialPinchXScale.range()[1];\n      var xDash = Math.round(-(iBR[0] * fTL[0] - iTL[0] * fBR[0]) / (iTL[0] - iBR[0]));\n      var yDash = Math.round(e + ((e - iBR[0]) * (e - fTL[0]) - (e - iTL[0]) * (e - fBR[0])) / (e - iTL[0] - (e - iBR[0])));\n      var x = Math.round(-xDash * iTL[0] / (-xDash + fTL[0]));\n      var y = Math.round(e - (yDash - e) * (e - iTL[0]) / (yDash + (e - fTL[0])));\n      var newDomain = [x, y].map(initialPinchXScale.invert); // var domainR = initial.right + right;\n\n      var _filterData3 = filterData(fullData, newDomain, xAccessor, initialPinchXScale, {\n        currentPlotData: initialPlotData,\n        currentDomain: initialXScale.domain()\n      }),\n          beforePlotData = _filterData3.plotData,\n          domain = _filterData3.domain;\n\n      var plotData = postCalculator(beforePlotData);\n      var updatedScale = initialXScale.copy().domain(domain);\n      var mouseXY = finalPinch.touch1Pos;\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain());\n      var currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      return {\n        chartConfig: chartConfig,\n        xScale: updatedScale,\n        plotData: plotData,\n        mouseXY: mouseXY,\n        currentItem: currentItem\n      };\n    }\n  }, {\n    key: \"cancelDrag\",\n    value: function cancelDrag() {\n      this.eventCaptureNode.cancelDrag();\n      this.triggerEvent(\"dragcancel\");\n    }\n  }, {\n    key: \"handlePinchZoom\",\n    value: function handlePinchZoom(initialPinch, finalPinch, e) {\n      var _this2 = this;\n\n      if (!this.waitingForPinchZoomAnimationFrame) {\n        this.waitingForPinchZoomAnimationFrame = true;\n        var state = this.pinchZoomHelper(initialPinch, finalPinch);\n        this.triggerEvent(\"pinchzoom\", state, e);\n        this.finalPinch = finalPinch;\n        requestAnimationFrame(function () {\n          _this2.clearBothCanvas();\n\n          _this2.draw({\n            trigger: \"pinchzoom\"\n          });\n\n          _this2.waitingForPinchZoomAnimationFrame = false;\n        });\n      }\n    }\n  }, {\n    key: \"handlePinchZoomEnd\",\n    value: function handlePinchZoomEnd(initialPinch, e) {\n      var xAccessor = this.state.xAccessor;\n\n      if (this.finalPinch) {\n        var state = this.pinchZoomHelper(initialPinch, this.finalPinch);\n        var xScale = state.xScale;\n        this.triggerEvent(\"pinchzoom\", state, e);\n        this.finalPinch = null;\n        this.clearThreeCanvas();\n        var fullData = this.fullData;\n        var firstItem = head(fullData);\n        var start = head(xScale.domain());\n        var end = xAccessor(firstItem);\n        var onLoadMore = this.props.onLoadMore;\n        this.setState(state, function () {\n          if (start < end) {\n            onLoadMore(start, end);\n          }\n        });\n      }\n    }\n  }, {\n    key: \"handleZoom\",\n    value: function handleZoom(zoomDirection, mouseXY, e) {\n      if (this.panInProgress) return; // console.log(\"zoomDirection \", zoomDirection, \" mouseXY \", mouseXY);\n\n      var _state4 = this.state,\n          xAccessor = _state4.xAccessor,\n          initialXScale = _state4.xScale,\n          initialPlotData = _state4.plotData;\n      var _props = this.props,\n          zoomMultiplier = _props.zoomMultiplier,\n          zoomAnchor = _props.zoomAnchor;\n      var fullData = this.fullData;\n      var item = zoomAnchor({\n        xScale: initialXScale,\n        xAccessor: xAccessor,\n        mouseXY: mouseXY,\n        plotData: initialPlotData,\n        fullData: fullData\n      });\n      var cx = initialXScale(item);\n      var c = zoomDirection > 0 ? 1 * zoomMultiplier : 1 / zoomMultiplier;\n      var newDomain = initialXScale.range().map(function (x) {\n        return cx + (x - cx) * c;\n      }).map(initialXScale.invert);\n\n      var _calculateStateForDom = this.calculateStateForDomain(newDomain),\n          xScale = _calculateStateForDom.xScale,\n          plotData = _calculateStateForDom.plotData,\n          chartConfig = _calculateStateForDom.chartConfig;\n\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      this.clearThreeCanvas();\n      var firstItem = head(fullData);\n      var start = head(xScale.domain());\n      var end = xAccessor(firstItem);\n      var onLoadMore = this.props.onLoadMore;\n      this.mutableState = {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      };\n      this.triggerEvent(\"zoom\", {\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig,\n        mouseXY: mouseXY,\n        currentCharts: currentCharts,\n        currentItem: currentItem,\n        show: true\n      }, e);\n      this.setState({\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      }, function () {\n        if (start < end) {\n          onLoadMore(start, end);\n        }\n      });\n    }\n  }, {\n    key: \"xAxisZoom\",\n    value: function xAxisZoom(newDomain) {\n      var _calculateStateForDom2 = this.calculateStateForDomain(newDomain),\n          xScale = _calculateStateForDom2.xScale,\n          plotData = _calculateStateForDom2.plotData,\n          chartConfig = _calculateStateForDom2.chartConfig;\n\n      this.clearThreeCanvas();\n      var xAccessor = this.state.xAccessor;\n      var fullData = this.fullData;\n      var firstItem = head(fullData);\n      var start = head(xScale.domain());\n      var end = xAccessor(firstItem);\n      var onLoadMore = this.props.onLoadMore;\n      this.setState({\n        xScale: xScale,\n        plotData: plotData,\n        chartConfig: chartConfig\n      }, function () {\n        if (start < end) onLoadMore(start, end);\n      });\n    }\n  }, {\n    key: \"yAxisZoom\",\n    value: function yAxisZoom(chartId, newDomain) {\n      this.clearThreeCanvas();\n      var initialChartConfig = this.state.chartConfig;\n      var chartConfig = initialChartConfig.map(function (each) {\n        if (each.id === chartId) {\n          var yScale = each.yScale;\n          return _extends({}, each, {\n            yScale: yScale.copy().domain(newDomain),\n            yPanEnabled: true\n          });\n        } else {\n          return each;\n        }\n      });\n      this.setState({\n        chartConfig: chartConfig\n      });\n    }\n  }, {\n    key: \"triggerEvent\",\n    value: function triggerEvent(type, props, e) {\n      var _this3 = this; // console.log(\"triggering ->\", type);\n\n\n      this.subscriptions.forEach(function (each) {\n        var state = _extends({}, _this3.state, {\n          fullData: _this3.fullData,\n          subscriptions: _this3.subscriptions\n        });\n\n        each.listener(type, props, state, e);\n      });\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(props) {\n      this.subscriptions.forEach(function (each) {\n        if (isDefined(each.draw)) each.draw(props);\n      });\n    }\n  }, {\n    key: \"redraw\",\n    value: function redraw() {\n      this.clearThreeCanvas();\n      this.draw({\n        force: true\n      });\n    }\n  }, {\n    key: \"panHelper\",\n    value: function panHelper(mouseXY, initialXScale, _ref2, chartsToPan) {\n      var dx = _ref2.dx,\n          dy = _ref2.dy;\n      var _state5 = this.state,\n          xAccessor = _state5.xAccessor,\n          displayXAccessor = _state5.displayXAccessor,\n          initialChartConfig = _state5.chartConfig;\n      var filterData = this.state.filterData;\n      var fullData = this.fullData;\n      var postCalculator = this.props.postCalculator; // console.log(dx, dy);\n\n      if (isNotDefined(initialXScale.invert)) throw new Error(\"xScale provided does not have an invert() method.\" + \"You are likely using an ordinal scale. This scale does not support zoom, pan\");\n      var newDomain = initialXScale.range().map(function (x) {\n        return x - dx;\n      }).map(initialXScale.invert);\n\n      var _filterData4 = filterData(fullData, newDomain, xAccessor, initialXScale, {\n        currentPlotData: this.hackyWayToStopPanBeyondBounds__plotData,\n        currentDomain: this.hackyWayToStopPanBeyondBounds__domain\n      }),\n          beforePlotData = _filterData4.plotData,\n          domain = _filterData4.domain;\n\n      var updatedScale = initialXScale.copy().domain(domain);\n      var plotData = postCalculator(beforePlotData); // console.log(last(plotData));\n\n      var currentItem = getCurrentItem(updatedScale, xAccessor, mouseXY, plotData);\n      var chartConfig = getChartConfigWithUpdatedYScales(initialChartConfig, {\n        plotData: plotData,\n        xAccessor: xAccessor,\n        displayXAccessor: displayXAccessor,\n        fullData: fullData\n      }, updatedScale.domain(), dy, chartsToPan);\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY); // console.log(initialXScale.domain(), newDomain, updatedScale.domain());\n\n      return {\n        xScale: updatedScale,\n        plotData: plotData,\n        chartConfig: chartConfig,\n        mouseXY: mouseXY,\n        currentCharts: currentCharts,\n        currentItem: currentItem\n      };\n    }\n  }, {\n    key: \"handlePan\",\n    value: function handlePan(mousePosition, panStartXScale, dxdy, chartsToPan, e) {\n      var _this4 = this;\n\n      if (!this.waitingForPanAnimationFrame) {\n        this.waitingForPanAnimationFrame = true;\n        this.hackyWayToStopPanBeyondBounds__plotData = this.hackyWayToStopPanBeyondBounds__plotData || this.state.plotData;\n        this.hackyWayToStopPanBeyondBounds__domain = this.hackyWayToStopPanBeyondBounds__domain || this.state.xScale.domain();\n        var state = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan);\n        this.hackyWayToStopPanBeyondBounds__plotData = state.plotData;\n        this.hackyWayToStopPanBeyondBounds__domain = state.xScale.domain();\n        this.panInProgress = true; // console.log(panStartXScale.domain(), state.xScale.domain());\n\n        this.triggerEvent(\"pan\", state, e);\n        this.mutableState = {\n          mouseXY: state.mouseXY,\n          currentItem: state.currentItem,\n          currentCharts: state.currentCharts\n        };\n        requestAnimationFrame(function () {\n          _this4.waitingForPanAnimationFrame = false;\n\n          _this4.clearBothCanvas();\n\n          _this4.draw({\n            trigger: \"pan\"\n          });\n        });\n      }\n    }\n  }, {\n    key: \"handlePanEnd\",\n    value: function handlePanEnd(mousePosition, panStartXScale, dxdy, chartsToPan, e) {\n      var _this5 = this;\n\n      var state = this.panHelper(mousePosition, panStartXScale, dxdy, chartsToPan); // console.log(this.canvasDrawCallbackList.map(d => d.type));\n\n      this.hackyWayToStopPanBeyondBounds__plotData = null;\n      this.hackyWayToStopPanBeyondBounds__domain = null;\n      this.panInProgress = false; // console.log(\"PANEND\", panEnd++);\n\n      var xScale = state.xScale,\n          plotData = state.plotData,\n          chartConfig = state.chartConfig;\n      this.triggerEvent(\"panend\", state, e);\n      requestAnimationFrame(function () {\n        var xAccessor = _this5.state.xAccessor;\n        var fullData = _this5.fullData;\n        var firstItem = head(fullData);\n        var start = head(xScale.domain());\n        var end = xAccessor(firstItem); // console.log(start, end, start < end ? \"Load more\" : \"I have it\");\n\n        var onLoadMore = _this5.props.onLoadMore;\n\n        _this5.clearThreeCanvas();\n\n        _this5.setState({\n          xScale: xScale,\n          plotData: plotData,\n          chartConfig: chartConfig\n        }, function () {\n          if (start < end) onLoadMore(start, end);\n        });\n      });\n    }\n  }, {\n    key: \"handleMouseDown\",\n    value: function handleMouseDown(mousePosition, currentCharts, e) {\n      this.triggerEvent(\"mousedown\", this.mutableState, e);\n    }\n  }, {\n    key: \"handleMouseEnter\",\n    value: function handleMouseEnter(e) {\n      this.triggerEvent(\"mouseenter\", {\n        show: true\n      }, e);\n    }\n  }, {\n    key: \"handleMouseMove\",\n    value: function handleMouseMove(mouseXY, inputType, e) {\n      var _this6 = this;\n\n      if (!this.waitingForMouseMoveAnimationFrame) {\n        this.waitingForMouseMoveAnimationFrame = true;\n        var _state6 = this.state,\n            chartConfig = _state6.chartConfig,\n            plotData = _state6.plotData,\n            xScale = _state6.xScale,\n            xAccessor = _state6.xAccessor;\n        var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n        var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n        this.triggerEvent(\"mousemove\", {\n          show: true,\n          mouseXY: mouseXY,\n          // prevMouseXY is used in interactive components\n          prevMouseXY: this.prevMouseXY,\n          currentItem: currentItem,\n          currentCharts: currentCharts\n        }, e);\n        this.prevMouseXY = mouseXY;\n        this.mutableState = {\n          mouseXY: mouseXY,\n          currentItem: currentItem,\n          currentCharts: currentCharts\n        };\n        requestAnimationFrame(function () {\n          _this6.clearMouseCanvas();\n\n          _this6.draw({\n            trigger: \"mousemove\"\n          });\n\n          _this6.waitingForMouseMoveAnimationFrame = false;\n        });\n      }\n    }\n  }, {\n    key: \"handleMouseLeave\",\n    value: function handleMouseLeave(e) {\n      this.triggerEvent(\"mouseleave\", {\n        show: false\n      }, e);\n      this.clearMouseCanvas();\n      this.draw({\n        trigger: \"mouseleave\"\n      });\n    }\n  }, {\n    key: \"handleDragStart\",\n    value: function handleDragStart(_ref3, e) {\n      var startPos = _ref3.startPos;\n      this.triggerEvent(\"dragstart\", {\n        startPos: startPos\n      }, e);\n    }\n  }, {\n    key: \"handleDrag\",\n    value: function handleDrag(_ref4, e) {\n      var _this7 = this;\n\n      var startPos = _ref4.startPos,\n          mouseXY = _ref4.mouseXY;\n      var _state7 = this.state,\n          chartConfig = _state7.chartConfig,\n          plotData = _state7.plotData,\n          xScale = _state7.xScale,\n          xAccessor = _state7.xAccessor;\n      var currentCharts = getCurrentCharts(chartConfig, mouseXY);\n      var currentItem = getCurrentItem(xScale, xAccessor, mouseXY, plotData);\n      this.triggerEvent(\"drag\", {\n        startPos: startPos,\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      }, e);\n      this.mutableState = {\n        mouseXY: mouseXY,\n        currentItem: currentItem,\n        currentCharts: currentCharts\n      };\n      requestAnimationFrame(function () {\n        _this7.clearMouseCanvas();\n\n        _this7.draw({\n          trigger: \"drag\"\n        });\n      });\n    }\n  }, {\n    key: \"handleDragEnd\",\n    value: function handleDragEnd(_ref5, e) {\n      var _this8 = this;\n\n      var mouseXY = _ref5.mouseXY;\n      this.triggerEvent(\"dragend\", {\n        mouseXY: mouseXY\n      }, e);\n      requestAnimationFrame(function () {\n        _this8.clearMouseCanvas();\n\n        _this8.draw({\n          trigger: \"dragend\"\n        });\n      });\n    }\n  }, {\n    key: \"handleClick\",\n    value: function handleClick(mousePosition, e) {\n      var _this9 = this;\n\n      this.triggerEvent(\"click\", this.mutableState, e);\n      requestAnimationFrame(function () {\n        _this9.clearMouseCanvas();\n\n        _this9.draw({\n          trigger: \"click\"\n        });\n      });\n    }\n  }, {\n    key: \"handleDoubleClick\",\n    value: function handleDoubleClick(mousePosition, e) {\n      this.triggerEvent(\"dblclick\", {}, e);\n    }\n  }, {\n    key: \"getChildContext\",\n    value: function getChildContext() {\n      var dimensions = getDimensions(this.props);\n      return {\n        fullData: this.fullData,\n        plotData: this.state.plotData,\n        width: dimensions.width,\n        height: dimensions.height,\n        chartConfig: this.state.chartConfig,\n        xScale: this.state.xScale,\n        xAccessor: this.state.xAccessor,\n        displayXAccessor: this.state.displayXAccessor,\n        chartCanvasType: this.props.type,\n        margin: this.props.margin,\n        ratio: this.props.ratio,\n        xAxisZoom: this.xAxisZoom,\n        yAxisZoom: this.yAxisZoom,\n        getCanvasContexts: this.getCanvasContexts,\n        redraw: this.redraw,\n        subscribe: this.subscribe,\n        unsubscribe: this.unsubscribe,\n        generateSubscriptionId: this.generateSubscriptionId,\n        getMutableState: this.getMutableState,\n        amIOnTop: this.amIOnTop,\n        setCursorClass: this.setCursorClass\n      };\n    }\n  }, {\n    key: \"componentWillMount\",\n    value: function componentWillMount() {\n      var _resetChart = resetChart(this.props, true),\n          fullData = _resetChart.fullData,\n          state = _objectWithoutProperties(_resetChart, [\"fullData\"]);\n\n      this.setState(state);\n      this.fullData = fullData;\n    }\n  }, {\n    key: \"componentWillReceiveProps\",\n    value: function componentWillReceiveProps(nextProps) {\n      var reset = shouldResetChart(this.props, nextProps);\n      var interaction = isInteractionEnabled(this.state.xScale, this.state.xAccessor, this.state.plotData);\n      var initialChartConfig = this.state.chartConfig;\n      var newState = void 0;\n\n      if (!interaction || reset || !shallowEqual(this.props.xExtents, nextProps.xExtents)) {\n        if (process.env.NODE_ENV !== \"production\") {\n          if (!interaction) log(\"RESET CHART, changes to a non interactive chart\");else if (reset) log(\"RESET CHART, one or more of these props changed\", CANDIDATES_FOR_RESET);else log(\"xExtents changed\");\n        } // do reset\n\n\n        newState = resetChart(nextProps);\n        this.mutableState = {};\n      } else {\n        var _state$xScale$domain = this.state.xScale.domain(),\n            _state$xScale$domain2 = _slicedToArray(_state$xScale$domain, 2),\n            start = _state$xScale$domain2[0],\n            end = _state$xScale$domain2[1];\n\n        var prevLastItem = last(this.fullData);\n        var calculatedState = calculateFullData(nextProps);\n        var xAccessor = calculatedState.xAccessor;\n        var lastItemWasVisible = xAccessor(prevLastItem) <= end && xAccessor(prevLastItem) >= start;\n\n        if (process.env.NODE_ENV !== \"production\") {\n          if (this.props.data !== nextProps.data) log(\"data is changed but seriesName did not, change the seriesName if you wish to reset the chart and lastItemWasVisible = \", lastItemWasVisible);else log(\"Trivial change, may be width/height or type changed, but that does not matter\");\n        }\n\n        newState = updateChart(calculatedState, this.state.xScale, nextProps, lastItemWasVisible, initialChartConfig);\n      }\n\n      var _newState = newState,\n          fullData = _newState.fullData,\n          state = _objectWithoutProperties(_newState, [\"fullData\"]);\n\n      if (this.panInProgress) {\n        if (process.env.NODE_ENV !== \"production\") {\n          log(\"Pan is in progress\");\n        }\n      } else {\n        /*\n        if (!reset) {\n        \tstate.chartConfig\n        \t\t.forEach((each) => {\n        \t\t\t// const sourceChartConfig = initialChartConfig.filter(d => d.id === each.id);\n        \t\t\tconst prevChartConfig = find(initialChartConfig, d => d.id === each.id);\n        \t\t\tif (isDefined(prevChartConfig) && prevChartConfig.yPanEnabled) {\n        \t\t\t\teach.yScale.domain(prevChartConfig.yScale.domain());\n        \t\t\t\teach.yPanEnabled = prevChartConfig.yPanEnabled;\n        \t\t\t}\n        \t\t});\n        }\n        */\n        this.clearThreeCanvas();\n        this.setState(state);\n      }\n\n      this.fullData = fullData;\n    }\n    /*\n    componentDidUpdate(prevProps, prevState) {\n    \tconsole.error(this.state.chartConfig, this.state.chartConfig.map(d => d.yScale.domain()));\n    }\n    */\n\n  }, {\n    key: \"resetYDomain\",\n    value: function resetYDomain(chartId) {\n      var chartConfig = this.state.chartConfig;\n      var changed = false;\n      var newChartConfig = chartConfig.map(function (each) {\n        if ((isNotDefined(chartId) || each.id === chartId) && !shallowEqual(each.yScale.domain(), each.realYDomain)) {\n          changed = true;\n          return _extends({}, each, {\n            yScale: each.yScale.domain(each.realYDomain),\n            yPanEnabled: false\n          });\n        }\n\n        return each;\n      });\n\n      if (changed) {\n        this.clearThreeCanvas();\n        this.setState({\n          chartConfig: newChartConfig\n        });\n      }\n    }\n  }, {\n    key: \"shouldComponentUpdate\",\n    value: function shouldComponentUpdate() {\n      // console.log(\"Happneing.....\", !this.panInProgress)\n      return !this.panInProgress;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _props2 = this.props,\n          type = _props2.type,\n          height = _props2.height,\n          width = _props2.width,\n          margin = _props2.margin,\n          className = _props2.className,\n          zIndex = _props2.zIndex,\n          defaultFocus = _props2.defaultFocus,\n          ratio = _props2.ratio,\n          mouseMoveEvent = _props2.mouseMoveEvent,\n          panEvent = _props2.panEvent,\n          zoomEvent = _props2.zoomEvent;\n      var _props3 = this.props,\n          useCrossHairStyleCursor = _props3.useCrossHairStyleCursor,\n          onSelect = _props3.onSelect;\n      var _state8 = this.state,\n          plotData = _state8.plotData,\n          xScale = _state8.xScale,\n          xAccessor = _state8.xAccessor,\n          chartConfig = _state8.chartConfig;\n      var dimensions = getDimensions(this.props);\n      var interaction = isInteractionEnabled(xScale, xAccessor, plotData);\n      var cursorStyle = useCrossHairStyleCursor && interaction;\n      var cursor = getCursorStyle();\n      return React.createElement(\"div\", {\n        style: {\n          position: \"relative\",\n          width: width,\n          height: height\n        },\n        className: className,\n        onClick: onSelect\n      }, React.createElement(CanvasContainer, {\n        ref: this.saveCanvasContainerNode,\n        type: type,\n        ratio: ratio,\n        width: width,\n        height: height,\n        zIndex: zIndex\n      }), React.createElement(\"svg\", {\n        className: className,\n        width: width,\n        height: height,\n        style: {\n          position: \"absolute\",\n          zIndex: zIndex + 5\n        }\n      }, cursor, React.createElement(\"defs\", null, React.createElement(\"clipPath\", {\n        id: \"chart-area-clip\"\n      }, React.createElement(\"rect\", {\n        x: \"0\",\n        y: \"0\",\n        width: dimensions.width,\n        height: dimensions.height\n      })), chartConfig.map(function (each, idx) {\n        return React.createElement(\"clipPath\", {\n          key: idx,\n          id: \"chart-area-clip-\" + each.id\n        }, React.createElement(\"rect\", {\n          x: \"0\",\n          y: \"0\",\n          width: each.width,\n          height: each.height\n        }));\n      })), React.createElement(\"g\", {\n        transform: \"translate(\" + (margin.left + 0.5) + \", \" + (margin.top + 0.5) + \")\"\n      }, React.createElement(EventCapture, {\n        ref: this.saveEventCaptureNode,\n        useCrossHairStyleCursor: cursorStyle,\n        mouseMove: mouseMoveEvent && interaction,\n        zoom: zoomEvent && interaction,\n        pan: panEvent && interaction,\n        width: dimensions.width,\n        height: dimensions.height,\n        chartConfig: chartConfig,\n        xScale: xScale,\n        xAccessor: xAccessor,\n        focus: defaultFocus,\n        disableInteraction: this.props.disableInteraction,\n        getAllPanConditions: this.getAllPanConditions,\n        onContextMenu: this.handleContextMenu,\n        onClick: this.handleClick,\n        onDoubleClick: this.handleDoubleClick,\n        onMouseDown: this.handleMouseDown,\n        onMouseMove: this.handleMouseMove,\n        onMouseEnter: this.handleMouseEnter,\n        onMouseLeave: this.handleMouseLeave,\n        onDragStart: this.handleDragStart,\n        onDrag: this.handleDrag,\n        onDragComplete: this.handleDragEnd,\n        onZoom: this.handleZoom,\n        onPinchZoom: this.handlePinchZoom,\n        onPinchZoomEnd: this.handlePinchZoomEnd,\n        onPan: this.handlePan,\n        onPanEnd: this.handlePanEnd\n      }), React.createElement(\"g\", {\n        className: \"react-stockcharts-avoid-interaction\"\n      }, this.props.children))));\n    }\n  }]);\n\n  return ChartCanvas;\n}(Component);\n\nfunction isInteractionEnabled(xScale, xAccessor, data) {\n  var interaction = !isNaN(xScale(xAccessor(head(data)))) && isDefined(xScale.invert);\n  return interaction;\n}\n\nChartCanvas.propTypes = {\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  margin: PropTypes.object,\n  ratio: PropTypes.number.isRequired,\n  // interval: PropTypes.oneOf([\"D\", \"W\", \"M\"]), // ,\"m1\", \"m5\", \"m15\", \"W\", \"M\"\n  type: PropTypes.oneOf([\"svg\", \"hybrid\"]),\n  pointsPerPxThreshold: PropTypes.number,\n  minPointsPerPxThreshold: PropTypes.number,\n  data: PropTypes.array.isRequired,\n  // initialDisplay: PropTypes.number,\n  xAccessor: PropTypes.func,\n  xExtents: PropTypes.oneOfType([PropTypes.array, PropTypes.func]),\n  zoomAnchor: PropTypes.func,\n  className: PropTypes.string,\n  seriesName: PropTypes.string.isRequired,\n  zIndex: PropTypes.number,\n  children: PropTypes.node.isRequired,\n  xScale: PropTypes.func.isRequired,\n  postCalculator: PropTypes.func,\n  flipXScale: PropTypes.bool,\n  useCrossHairStyleCursor: PropTypes.bool,\n  padding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n    left: PropTypes.number,\n    right: PropTypes.number\n  })]),\n  defaultFocus: PropTypes.bool,\n  zoomMultiplier: PropTypes.number,\n  onLoadMore: PropTypes.func,\n  displayXAccessor: function displayXAccessor(props, propName\n  /* , componentName */\n  ) {\n    if (isNotDefined(props[propName])) {\n      console.warn(\"`displayXAccessor` is not defined,\" + \" will use the value from `xAccessor` as `displayXAccessor`.\" + \" This might be ok if you do not use a discontinuous scale\" + \" but if you do, provide a `displayXAccessor` prop to `ChartCanvas`\");\n    } else if (typeof props[propName] !== \"function\") {\n      return new Error(\"displayXAccessor has to be a function\");\n    }\n  },\n  mouseMoveEvent: PropTypes.bool,\n  panEvent: PropTypes.bool,\n  clamp: PropTypes.oneOfType([PropTypes.string, PropTypes.bool, PropTypes.func]),\n  zoomEvent: PropTypes.bool,\n  onSelect: PropTypes.func,\n  maintainPointsPerPixelOnResize: PropTypes.bool,\n  disableInteraction: PropTypes.bool\n};\nChartCanvas.defaultProps = {\n  margin: {\n    top: 20,\n    right: 30,\n    bottom: 30,\n    left: 80\n  },\n  type: \"hybrid\",\n  pointsPerPxThreshold: 2,\n  minPointsPerPxThreshold: 1 / 100,\n  className: \"react-stockchart\",\n  zIndex: 1,\n  xExtents: [min, max],\n  postCalculator: identity,\n  padding: 0,\n  xAccessor: identity,\n  flipXScale: false,\n  useCrossHairStyleCursor: true,\n  defaultFocus: true,\n  onLoadMore: noop,\n  onSelect: noop,\n  mouseMoveEvent: true,\n  panEvent: true,\n  zoomEvent: true,\n  zoomMultiplier: 1.1,\n  clamp: false,\n  zoomAnchor: mouseBasedZoomAnchor,\n  maintainPointsPerPixelOnResize: true,\n  // ratio: 2,\n  disableInteraction: false\n};\nChartCanvas.childContextTypes = {\n  plotData: PropTypes.array,\n  fullData: PropTypes.array,\n  chartConfig: PropTypes.arrayOf(PropTypes.shape({\n    id: PropTypes.oneOfType([PropTypes.number, PropTypes.string]).isRequired,\n    origin: PropTypes.arrayOf(PropTypes.number).isRequired,\n    padding: PropTypes.oneOfType([PropTypes.number, PropTypes.shape({\n      top: PropTypes.number,\n      bottom: PropTypes.number\n    })]),\n    yExtents: PropTypes.arrayOf(PropTypes.func),\n    yExtentsProvider: PropTypes.func,\n    yScale: PropTypes.func.isRequired,\n    mouseCoordinates: PropTypes.shape({\n      at: PropTypes.string,\n      format: PropTypes.func\n    }),\n    width: PropTypes.number.isRequired,\n    height: PropTypes.number.isRequired\n  })).isRequired,\n  xScale: PropTypes.func.isRequired,\n  xAccessor: PropTypes.func.isRequired,\n  displayXAccessor: PropTypes.func.isRequired,\n  width: PropTypes.number.isRequired,\n  height: PropTypes.number.isRequired,\n  chartCanvasType: PropTypes.oneOf([\"svg\", \"hybrid\"]).isRequired,\n  margin: PropTypes.object.isRequired,\n  ratio: PropTypes.number.isRequired,\n  getCanvasContexts: PropTypes.func,\n  xAxisZoom: PropTypes.func,\n  yAxisZoom: PropTypes.func,\n  amIOnTop: PropTypes.func,\n  redraw: PropTypes.func,\n  subscribe: PropTypes.func,\n  unsubscribe: PropTypes.func,\n  setCursorClass: PropTypes.func,\n  generateSubscriptionId: PropTypes.func,\n  getMutableState: PropTypes.func\n};\n\nChartCanvas.ohlcv = function (d) {\n  return {\n    date: d.date,\n    open: d.open,\n    high: d.high,\n    low: d.low,\n    close: d.close,\n    volume: d.volume\n  };\n};\n\nexport default ChartCanvas;","map":null,"metadata":{},"sourceType":"module"}