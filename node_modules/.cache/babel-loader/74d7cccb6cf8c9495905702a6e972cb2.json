{"ast":null,"code":"/* @license C3.js v0.4.23 | (c) C3 Team and other contributors | http://c3js.org/ */\n(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : global.c3 = factory();\n})(this, function () {\n  'use strict';\n\n  var CLASS = {\n    target: 'c3-target',\n    chart: 'c3-chart',\n    chartLine: 'c3-chart-line',\n    chartLines: 'c3-chart-lines',\n    chartBar: 'c3-chart-bar',\n    chartBars: 'c3-chart-bars',\n    chartText: 'c3-chart-text',\n    chartTexts: 'c3-chart-texts',\n    chartArc: 'c3-chart-arc',\n    chartArcs: 'c3-chart-arcs',\n    chartArcsTitle: 'c3-chart-arcs-title',\n    chartArcsBackground: 'c3-chart-arcs-background',\n    chartArcsGaugeUnit: 'c3-chart-arcs-gauge-unit',\n    chartArcsGaugeMax: 'c3-chart-arcs-gauge-max',\n    chartArcsGaugeMin: 'c3-chart-arcs-gauge-min',\n    selectedCircle: 'c3-selected-circle',\n    selectedCircles: 'c3-selected-circles',\n    eventRect: 'c3-event-rect',\n    eventRects: 'c3-event-rects',\n    eventRectsSingle: 'c3-event-rects-single',\n    eventRectsMultiple: 'c3-event-rects-multiple',\n    zoomRect: 'c3-zoom-rect',\n    brush: 'c3-brush',\n    focused: 'c3-focused',\n    defocused: 'c3-defocused',\n    region: 'c3-region',\n    regions: 'c3-regions',\n    title: 'c3-title',\n    tooltipContainer: 'c3-tooltip-container',\n    tooltip: 'c3-tooltip',\n    tooltipName: 'c3-tooltip-name',\n    shape: 'c3-shape',\n    shapes: 'c3-shapes',\n    line: 'c3-line',\n    lines: 'c3-lines',\n    bar: 'c3-bar',\n    bars: 'c3-bars',\n    circle: 'c3-circle',\n    circles: 'c3-circles',\n    arc: 'c3-arc',\n    arcLabelLine: 'c3-arc-label-line',\n    arcs: 'c3-arcs',\n    area: 'c3-area',\n    areas: 'c3-areas',\n    empty: 'c3-empty',\n    text: 'c3-text',\n    texts: 'c3-texts',\n    gaugeValue: 'c3-gauge-value',\n    grid: 'c3-grid',\n    gridLines: 'c3-grid-lines',\n    xgrid: 'c3-xgrid',\n    xgrids: 'c3-xgrids',\n    xgridLine: 'c3-xgrid-line',\n    xgridLines: 'c3-xgrid-lines',\n    xgridFocus: 'c3-xgrid-focus',\n    ygrid: 'c3-ygrid',\n    ygrids: 'c3-ygrids',\n    ygridLine: 'c3-ygrid-line',\n    ygridLines: 'c3-ygrid-lines',\n    axis: 'c3-axis',\n    axisX: 'c3-axis-x',\n    axisXLabel: 'c3-axis-x-label',\n    axisY: 'c3-axis-y',\n    axisYLabel: 'c3-axis-y-label',\n    axisY2: 'c3-axis-y2',\n    axisY2Label: 'c3-axis-y2-label',\n    legendBackground: 'c3-legend-background',\n    legendItem: 'c3-legend-item',\n    legendItemEvent: 'c3-legend-item-event',\n    legendItemTile: 'c3-legend-item-tile',\n    legendItemHidden: 'c3-legend-item-hidden',\n    legendItemFocused: 'c3-legend-item-focused',\n    dragarea: 'c3-dragarea',\n    EXPANDED: '_expanded_',\n    SELECTED: '_selected_',\n    INCLUDED: '_included_'\n  };\n\n  var _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  };\n\n  var classCallCheck = function classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  };\n\n  var inherits = function inherits(subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    subClass.prototype = Object.create(superClass && superClass.prototype, {\n      constructor: {\n        value: subClass,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n  };\n\n  var possibleConstructorReturn = function possibleConstructorReturn(self, call) {\n    if (!self) {\n      throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    }\n\n    return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n  };\n\n  var isValue = function isValue(v) {\n    return v || v === 0;\n  };\n\n  var isFunction = function isFunction(o) {\n    return typeof o === 'function';\n  };\n\n  var isArray = function isArray(o) {\n    return Array.isArray(o);\n  };\n\n  var isString = function isString(o) {\n    return typeof o === 'string';\n  };\n\n  var isUndefined = function isUndefined(v) {\n    return typeof v === 'undefined';\n  };\n\n  var isDefined = function isDefined(v) {\n    return typeof v !== 'undefined';\n  };\n\n  var ceil10 = function ceil10(v) {\n    return Math.ceil(v / 10) * 10;\n  };\n\n  var asHalfPixel = function asHalfPixel(n) {\n    return Math.ceil(n) + 0.5;\n  };\n\n  var diffDomain = function diffDomain(d) {\n    return d[1] - d[0];\n  };\n\n  var isEmpty = function isEmpty(o) {\n    return typeof o === 'undefined' || o === null || isString(o) && o.length === 0 || (typeof o === 'undefined' ? 'undefined' : _typeof(o)) === 'object' && Object.keys(o).length === 0;\n  };\n\n  var notEmpty = function notEmpty(o) {\n    return !c3_chart_internal_fn.isEmpty(o);\n  };\n\n  var getOption = function getOption(options, key, defaultValue) {\n    return isDefined(options[key]) ? options[key] : defaultValue;\n  };\n\n  var hasValue = function hasValue(dict, value) {\n    var found = false;\n    Object.keys(dict).forEach(function (key) {\n      if (dict[key] === value) {\n        found = true;\n      }\n    });\n    return found;\n  };\n\n  var sanitise = function sanitise(str) {\n    return typeof str === 'string' ? str.replace(/</g, '&lt;').replace(/>/g, '&gt;') : str;\n  };\n\n  var getPathBox = function getPathBox(path) {\n    var box = path.getBoundingClientRect(),\n        items = [path.pathSegList.getItem(0), path.pathSegList.getItem(1)],\n        minX = items[0].x,\n        minY = Math.min(items[0].y, items[1].y);\n    return {\n      x: minX,\n      y: minY,\n      width: box.width,\n      height: box.height\n    };\n  };\n\n  var c3_axis_fn;\n  var c3_axis_internal_fn;\n\n  function AxisInternal(component, params) {\n    var internal = this;\n    internal.component = component;\n    internal.params = params || {};\n    internal.d3 = component.d3;\n    internal.scale = internal.d3.scale.linear();\n    internal.range;\n    internal.orient = \"bottom\";\n    internal.innerTickSize = 6;\n    internal.outerTickSize = this.params.withOuterTick ? 6 : 0;\n    internal.tickPadding = 3;\n    internal.tickValues = null;\n    internal.tickFormat;\n    internal.tickArguments;\n    internal.tickOffset = 0;\n    internal.tickCulling = true;\n    internal.tickCentered;\n    internal.tickTextCharSize;\n    internal.tickTextRotate = internal.params.tickTextRotate;\n    internal.tickLength;\n    internal.axis = internal.generateAxis();\n  }\n\n  c3_axis_internal_fn = AxisInternal.prototype;\n\n  c3_axis_internal_fn.axisX = function (selection, x, tickOffset) {\n    selection.attr(\"transform\", function (d) {\n      return \"translate(\" + Math.ceil(x(d) + tickOffset) + \", 0)\";\n    });\n  };\n\n  c3_axis_internal_fn.axisY = function (selection, y) {\n    selection.attr(\"transform\", function (d) {\n      return \"translate(0,\" + Math.ceil(y(d)) + \")\";\n    });\n  };\n\n  c3_axis_internal_fn.scaleExtent = function (domain) {\n    var start = domain[0],\n        stop = domain[domain.length - 1];\n    return start < stop ? [start, stop] : [stop, start];\n  };\n\n  c3_axis_internal_fn.generateTicks = function (scale) {\n    var internal = this;\n    var i,\n        domain,\n        ticks = [];\n\n    if (scale.ticks) {\n      return scale.ticks.apply(scale, internal.tickArguments);\n    }\n\n    domain = scale.domain();\n\n    for (i = Math.ceil(domain[0]); i < domain[1]; i++) {\n      ticks.push(i);\n    }\n\n    if (ticks.length > 0 && ticks[0] > 0) {\n      ticks.unshift(ticks[0] - (ticks[1] - ticks[0]));\n    }\n\n    return ticks;\n  };\n\n  c3_axis_internal_fn.copyScale = function () {\n    var internal = this;\n    var newScale = internal.scale.copy(),\n        domain;\n\n    if (internal.params.isCategory) {\n      domain = internal.scale.domain();\n      newScale.domain([domain[0], domain[1] - 1]);\n    }\n\n    return newScale;\n  };\n\n  c3_axis_internal_fn.textFormatted = function (v) {\n    var internal = this,\n        formatted = internal.tickFormat ? internal.tickFormat(v) : v;\n    return typeof formatted !== 'undefined' ? formatted : '';\n  };\n\n  c3_axis_internal_fn.updateRange = function () {\n    var internal = this;\n    internal.range = internal.scale.rangeExtent ? internal.scale.rangeExtent() : internal.scaleExtent(internal.scale.range());\n    return internal.range;\n  };\n\n  c3_axis_internal_fn.updateTickTextCharSize = function (tick) {\n    var internal = this;\n\n    if (internal.tickTextCharSize) {\n      return internal.tickTextCharSize;\n    }\n\n    var size = {\n      h: 11.5,\n      w: 5.5\n    };\n    tick.select('text').text(function (d) {\n      return internal.textFormatted(d);\n    }).each(function (d) {\n      var box = this.getBoundingClientRect(),\n          text = internal.textFormatted(d),\n          h = box.height,\n          w = text ? box.width / text.length : undefined;\n\n      if (h && w) {\n        size.h = h;\n        size.w = w;\n      }\n    }).text('');\n    internal.tickTextCharSize = size;\n    return size;\n  };\n\n  c3_axis_internal_fn.transitionise = function (selection) {\n    return this.params.withoutTransition ? selection : this.d3.transition(selection);\n  };\n\n  c3_axis_internal_fn.isVertical = function () {\n    return this.orient === 'left' || this.orient === 'right';\n  };\n\n  c3_axis_internal_fn.tspanData = function (d, i, ticks, scale) {\n    var internal = this;\n    var splitted = internal.params.tickMultiline ? internal.splitTickText(d, ticks, scale) : [].concat(internal.textFormatted(d));\n\n    if (internal.params.tickMultiline && internal.params.tickMultilineMax > 0) {\n      splitted = internal.ellipsify(splitted, internal.params.tickMultilineMax);\n    }\n\n    return splitted.map(function (s) {\n      return {\n        index: i,\n        splitted: s,\n        length: splitted.length\n      };\n    });\n  };\n\n  c3_axis_internal_fn.splitTickText = function (d, ticks, scale) {\n    var internal = this,\n        tickText = internal.textFormatted(d),\n        maxWidth = internal.params.tickWidth,\n        subtext,\n        spaceIndex,\n        textWidth,\n        splitted = [];\n\n    if (Object.prototype.toString.call(tickText) === \"[object Array]\") {\n      return tickText;\n    }\n\n    if (!maxWidth || maxWidth <= 0) {\n      maxWidth = internal.isVertical() ? 95 : internal.params.isCategory ? Math.ceil(scale(ticks[1]) - scale(ticks[0])) - 12 : 110;\n    }\n\n    function split(splitted, text) {\n      spaceIndex = undefined;\n\n      for (var i = 1; i < text.length; i++) {\n        if (text.charAt(i) === ' ') {\n          spaceIndex = i;\n        }\n\n        subtext = text.substr(0, i + 1);\n        textWidth = internal.tickTextCharSize.w * subtext.length; // if text width gets over tick width, split by space index or crrent index\n\n        if (maxWidth < textWidth) {\n          return split(splitted.concat(text.substr(0, spaceIndex ? spaceIndex : i)), text.slice(spaceIndex ? spaceIndex + 1 : i));\n        }\n      }\n\n      return splitted.concat(text);\n    }\n\n    return split(splitted, tickText + \"\");\n  };\n\n  c3_axis_internal_fn.ellipsify = function (splitted, max) {\n    if (splitted.length <= max) {\n      return splitted;\n    }\n\n    var ellipsified = splitted.slice(0, max);\n    var remaining = 3;\n\n    for (var i = max - 1; i >= 0; i--) {\n      var available = ellipsified[i].length;\n      ellipsified[i] = ellipsified[i].substr(0, available - remaining).padEnd(available, '.');\n      remaining -= available;\n\n      if (remaining <= 0) {\n        break;\n      }\n    }\n\n    return ellipsified;\n  };\n\n  c3_axis_internal_fn.updateTickLength = function () {\n    var internal = this;\n    internal.tickLength = Math.max(internal.innerTickSize, 0) + internal.tickPadding;\n  };\n\n  c3_axis_internal_fn.lineY2 = function (d) {\n    var internal = this,\n        tickPosition = internal.scale(d) + (internal.tickCentered ? 0 : internal.tickOffset);\n    return internal.range[0] < tickPosition && tickPosition < internal.range[1] ? internal.innerTickSize : 0;\n  };\n\n  c3_axis_internal_fn.textY = function () {\n    var internal = this,\n        rotate = internal.tickTextRotate;\n    return rotate ? 11.5 - 2.5 * (rotate / 15) * (rotate > 0 ? 1 : -1) : internal.tickLength;\n  };\n\n  c3_axis_internal_fn.textTransform = function () {\n    var internal = this,\n        rotate = internal.tickTextRotate;\n    return rotate ? \"rotate(\" + rotate + \")\" : \"\";\n  };\n\n  c3_axis_internal_fn.textTextAnchor = function () {\n    var internal = this,\n        rotate = internal.tickTextRotate;\n    return rotate ? rotate > 0 ? \"start\" : \"end\" : \"middle\";\n  };\n\n  c3_axis_internal_fn.tspanDx = function () {\n    var internal = this,\n        rotate = internal.tickTextRotate;\n    return rotate ? 8 * Math.sin(Math.PI * (rotate / 180)) : 0;\n  };\n\n  c3_axis_internal_fn.tspanDy = function (d, i) {\n    var internal = this,\n        dy = internal.tickTextCharSize.h;\n\n    if (i === 0) {\n      if (internal.isVertical()) {\n        dy = -((d.length - 1) * (internal.tickTextCharSize.h / 2) - 3);\n      } else {\n        dy = \".71em\";\n      }\n    }\n\n    return dy;\n  };\n\n  c3_axis_internal_fn.generateAxis = function () {\n    var internal = this,\n        d3 = internal.d3,\n        params = internal.params;\n\n    function axis(g) {\n      g.each(function () {\n        var g = axis.g = d3.select(this);\n        var scale0 = this.__chart__ || internal.scale,\n            scale1 = this.__chart__ = internal.copyScale();\n        var ticks = internal.tickValues ? internal.tickValues : internal.generateTicks(scale1),\n            tick = g.selectAll(\".tick\").data(ticks, scale1),\n            tickEnter = tick.enter().insert(\"g\", \".domain\").attr(\"class\", \"tick\").style(\"opacity\", 1e-6),\n            // MEMO: No exit transition. The reason is this transition affects max tick width calculation because old tick will be included in the ticks.\n        tickExit = tick.exit().remove(),\n            tickUpdate = internal.transitionise(tick).style(\"opacity\", 1),\n            tickTransform,\n            tickX,\n            tickY;\n\n        if (params.isCategory) {\n          internal.tickOffset = Math.ceil((scale1(1) - scale1(0)) / 2);\n          tickX = internal.tickCentered ? 0 : internal.tickOffset;\n          tickY = internal.tickCentered ? internal.tickOffset : 0;\n        } else {\n          internal.tickOffset = tickX = 0;\n        }\n\n        tickEnter.append(\"line\");\n        tickEnter.append(\"text\");\n        internal.updateRange();\n        internal.updateTickLength();\n        internal.updateTickTextCharSize(g.select('.tick'));\n        var lineUpdate = tickUpdate.select(\"line\"),\n            textUpdate = tickUpdate.select(\"text\"),\n            tspanUpdate = tick.select(\"text\").selectAll('tspan').data(function (d, i) {\n          return internal.tspanData(d, i, ticks, scale1);\n        });\n        tspanUpdate.enter().append('tspan');\n        tspanUpdate.exit().remove();\n        tspanUpdate.text(function (d) {\n          return d.splitted;\n        });\n        var path = g.selectAll(\".domain\").data([0]),\n            pathUpdate = (path.enter().append(\"path\").attr(\"class\", \"domain\"), internal.transitionise(path)); // TODO: each attr should be one function and change its behavior by internal.orient, probably\n\n        switch (internal.orient) {\n          case \"bottom\":\n            {\n              tickTransform = internal.axisX;\n              lineUpdate.attr(\"x1\", tickX).attr(\"x2\", tickX).attr(\"y2\", function (d, i) {\n                return internal.lineY2(d, i);\n              });\n              textUpdate.attr(\"x\", 0).attr(\"y\", function (d, i) {\n                return internal.textY(d, i);\n              }).attr(\"transform\", function (d, i) {\n                return internal.textTransform(d, i);\n              }).style(\"text-anchor\", function (d, i) {\n                return internal.textTextAnchor(d, i);\n              });\n              tspanUpdate.attr('x', 0).attr(\"dy\", function (d, i) {\n                return internal.tspanDy(d, i);\n              }).attr('dx', function (d, i) {\n                return internal.tspanDx(d, i);\n              });\n              pathUpdate.attr(\"d\", \"M\" + internal.range[0] + \",\" + internal.outerTickSize + \"V0H\" + internal.range[1] + \"V\" + internal.outerTickSize);\n              break;\n            }\n\n          case \"top\":\n            {\n              // TODO: rotated tick text\n              tickTransform = internal.axisX;\n              lineUpdate.attr(\"x1\", tickX).attr(\"x2\", tickX).attr(\"y2\", function (d, i) {\n                return -1 * internal.lineY2(d, i);\n              });\n              textUpdate.attr(\"x\", 0).attr(\"y\", function (d, i) {\n                return -1 * internal.textY(d, i) - (params.isCategory ? 2 : internal.tickLength - 2);\n              }).attr(\"transform\", function (d, i) {\n                return internal.textTransform(d, i);\n              }).style(\"text-anchor\", function (d, i) {\n                return internal.textTextAnchor(d, i);\n              });\n              tspanUpdate.attr('x', 0).attr(\"dy\", function (d, i) {\n                return internal.tspanDy(d, i);\n              }).attr('dx', function (d, i) {\n                return internal.tspanDx(d, i);\n              });\n              pathUpdate.attr(\"d\", \"M\" + internal.range[0] + \",\" + -internal.outerTickSize + \"V0H\" + internal.range[1] + \"V\" + -internal.outerTickSize);\n              break;\n            }\n\n          case \"left\":\n            {\n              tickTransform = internal.axisY;\n              lineUpdate.attr(\"x2\", -internal.innerTickSize).attr(\"y1\", tickY).attr(\"y2\", tickY);\n              textUpdate.attr(\"x\", -internal.tickLength).attr(\"y\", internal.tickOffset).style(\"text-anchor\", \"end\");\n              tspanUpdate.attr('x', -internal.tickLength).attr(\"dy\", function (d, i) {\n                return internal.tspanDy(d, i);\n              });\n              pathUpdate.attr(\"d\", \"M\" + -internal.outerTickSize + \",\" + internal.range[0] + \"H0V\" + internal.range[1] + \"H\" + -internal.outerTickSize);\n              break;\n            }\n\n          case \"right\":\n            {\n              tickTransform = internal.axisY;\n              lineUpdate.attr(\"x2\", internal.innerTickSize).attr(\"y1\", tickY).attr(\"y2\", tickY);\n              textUpdate.attr(\"x\", internal.tickLength).attr(\"y\", internal.tickOffset).style(\"text-anchor\", \"start\");\n              tspanUpdate.attr('x', internal.tickLength).attr(\"dy\", function (d, i) {\n                return internal.tspanDy(d, i);\n              });\n              pathUpdate.attr(\"d\", \"M\" + internal.outerTickSize + \",\" + internal.range[0] + \"H0V\" + internal.range[1] + \"H\" + internal.outerTickSize);\n              break;\n            }\n        }\n\n        if (scale1.rangeBand) {\n          var x = scale1,\n              dx = x.rangeBand() / 2;\n\n          scale0 = scale1 = function scale1(d) {\n            return x(d) + dx;\n          };\n        } else if (scale0.rangeBand) {\n          scale0 = scale1;\n        } else {\n          tickExit.call(tickTransform, scale1, internal.tickOffset);\n        }\n\n        tickEnter.call(tickTransform, scale0, internal.tickOffset);\n        tickUpdate.call(tickTransform, scale1, internal.tickOffset);\n      });\n    }\n\n    axis.scale = function (x) {\n      if (!arguments.length) {\n        return internal.scale;\n      }\n\n      internal.scale = x;\n      return axis;\n    };\n\n    axis.orient = function (x) {\n      if (!arguments.length) {\n        return internal.orient;\n      }\n\n      internal.orient = x in {\n        top: 1,\n        right: 1,\n        bottom: 1,\n        left: 1\n      } ? x + \"\" : \"bottom\";\n      return axis;\n    };\n\n    axis.tickFormat = function (format) {\n      if (!arguments.length) {\n        return internal.tickFormat;\n      }\n\n      internal.tickFormat = format;\n      return axis;\n    };\n\n    axis.tickCentered = function (isCentered) {\n      if (!arguments.length) {\n        return internal.tickCentered;\n      }\n\n      internal.tickCentered = isCentered;\n      return axis;\n    };\n\n    axis.tickOffset = function () {\n      return internal.tickOffset;\n    };\n\n    axis.tickInterval = function () {\n      var interval, length;\n\n      if (params.isCategory) {\n        interval = internal.tickOffset * 2;\n      } else {\n        length = axis.g.select('path.domain').node().getTotalLength() - internal.outerTickSize * 2;\n        interval = length / axis.g.selectAll('line').size();\n      }\n\n      return interval === Infinity ? 0 : interval;\n    };\n\n    axis.ticks = function () {\n      if (!arguments.length) {\n        return internal.tickArguments;\n      }\n\n      internal.tickArguments = arguments;\n      return axis;\n    };\n\n    axis.tickCulling = function (culling) {\n      if (!arguments.length) {\n        return internal.tickCulling;\n      }\n\n      internal.tickCulling = culling;\n      return axis;\n    };\n\n    axis.tickValues = function (x) {\n      if (typeof x === 'function') {\n        internal.tickValues = function () {\n          return x(internal.scale.domain());\n        };\n      } else {\n        if (!arguments.length) {\n          return internal.tickValues;\n        }\n\n        internal.tickValues = x;\n      }\n\n      return axis;\n    };\n\n    return axis;\n  };\n\n  var Axis = function (_Component) {\n    inherits(Axis, _Component);\n\n    function Axis(owner) {\n      classCallCheck(this, Axis);\n      var fn = {\n        fn: c3_axis_fn,\n        internal: {\n          fn: c3_axis_internal_fn\n        }\n      };\n\n      var _this = possibleConstructorReturn(this, (Axis.__proto__ || Object.getPrototypeOf(Axis)).call(this, owner, 'axis', fn));\n\n      _this.d3 = owner.d3;\n      _this.internal = AxisInternal;\n      return _this;\n    }\n\n    return Axis;\n  }(Component);\n\n  c3_axis_fn = Axis.prototype;\n\n  c3_axis_fn.init = function init() {\n    var $$ = this.owner,\n        config = $$.config,\n        main = $$.main;\n    $$.axes.x = main.append(\"g\").attr(\"class\", CLASS.axis + ' ' + CLASS.axisX).attr(\"clip-path\", config.axis_x_inner ? \"\" : $$.clipPathForXAxis).attr(\"transform\", $$.getTranslate('x')).style(\"visibility\", config.axis_x_show ? 'visible' : 'hidden');\n    $$.axes.x.append(\"text\").attr(\"class\", CLASS.axisXLabel).attr(\"transform\", config.axis_rotated ? \"rotate(-90)\" : \"\").style(\"text-anchor\", this.textAnchorForXAxisLabel.bind(this));\n    $$.axes.y = main.append(\"g\").attr(\"class\", CLASS.axis + ' ' + CLASS.axisY).attr(\"clip-path\", config.axis_y_inner ? \"\" : $$.clipPathForYAxis).attr(\"transform\", $$.getTranslate('y')).style(\"visibility\", config.axis_y_show ? 'visible' : 'hidden');\n    $$.axes.y.append(\"text\").attr(\"class\", CLASS.axisYLabel).attr(\"transform\", config.axis_rotated ? \"\" : \"rotate(-90)\").style(\"text-anchor\", this.textAnchorForYAxisLabel.bind(this));\n    $$.axes.y2 = main.append(\"g\").attr(\"class\", CLASS.axis + ' ' + CLASS.axisY2) // clip-path?\n    .attr(\"transform\", $$.getTranslate('y2')).style(\"visibility\", config.axis_y2_show ? 'visible' : 'hidden');\n    $$.axes.y2.append(\"text\").attr(\"class\", CLASS.axisY2Label).attr(\"transform\", config.axis_rotated ? \"\" : \"rotate(-90)\").style(\"text-anchor\", this.textAnchorForY2AxisLabel.bind(this));\n  };\n\n  c3_axis_fn.getXAxis = function getXAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {\n    var $$ = this.owner,\n        config = $$.config,\n        axisParams = {\n      isCategory: $$.isCategorized(),\n      withOuterTick: withOuterTick,\n      tickMultiline: config.axis_x_tick_multiline,\n      tickMultilineMax: config.axis_x_tick_multiline ? Number(config.axis_x_tick_multilineMax) : 0,\n      tickWidth: config.axis_x_tick_width,\n      tickTextRotate: withoutRotateTickText ? 0 : config.axis_x_tick_rotate,\n      withoutTransition: withoutTransition\n    },\n        axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient);\n\n    if ($$.isTimeSeries() && tickValues && typeof tickValues !== \"function\") {\n      tickValues = tickValues.map(function (v) {\n        return $$.parseDate(v);\n      });\n    } // Set tick\n\n\n    axis.tickFormat(tickFormat).tickValues(tickValues);\n\n    if ($$.isCategorized()) {\n      axis.tickCentered(config.axis_x_tick_centered);\n\n      if (isEmpty(config.axis_x_tick_culling)) {\n        config.axis_x_tick_culling = false;\n      }\n    }\n\n    return axis;\n  };\n\n  c3_axis_fn.updateXAxisTickValues = function updateXAxisTickValues(targets, axis) {\n    var $$ = this.owner,\n        config = $$.config,\n        tickValues;\n\n    if (config.axis_x_tick_fit || config.axis_x_tick_count) {\n      tickValues = this.generateTickValues($$.mapTargetsToUniqueXs(targets), config.axis_x_tick_count, $$.isTimeSeries());\n    }\n\n    if (axis) {\n      axis.tickValues(tickValues);\n    } else {\n      $$.xAxis.tickValues(tickValues);\n      $$.subXAxis.tickValues(tickValues);\n    }\n\n    return tickValues;\n  };\n\n  c3_axis_fn.getYAxis = function getYAxis(scale, orient, tickFormat, tickValues, withOuterTick, withoutTransition, withoutRotateTickText) {\n    var $$ = this.owner,\n        config = $$.config,\n        axisParams = {\n      withOuterTick: withOuterTick,\n      withoutTransition: withoutTransition,\n      tickTextRotate: withoutRotateTickText ? 0 : config.axis_y_tick_rotate\n    },\n        axis = new this.internal(this, axisParams).axis.scale(scale).orient(orient).tickFormat(tickFormat);\n\n    if ($$.isTimeSeriesY()) {\n      axis.ticks($$.d3.time[config.axis_y_tick_time_value], config.axis_y_tick_time_interval);\n    } else {\n      axis.tickValues(tickValues);\n    }\n\n    return axis;\n  };\n\n  c3_axis_fn.getId = function getId(id) {\n    var config = this.owner.config;\n    return id in config.data_axes ? config.data_axes[id] : 'y';\n  };\n\n  c3_axis_fn.getXAxisTickFormat = function getXAxisTickFormat() {\n    var $$ = this.owner,\n        config = $$.config,\n        format = $$.isTimeSeries() ? $$.defaultAxisTimeFormat : $$.isCategorized() ? $$.categoryName : function (v) {\n      return v < 0 ? v.toFixed(0) : v;\n    };\n\n    if (config.axis_x_tick_format) {\n      if (isFunction(config.axis_x_tick_format)) {\n        format = config.axis_x_tick_format;\n      } else if ($$.isTimeSeries()) {\n        format = function format(date) {\n          return date ? $$.axisTimeFormat(config.axis_x_tick_format)(date) : \"\";\n        };\n      }\n    }\n\n    return isFunction(format) ? function (v) {\n      return format.call($$, v);\n    } : format;\n  };\n\n  c3_axis_fn.getTickValues = function getTickValues(tickValues, axis) {\n    return tickValues ? tickValues : axis ? axis.tickValues() : undefined;\n  };\n\n  c3_axis_fn.getXAxisTickValues = function getXAxisTickValues() {\n    return this.getTickValues(this.owner.config.axis_x_tick_values, this.owner.xAxis);\n  };\n\n  c3_axis_fn.getYAxisTickValues = function getYAxisTickValues() {\n    return this.getTickValues(this.owner.config.axis_y_tick_values, this.owner.yAxis);\n  };\n\n  c3_axis_fn.getY2AxisTickValues = function getY2AxisTickValues() {\n    return this.getTickValues(this.owner.config.axis_y2_tick_values, this.owner.y2Axis);\n  };\n\n  c3_axis_fn.getLabelOptionByAxisId = function getLabelOptionByAxisId(axisId) {\n    var $$ = this.owner,\n        config = $$.config,\n        option;\n\n    if (axisId === 'y') {\n      option = config.axis_y_label;\n    } else if (axisId === 'y2') {\n      option = config.axis_y2_label;\n    } else if (axisId === 'x') {\n      option = config.axis_x_label;\n    }\n\n    return option;\n  };\n\n  c3_axis_fn.getLabelText = function getLabelText(axisId) {\n    var option = this.getLabelOptionByAxisId(axisId);\n    return isString(option) ? option : option ? option.text : null;\n  };\n\n  c3_axis_fn.setLabelText = function setLabelText(axisId, text) {\n    var $$ = this.owner,\n        config = $$.config,\n        option = this.getLabelOptionByAxisId(axisId);\n\n    if (isString(option)) {\n      if (axisId === 'y') {\n        config.axis_y_label = text;\n      } else if (axisId === 'y2') {\n        config.axis_y2_label = text;\n      } else if (axisId === 'x') {\n        config.axis_x_label = text;\n      }\n    } else if (option) {\n      option.text = text;\n    }\n  };\n\n  c3_axis_fn.getLabelPosition = function getLabelPosition(axisId, defaultPosition) {\n    var option = this.getLabelOptionByAxisId(axisId),\n        position = option && (typeof option === 'undefined' ? 'undefined' : _typeof(option)) === 'object' && option.position ? option.position : defaultPosition;\n    return {\n      isInner: position.indexOf('inner') >= 0,\n      isOuter: position.indexOf('outer') >= 0,\n      isLeft: position.indexOf('left') >= 0,\n      isCenter: position.indexOf('center') >= 0,\n      isRight: position.indexOf('right') >= 0,\n      isTop: position.indexOf('top') >= 0,\n      isMiddle: position.indexOf('middle') >= 0,\n      isBottom: position.indexOf('bottom') >= 0\n    };\n  };\n\n  c3_axis_fn.getXAxisLabelPosition = function getXAxisLabelPosition() {\n    return this.getLabelPosition('x', this.owner.config.axis_rotated ? 'inner-top' : 'inner-right');\n  };\n\n  c3_axis_fn.getYAxisLabelPosition = function getYAxisLabelPosition() {\n    return this.getLabelPosition('y', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');\n  };\n\n  c3_axis_fn.getY2AxisLabelPosition = function getY2AxisLabelPosition() {\n    return this.getLabelPosition('y2', this.owner.config.axis_rotated ? 'inner-right' : 'inner-top');\n  };\n\n  c3_axis_fn.getLabelPositionById = function getLabelPositionById(id) {\n    return id === 'y2' ? this.getY2AxisLabelPosition() : id === 'y' ? this.getYAxisLabelPosition() : this.getXAxisLabelPosition();\n  };\n\n  c3_axis_fn.textForXAxisLabel = function textForXAxisLabel() {\n    return this.getLabelText('x');\n  };\n\n  c3_axis_fn.textForYAxisLabel = function textForYAxisLabel() {\n    return this.getLabelText('y');\n  };\n\n  c3_axis_fn.textForY2AxisLabel = function textForY2AxisLabel() {\n    return this.getLabelText('y2');\n  };\n\n  c3_axis_fn.xForAxisLabel = function xForAxisLabel(forHorizontal, position) {\n    var $$ = this.owner;\n\n    if (forHorizontal) {\n      return position.isLeft ? 0 : position.isCenter ? $$.width / 2 : $$.width;\n    } else {\n      return position.isBottom ? -$$.height : position.isMiddle ? -$$.height / 2 : 0;\n    }\n  };\n\n  c3_axis_fn.dxForAxisLabel = function dxForAxisLabel(forHorizontal, position) {\n    if (forHorizontal) {\n      return position.isLeft ? \"0.5em\" : position.isRight ? \"-0.5em\" : \"0\";\n    } else {\n      return position.isTop ? \"-0.5em\" : position.isBottom ? \"0.5em\" : \"0\";\n    }\n  };\n\n  c3_axis_fn.textAnchorForAxisLabel = function textAnchorForAxisLabel(forHorizontal, position) {\n    if (forHorizontal) {\n      return position.isLeft ? 'start' : position.isCenter ? 'middle' : 'end';\n    } else {\n      return position.isBottom ? 'start' : position.isMiddle ? 'middle' : 'end';\n    }\n  };\n\n  c3_axis_fn.xForXAxisLabel = function xForXAxisLabel() {\n    return this.xForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());\n  };\n\n  c3_axis_fn.xForYAxisLabel = function xForYAxisLabel() {\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());\n  };\n\n  c3_axis_fn.xForY2AxisLabel = function xForY2AxisLabel() {\n    return this.xForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());\n  };\n\n  c3_axis_fn.dxForXAxisLabel = function dxForXAxisLabel() {\n    return this.dxForAxisLabel(!this.owner.config.axis_rotated, this.getXAxisLabelPosition());\n  };\n\n  c3_axis_fn.dxForYAxisLabel = function dxForYAxisLabel() {\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getYAxisLabelPosition());\n  };\n\n  c3_axis_fn.dxForY2AxisLabel = function dxForY2AxisLabel() {\n    return this.dxForAxisLabel(this.owner.config.axis_rotated, this.getY2AxisLabelPosition());\n  };\n\n  c3_axis_fn.dyForXAxisLabel = function dyForXAxisLabel() {\n    var $$ = this.owner,\n        config = $$.config,\n        position = this.getXAxisLabelPosition();\n\n    if (config.axis_rotated) {\n      return position.isInner ? \"1.2em\" : -25 - ($$.config.axis_x_inner ? 0 : this.getMaxTickWidth('x'));\n    } else {\n      return position.isInner ? \"-0.5em\" : config.axis_x_height ? config.axis_x_height - 10 : \"3em\";\n    }\n  };\n\n  c3_axis_fn.dyForYAxisLabel = function dyForYAxisLabel() {\n    var $$ = this.owner,\n        position = this.getYAxisLabelPosition();\n\n    if ($$.config.axis_rotated) {\n      return position.isInner ? \"-0.5em\" : \"3em\";\n    } else {\n      return position.isInner ? \"1.2em\" : -10 - ($$.config.axis_y_inner ? 0 : this.getMaxTickWidth('y') + 10);\n    }\n  };\n\n  c3_axis_fn.dyForY2AxisLabel = function dyForY2AxisLabel() {\n    var $$ = this.owner,\n        position = this.getY2AxisLabelPosition();\n\n    if ($$.config.axis_rotated) {\n      return position.isInner ? \"1.2em\" : \"-2.2em\";\n    } else {\n      return position.isInner ? \"-0.5em\" : 15 + ($$.config.axis_y2_inner ? 0 : this.getMaxTickWidth('y2') + 15);\n    }\n  };\n\n  c3_axis_fn.textAnchorForXAxisLabel = function textAnchorForXAxisLabel() {\n    var $$ = this.owner;\n    return this.textAnchorForAxisLabel(!$$.config.axis_rotated, this.getXAxisLabelPosition());\n  };\n\n  c3_axis_fn.textAnchorForYAxisLabel = function textAnchorForYAxisLabel() {\n    var $$ = this.owner;\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getYAxisLabelPosition());\n  };\n\n  c3_axis_fn.textAnchorForY2AxisLabel = function textAnchorForY2AxisLabel() {\n    var $$ = this.owner;\n    return this.textAnchorForAxisLabel($$.config.axis_rotated, this.getY2AxisLabelPosition());\n  };\n\n  c3_axis_fn.getMaxTickWidth = function getMaxTickWidth(id, withoutRecompute) {\n    var $$ = this.owner,\n        config = $$.config,\n        maxWidth = 0,\n        targetsToShow,\n        scale,\n        axis,\n        dummy,\n        svg;\n\n    if (withoutRecompute && $$.currentMaxTickWidths[id]) {\n      return $$.currentMaxTickWidths[id];\n    }\n\n    if ($$.svg) {\n      targetsToShow = $$.filterTargetsToShow($$.data.targets);\n\n      if (id === 'y') {\n        scale = $$.y.copy().domain($$.getYDomain(targetsToShow, 'y'));\n        axis = this.getYAxis(scale, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, false, true, true);\n      } else if (id === 'y2') {\n        scale = $$.y2.copy().domain($$.getYDomain(targetsToShow, 'y2'));\n        axis = this.getYAxis(scale, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, false, true, true);\n      } else {\n        scale = $$.x.copy().domain($$.getXDomain(targetsToShow));\n        axis = this.getXAxis(scale, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, false, true, true);\n        this.updateXAxisTickValues(targetsToShow, axis);\n      }\n\n      dummy = $$.d3.select('body').append('div').classed('c3', true);\n      svg = dummy.append(\"svg\").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0), svg.append('g').call(axis).each(function () {\n        $$.d3.select(this).selectAll('text').each(function () {\n          var box = this.getBoundingClientRect();\n\n          if (maxWidth < box.width) {\n            maxWidth = box.width;\n          }\n        });\n        dummy.remove();\n      });\n    }\n\n    $$.currentMaxTickWidths[id] = maxWidth <= 0 ? $$.currentMaxTickWidths[id] : maxWidth;\n    return $$.currentMaxTickWidths[id];\n  };\n\n  c3_axis_fn.updateLabels = function updateLabels(withTransition) {\n    var $$ = this.owner;\n    var axisXLabel = $$.main.select('.' + CLASS.axisX + ' .' + CLASS.axisXLabel),\n        axisYLabel = $$.main.select('.' + CLASS.axisY + ' .' + CLASS.axisYLabel),\n        axisY2Label = $$.main.select('.' + CLASS.axisY2 + ' .' + CLASS.axisY2Label);\n    (withTransition ? axisXLabel.transition() : axisXLabel).attr(\"x\", this.xForXAxisLabel.bind(this)).attr(\"dx\", this.dxForXAxisLabel.bind(this)).attr(\"dy\", this.dyForXAxisLabel.bind(this)).text(this.textForXAxisLabel.bind(this));\n    (withTransition ? axisYLabel.transition() : axisYLabel).attr(\"x\", this.xForYAxisLabel.bind(this)).attr(\"dx\", this.dxForYAxisLabel.bind(this)).attr(\"dy\", this.dyForYAxisLabel.bind(this)).text(this.textForYAxisLabel.bind(this));\n    (withTransition ? axisY2Label.transition() : axisY2Label).attr(\"x\", this.xForY2AxisLabel.bind(this)).attr(\"dx\", this.dxForY2AxisLabel.bind(this)).attr(\"dy\", this.dyForY2AxisLabel.bind(this)).text(this.textForY2AxisLabel.bind(this));\n  };\n\n  c3_axis_fn.getPadding = function getPadding(padding, key, defaultValue, domainLength) {\n    var p = typeof padding === 'number' ? padding : padding[key];\n\n    if (!isValue(p)) {\n      return defaultValue;\n    }\n\n    if (padding.unit === 'ratio') {\n      return padding[key] * domainLength;\n    } // assume padding is pixels if unit is not specified\n\n\n    return this.convertPixelsToAxisPadding(p, domainLength);\n  };\n\n  c3_axis_fn.convertPixelsToAxisPadding = function convertPixelsToAxisPadding(pixels, domainLength) {\n    var $$ = this.owner,\n        length = $$.config.axis_rotated ? $$.width : $$.height;\n    return domainLength * (pixels / length);\n  };\n\n  c3_axis_fn.generateTickValues = function generateTickValues(values, tickCount, forTimeSeries) {\n    var tickValues = values,\n        targetCount,\n        start,\n        end,\n        count,\n        interval,\n        i,\n        tickValue;\n\n    if (tickCount) {\n      targetCount = isFunction(tickCount) ? tickCount() : tickCount; // compute ticks according to tickCount\n\n      if (targetCount === 1) {\n        tickValues = [values[0]];\n      } else if (targetCount === 2) {\n        tickValues = [values[0], values[values.length - 1]];\n      } else if (targetCount > 2) {\n        count = targetCount - 2;\n        start = values[0];\n        end = values[values.length - 1];\n        interval = (end - start) / (count + 1); // re-construct unique values\n\n        tickValues = [start];\n\n        for (i = 0; i < count; i++) {\n          tickValue = +start + interval * (i + 1);\n          tickValues.push(forTimeSeries ? new Date(tickValue) : tickValue);\n        }\n\n        tickValues.push(end);\n      }\n    }\n\n    if (!forTimeSeries) {\n      tickValues = tickValues.sort(function (a, b) {\n        return a - b;\n      });\n    }\n\n    return tickValues;\n  };\n\n  c3_axis_fn.generateTransitions = function generateTransitions(duration) {\n    var $$ = this.owner,\n        axes = $$.axes;\n    return {\n      axisX: duration ? axes.x.transition().duration(duration) : axes.x,\n      axisY: duration ? axes.y.transition().duration(duration) : axes.y,\n      axisY2: duration ? axes.y2.transition().duration(duration) : axes.y2,\n      axisSubX: duration ? axes.subx.transition().duration(duration) : axes.subx\n    };\n  };\n\n  c3_axis_fn.redraw = function redraw(transitions, isHidden) {\n    var $$ = this.owner;\n    $$.axes.x.style(\"opacity\", isHidden ? 0 : 1);\n    $$.axes.y.style(\"opacity\", isHidden ? 0 : 1);\n    $$.axes.y2.style(\"opacity\", isHidden ? 0 : 1);\n    $$.axes.subx.style(\"opacity\", isHidden ? 0 : 1);\n    transitions.axisX.call($$.xAxis);\n    transitions.axisY.call($$.yAxis);\n    transitions.axisY2.call($$.y2Axis);\n    transitions.axisSubX.call($$.subXAxis);\n  };\n\n  var c3 = {\n    version: \"0.4.23\"\n  };\n  var c3_chart_fn;\n  var c3_chart_internal_fn;\n\n  function Component(owner, componentKey, fn) {\n    this.owner = owner;\n    c3.chart.internal[componentKey] = fn;\n  }\n\n  function Chart(config) {\n    var $$ = this.internal = new ChartInternal(this);\n    $$.loadConfig(config);\n    $$.beforeInit(config);\n    $$.init();\n    $$.afterInit(config); // bind \"this\" to nested API\n\n    (function bindThis(fn, target, argThis) {\n      Object.keys(fn).forEach(function (key) {\n        target[key] = fn[key].bind(argThis);\n\n        if (Object.keys(fn[key]).length > 0) {\n          bindThis(fn[key], target[key], argThis);\n        }\n      });\n    })(c3_chart_fn, this, this);\n  }\n\n  function ChartInternal(api) {\n    var $$ = this;\n    $$.d3 = window.d3 ? window.d3 : typeof require !== 'undefined' ? require(\"d3\") : undefined;\n    $$.api = api;\n    $$.config = $$.getDefaultConfig();\n    $$.data = {};\n    $$.cache = {};\n    $$.axes = {};\n  }\n\n  c3.generate = function (config) {\n    return new Chart(config);\n  };\n\n  c3.chart = {\n    fn: Chart.prototype,\n    internal: {\n      fn: ChartInternal.prototype\n    }\n  };\n  c3_chart_fn = c3.chart.fn;\n  c3_chart_internal_fn = c3.chart.internal.fn;\n\n  c3_chart_internal_fn.beforeInit = function () {// can do something\n  };\n\n  c3_chart_internal_fn.afterInit = function () {// can do something\n  };\n\n  c3_chart_internal_fn.init = function () {\n    var $$ = this,\n        config = $$.config;\n    $$.initParams();\n\n    if (config.data_url) {\n      $$.convertUrlToData(config.data_url, config.data_mimeType, config.data_headers, config.data_keys, $$.initWithData);\n    } else if (config.data_json) {\n      $$.initWithData($$.convertJsonToData(config.data_json, config.data_keys));\n    } else if (config.data_rows) {\n      $$.initWithData($$.convertRowsToData(config.data_rows));\n    } else if (config.data_columns) {\n      $$.initWithData($$.convertColumnsToData(config.data_columns));\n    } else {\n      throw Error('url or json or rows or columns is required.');\n    }\n  };\n\n  c3_chart_internal_fn.initParams = function () {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config; // MEMO: clipId needs to be unique because it conflicts when multiple charts exist\n\n    $$.clipId = \"c3-\" + +new Date() + '-clip', $$.clipIdForXAxis = $$.clipId + '-xaxis', $$.clipIdForYAxis = $$.clipId + '-yaxis', $$.clipIdForGrid = $$.clipId + '-grid', $$.clipIdForSubchart = $$.clipId + '-subchart', $$.clipPath = $$.getClipPath($$.clipId), $$.clipPathForXAxis = $$.getClipPath($$.clipIdForXAxis), $$.clipPathForYAxis = $$.getClipPath($$.clipIdForYAxis);\n    $$.clipPathForGrid = $$.getClipPath($$.clipIdForGrid), $$.clipPathForSubchart = $$.getClipPath($$.clipIdForSubchart), $$.dragStart = null;\n    $$.dragging = false;\n    $$.flowing = false;\n    $$.cancelClick = false;\n    $$.mouseover = false;\n    $$.transiting = false;\n    $$.color = $$.generateColor();\n    $$.levelColor = $$.generateLevelColor();\n    $$.dataTimeFormat = config.data_xLocaltime ? d3.time.format : d3.time.format.utc;\n    $$.axisTimeFormat = config.axis_x_localtime ? d3.time.format : d3.time.format.utc;\n    $$.defaultAxisTimeFormat = $$.axisTimeFormat.multi([[\".%L\", function (d) {\n      return d.getMilliseconds();\n    }], [\":%S\", function (d) {\n      return d.getSeconds();\n    }], [\"%I:%M\", function (d) {\n      return d.getMinutes();\n    }], [\"%I %p\", function (d) {\n      return d.getHours();\n    }], [\"%-m/%-d\", function (d) {\n      return d.getDay() && d.getDate() !== 1;\n    }], [\"%-m/%-d\", function (d) {\n      return d.getDate() !== 1;\n    }], [\"%-m/%-d\", function (d) {\n      return d.getMonth();\n    }], [\"%Y/%-m/%-d\", function () {\n      return true;\n    }]]);\n    $$.hiddenTargetIds = [];\n    $$.hiddenLegendIds = [];\n    $$.focusedTargetIds = [];\n    $$.defocusedTargetIds = [];\n    $$.xOrient = config.axis_rotated ? config.axis_x_inner ? \"right\" : \"left\" : config.axis_x_inner ? \"top\" : \"bottom\";\n    $$.yOrient = config.axis_rotated ? config.axis_y_inner ? \"top\" : \"bottom\" : config.axis_y_inner ? \"right\" : \"left\";\n    $$.y2Orient = config.axis_rotated ? config.axis_y2_inner ? \"bottom\" : \"top\" : config.axis_y2_inner ? \"left\" : \"right\";\n    $$.subXOrient = config.axis_rotated ? \"left\" : \"bottom\";\n    $$.isLegendRight = config.legend_position === 'right';\n    $$.isLegendInset = config.legend_position === 'inset';\n    $$.isLegendTop = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'top-right';\n    $$.isLegendLeft = config.legend_inset_anchor === 'top-left' || config.legend_inset_anchor === 'bottom-left';\n    $$.legendStep = 0;\n    $$.legendItemWidth = 0;\n    $$.legendItemHeight = 0;\n    $$.currentMaxTickWidths = {\n      x: 0,\n      y: 0,\n      y2: 0\n    };\n    $$.rotated_padding_left = 30;\n    $$.rotated_padding_right = config.axis_rotated && !config.axis_x_show ? 0 : 30;\n    $$.rotated_padding_top = 5;\n    $$.withoutFadeIn = {};\n    $$.intervalForObserveInserted = undefined;\n    $$.axes.subx = d3.selectAll([]); // needs when excluding subchart.js\n  };\n\n  c3_chart_internal_fn.initChartElements = function () {\n    if (this.initBar) {\n      this.initBar();\n    }\n\n    if (this.initLine) {\n      this.initLine();\n    }\n\n    if (this.initArc) {\n      this.initArc();\n    }\n\n    if (this.initGauge) {\n      this.initGauge();\n    }\n\n    if (this.initText) {\n      this.initText();\n    }\n  };\n\n  c3_chart_internal_fn.initWithData = function (data) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config;\n    var defs,\n        main,\n        binding = true;\n    $$.axis = new Axis($$);\n\n    if ($$.initPie) {\n      $$.initPie();\n    }\n\n    if ($$.initBrush) {\n      $$.initBrush();\n    }\n\n    if ($$.initZoom) {\n      $$.initZoom();\n    }\n\n    if (!config.bindto) {\n      $$.selectChart = d3.selectAll([]);\n    } else if (typeof config.bindto.node === 'function') {\n      $$.selectChart = config.bindto;\n    } else {\n      $$.selectChart = d3.select(config.bindto);\n    }\n\n    if ($$.selectChart.empty()) {\n      $$.selectChart = d3.select(document.createElement('div')).style('opacity', 0);\n      $$.observeInserted($$.selectChart);\n      binding = false;\n    }\n\n    $$.selectChart.html(\"\").classed(\"c3\", true); // Init data as targets\n\n    $$.data.xs = {};\n    $$.data.targets = $$.convertDataToTargets(data);\n\n    if (config.data_filter) {\n      $$.data.targets = $$.data.targets.filter(config.data_filter);\n    } // Set targets to hide if needed\n\n\n    if (config.data_hide) {\n      $$.addHiddenTargetIds(config.data_hide === true ? $$.mapToIds($$.data.targets) : config.data_hide);\n    }\n\n    if (config.legend_hide) {\n      $$.addHiddenLegendIds(config.legend_hide === true ? $$.mapToIds($$.data.targets) : config.legend_hide);\n    } // Init sizes and scales\n\n\n    $$.updateSizes();\n    $$.updateScales(); // Set domains for each scale\n\n    $$.x.domain(d3.extent($$.getXDomain($$.data.targets)));\n    $$.y.domain($$.getYDomain($$.data.targets, 'y'));\n    $$.y2.domain($$.getYDomain($$.data.targets, 'y2'));\n    $$.subX.domain($$.x.domain());\n    $$.subY.domain($$.y.domain());\n    $$.subY2.domain($$.y2.domain()); // Save original x domain for zoom update\n\n    $$.orgXDomain = $$.x.domain(); // Set initialized scales to brush and zoom\n\n    if ($$.brush) {\n      $$.brush.scale($$.subX);\n    }\n\n    if (config.zoom_enabled) {\n      $$.zoom.scale($$.x);\n    }\n    /*-- Basic Elements --*/\n    // Define svgs\n\n\n    $$.svg = $$.selectChart.append(\"svg\").style(\"overflow\", \"hidden\").on('mouseenter', function () {\n      return config.onmouseover.call($$);\n    }).on('mouseleave', function () {\n      return config.onmouseout.call($$);\n    });\n\n    if ($$.config.svg_classname) {\n      $$.svg.attr('class', $$.config.svg_classname);\n    } // Define defs\n\n\n    defs = $$.svg.append(\"defs\");\n    $$.clipChart = $$.appendClip(defs, $$.clipId);\n    $$.clipXAxis = $$.appendClip(defs, $$.clipIdForXAxis);\n    $$.clipYAxis = $$.appendClip(defs, $$.clipIdForYAxis);\n    $$.clipGrid = $$.appendClip(defs, $$.clipIdForGrid);\n    $$.clipSubchart = $$.appendClip(defs, $$.clipIdForSubchart);\n    $$.updateSvgSize(); // Define regions\n\n    main = $$.main = $$.svg.append(\"g\").attr(\"transform\", $$.getTranslate('main'));\n\n    if ($$.initSubchart) {\n      $$.initSubchart();\n    }\n\n    if ($$.initTooltip) {\n      $$.initTooltip();\n    }\n\n    if ($$.initLegend) {\n      $$.initLegend();\n    }\n\n    if ($$.initTitle) {\n      $$.initTitle();\n    }\n    /*-- Main Region --*/\n    // text when empty\n\n\n    main.append(\"text\").attr(\"class\", CLASS.text + ' ' + CLASS.empty).attr(\"text-anchor\", \"middle\") // horizontal centering of text at x position in all browsers.\n    .attr(\"dominant-baseline\", \"middle\"); // vertical centering of text at y position in all browsers, except IE.\n    // Regions\n\n    $$.initRegion(); // Grids\n\n    $$.initGrid(); // Define g for chart area\n\n    main.append('g').attr(\"clip-path\", $$.clipPath).attr('class', CLASS.chart); // Grid lines\n\n    if (config.grid_lines_front) {\n      $$.initGridLines();\n    } // Cover whole with rects for events\n\n\n    $$.initEventRect(); // Define g for chart\n\n    $$.initChartElements(); // if zoom privileged, insert rect to forefront\n    // TODO: is this needed?\n\n    main.insert('rect', config.zoom_privileged ? null : 'g.' + CLASS.regions).attr('class', CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height).style('opacity', 0).on(\"dblclick.zoom\", null); // Set default extent if defined\n\n    if (config.axis_x_extent) {\n      $$.brush.extent($$.getDefaultExtent());\n    } // Add Axis\n\n\n    $$.axis.init(); // Set targets\n\n    $$.updateTargets($$.data.targets); // Draw with targets\n\n    if (binding) {\n      $$.updateDimension();\n      $$.config.oninit.call($$);\n      $$.redraw({\n        withTransition: false,\n        withTransform: true,\n        withUpdateXDomain: true,\n        withUpdateOrgXDomain: true,\n        withTransitionForAxis: false\n      });\n    } // Bind resize event\n\n\n    $$.bindResize(); // export element of the chart\n\n    $$.api.element = $$.selectChart.node();\n  };\n\n  c3_chart_internal_fn.smoothLines = function (el, type) {\n    var $$ = this;\n\n    if (type === 'grid') {\n      el.each(function () {\n        var g = $$.d3.select(this),\n            x1 = g.attr('x1'),\n            x2 = g.attr('x2'),\n            y1 = g.attr('y1'),\n            y2 = g.attr('y2');\n        g.attr({\n          'x1': Math.ceil(x1),\n          'x2': Math.ceil(x2),\n          'y1': Math.ceil(y1),\n          'y2': Math.ceil(y2)\n        });\n      });\n    }\n  };\n\n  c3_chart_internal_fn.updateSizes = function () {\n    var $$ = this,\n        config = $$.config;\n    var legendHeight = $$.legend ? $$.getLegendHeight() : 0,\n        legendWidth = $$.legend ? $$.getLegendWidth() : 0,\n        legendHeightForBottom = $$.isLegendRight || $$.isLegendInset ? 0 : legendHeight,\n        hasArc = $$.hasArcType(),\n        xAxisHeight = config.axis_rotated || hasArc ? 0 : $$.getHorizontalAxisHeight('x'),\n        subchartHeight = config.subchart_show && !hasArc ? config.subchart_size_height + xAxisHeight : 0;\n    $$.currentWidth = $$.getCurrentWidth();\n    $$.currentHeight = $$.getCurrentHeight(); // for main\n\n    $$.margin = config.axis_rotated ? {\n      top: $$.getHorizontalAxisHeight('y2') + $$.getCurrentPaddingTop(),\n      right: hasArc ? 0 : $$.getCurrentPaddingRight(),\n      bottom: $$.getHorizontalAxisHeight('y') + legendHeightForBottom + $$.getCurrentPaddingBottom(),\n      left: subchartHeight + (hasArc ? 0 : $$.getCurrentPaddingLeft())\n    } : {\n      top: 4 + $$.getCurrentPaddingTop(),\n      // for top tick text\n      right: hasArc ? 0 : $$.getCurrentPaddingRight(),\n      bottom: xAxisHeight + subchartHeight + legendHeightForBottom + $$.getCurrentPaddingBottom(),\n      left: hasArc ? 0 : $$.getCurrentPaddingLeft()\n    }; // for subchart\n\n    $$.margin2 = config.axis_rotated ? {\n      top: $$.margin.top,\n      right: NaN,\n      bottom: 20 + legendHeightForBottom,\n      left: $$.rotated_padding_left\n    } : {\n      top: $$.currentHeight - subchartHeight - legendHeightForBottom,\n      right: NaN,\n      bottom: xAxisHeight + legendHeightForBottom,\n      left: $$.margin.left\n    }; // for legend\n\n    $$.margin3 = {\n      top: 0,\n      right: NaN,\n      bottom: 0,\n      left: 0\n    };\n\n    if ($$.updateSizeForLegend) {\n      $$.updateSizeForLegend(legendHeight, legendWidth);\n    }\n\n    $$.width = $$.currentWidth - $$.margin.left - $$.margin.right;\n    $$.height = $$.currentHeight - $$.margin.top - $$.margin.bottom;\n\n    if ($$.width < 0) {\n      $$.width = 0;\n    }\n\n    if ($$.height < 0) {\n      $$.height = 0;\n    }\n\n    $$.width2 = config.axis_rotated ? $$.margin.left - $$.rotated_padding_left - $$.rotated_padding_right : $$.width;\n    $$.height2 = config.axis_rotated ? $$.height : $$.currentHeight - $$.margin2.top - $$.margin2.bottom;\n\n    if ($$.width2 < 0) {\n      $$.width2 = 0;\n    }\n\n    if ($$.height2 < 0) {\n      $$.height2 = 0;\n    } // for arc\n\n\n    $$.arcWidth = $$.width - ($$.isLegendRight ? legendWidth + 10 : 0);\n    $$.arcHeight = $$.height - ($$.isLegendRight ? 0 : 10);\n\n    if ($$.hasType('gauge') && !config.gauge_fullCircle) {\n      $$.arcHeight += $$.height - $$.getGaugeLabelHeight();\n    }\n\n    if ($$.updateRadius) {\n      $$.updateRadius();\n    }\n\n    if ($$.isLegendRight && hasArc) {\n      $$.margin3.left = $$.arcWidth / 2 + $$.radiusExpanded * 1.1;\n    }\n  };\n\n  c3_chart_internal_fn.updateTargets = function (targets) {\n    var $$ = this;\n    /*-- Main --*/\n    //-- Text --//\n\n    $$.updateTargetsForText(targets); //-- Bar --//\n\n    $$.updateTargetsForBar(targets); //-- Line --//\n\n    $$.updateTargetsForLine(targets); //-- Arc --//\n\n    if ($$.hasArcType() && $$.updateTargetsForArc) {\n      $$.updateTargetsForArc(targets);\n    }\n    /*-- Sub --*/\n\n\n    if ($$.updateTargetsForSubchart) {\n      $$.updateTargetsForSubchart(targets);\n    } // Fade-in each chart\n\n\n    $$.showTargets();\n  };\n\n  c3_chart_internal_fn.showTargets = function () {\n    var $$ = this;\n    $$.svg.selectAll('.' + CLASS.target).filter(function (d) {\n      return $$.isTargetToShow(d.id);\n    }).transition().duration($$.config.transition_duration).style(\"opacity\", 1);\n  };\n\n  c3_chart_internal_fn.redraw = function (options, transitions) {\n    var $$ = this,\n        main = $$.main,\n        d3 = $$.d3,\n        config = $$.config;\n    var areaIndices = $$.getShapeIndices($$.isAreaType),\n        barIndices = $$.getShapeIndices($$.isBarType),\n        lineIndices = $$.getShapeIndices($$.isLineType);\n    var withY, withSubchart, withTransition, withTransitionForExit, withTransitionForAxis, withTransform, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain, withLegend, withEventRect, withDimension, withUpdateXAxis;\n    var hideAxis = $$.hasArcType();\n    var drawArea, drawBar, drawLine, xForText, yForText;\n    var duration, durationForExit, durationForAxis;\n    var waitForDraw, flow;\n    var targetsToShow = $$.filterTargetsToShow($$.data.targets),\n        tickValues,\n        i,\n        intervalForCulling,\n        xDomainForZoom;\n    var xv = $$.xv.bind($$),\n        cx,\n        cy;\n    options = options || {};\n    withY = getOption(options, \"withY\", true);\n    withSubchart = getOption(options, \"withSubchart\", true);\n    withTransition = getOption(options, \"withTransition\", true);\n    withTransform = getOption(options, \"withTransform\", false);\n    withUpdateXDomain = getOption(options, \"withUpdateXDomain\", false);\n    withUpdateOrgXDomain = getOption(options, \"withUpdateOrgXDomain\", false);\n    withTrimXDomain = getOption(options, \"withTrimXDomain\", true);\n    withUpdateXAxis = getOption(options, \"withUpdateXAxis\", withUpdateXDomain);\n    withLegend = getOption(options, \"withLegend\", false);\n    withEventRect = getOption(options, \"withEventRect\", true);\n    withDimension = getOption(options, \"withDimension\", true);\n    withTransitionForExit = getOption(options, \"withTransitionForExit\", withTransition);\n    withTransitionForAxis = getOption(options, \"withTransitionForAxis\", withTransition);\n    duration = withTransition ? config.transition_duration : 0;\n    durationForExit = withTransitionForExit ? duration : 0;\n    durationForAxis = withTransitionForAxis ? duration : 0;\n    transitions = transitions || $$.axis.generateTransitions(durationForAxis); // update legend and transform each g\n\n    if (withLegend && config.legend_show) {\n      $$.updateLegend($$.mapToIds($$.data.targets), options, transitions);\n    } else if (withDimension) {\n      // need to update dimension (e.g. axis.y.tick.values) because y tick values should change\n      // no need to update axis in it because they will be updated in redraw()\n      $$.updateDimension(true);\n    } // MEMO: needed for grids calculation\n\n\n    if ($$.isCategorized() && targetsToShow.length === 0) {\n      $$.x.domain([0, $$.axes.x.selectAll('.tick').size()]);\n    }\n\n    if (targetsToShow.length) {\n      $$.updateXDomain(targetsToShow, withUpdateXDomain, withUpdateOrgXDomain, withTrimXDomain);\n\n      if (!config.axis_x_tick_values) {\n        tickValues = $$.axis.updateXAxisTickValues(targetsToShow);\n      }\n    } else {\n      $$.xAxis.tickValues([]);\n      $$.subXAxis.tickValues([]);\n    }\n\n    if (config.zoom_rescale && !options.flow) {\n      xDomainForZoom = $$.x.orgDomain();\n    }\n\n    $$.y.domain($$.getYDomain(targetsToShow, 'y', xDomainForZoom));\n    $$.y2.domain($$.getYDomain(targetsToShow, 'y2', xDomainForZoom));\n\n    if (!config.axis_y_tick_values && config.axis_y_tick_count) {\n      $$.yAxis.tickValues($$.axis.generateTickValues($$.y.domain(), config.axis_y_tick_count));\n    }\n\n    if (!config.axis_y2_tick_values && config.axis_y2_tick_count) {\n      $$.y2Axis.tickValues($$.axis.generateTickValues($$.y2.domain(), config.axis_y2_tick_count));\n    } // axes\n\n\n    $$.axis.redraw(transitions, hideAxis); // Update axis label\n\n    $$.axis.updateLabels(withTransition); // show/hide if manual culling needed\n\n    if ((withUpdateXDomain || withUpdateXAxis) && targetsToShow.length) {\n      if (config.axis_x_tick_culling && tickValues) {\n        for (i = 1; i < tickValues.length; i++) {\n          if (tickValues.length / i < config.axis_x_tick_culling_max) {\n            intervalForCulling = i;\n            break;\n          }\n        }\n\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').each(function (e) {\n          var index = tickValues.indexOf(e);\n\n          if (index >= 0) {\n            d3.select(this).style('display', index % intervalForCulling ? 'none' : 'block');\n          }\n        });\n      } else {\n        $$.svg.selectAll('.' + CLASS.axisX + ' .tick text').style('display', 'block');\n      }\n    } // setup drawer - MEMO: these must be called after axis updated\n\n\n    drawArea = $$.generateDrawArea ? $$.generateDrawArea(areaIndices, false) : undefined;\n    drawBar = $$.generateDrawBar ? $$.generateDrawBar(barIndices) : undefined;\n    drawLine = $$.generateDrawLine ? $$.generateDrawLine(lineIndices, false) : undefined;\n    xForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, true);\n    yForText = $$.generateXYForText(areaIndices, barIndices, lineIndices, false); // Update sub domain\n\n    if (withY) {\n      $$.subY.domain($$.getYDomain(targetsToShow, 'y'));\n      $$.subY2.domain($$.getYDomain(targetsToShow, 'y2'));\n    } // xgrid focus\n\n\n    $$.updateXgridFocus(); // Data empty label positioning and text.\n\n    main.select(\"text.\" + CLASS.text + '.' + CLASS.empty).attr(\"x\", $$.width / 2).attr(\"y\", $$.height / 2).text(config.data_empty_label_text).transition().style('opacity', targetsToShow.length ? 0 : 1); // grid\n\n    $$.updateGrid(duration); // rect for regions\n\n    $$.updateRegion(duration); // bars\n\n    $$.updateBar(durationForExit); // lines, areas and cricles\n\n    $$.updateLine(durationForExit);\n    $$.updateArea(durationForExit);\n    $$.updateCircle(); // text\n\n    if ($$.hasDataLabel()) {\n      $$.updateText(durationForExit);\n    } // title\n\n\n    if ($$.redrawTitle) {\n      $$.redrawTitle();\n    } // arc\n\n\n    if ($$.redrawArc) {\n      $$.redrawArc(duration, durationForExit, withTransform);\n    } // subchart\n\n\n    if ($$.redrawSubchart) {\n      $$.redrawSubchart(withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices);\n    } // circles for select\n\n\n    main.selectAll('.' + CLASS.selectedCircles).filter($$.isBarType.bind($$)).selectAll('circle').remove(); // event rects will redrawn when flow called\n\n    if (config.interaction_enabled && !options.flow && withEventRect) {\n      $$.redrawEventRect();\n\n      if ($$.updateZoom) {\n        $$.updateZoom();\n      }\n    } // update circleY based on updated parameters\n\n\n    $$.updateCircleY(); // generate circle x/y functions depending on updated params\n\n    cx = ($$.config.axis_rotated ? $$.circleY : $$.circleX).bind($$);\n    cy = ($$.config.axis_rotated ? $$.circleX : $$.circleY).bind($$);\n\n    if (options.flow) {\n      flow = $$.generateFlow({\n        targets: targetsToShow,\n        flow: options.flow,\n        duration: options.flow.duration,\n        drawBar: drawBar,\n        drawLine: drawLine,\n        drawArea: drawArea,\n        cx: cx,\n        cy: cy,\n        xv: xv,\n        xForText: xForText,\n        yForText: yForText\n      });\n    }\n\n    if ((duration || flow) && $$.isTabVisible()) {\n      // Only use transition if tab visible. See #938.\n      // transition should be derived from one transition\n      d3.transition().duration(duration).each(function () {\n        var transitionsToWait = []; // redraw and gather transitions\n\n        [$$.redrawBar(drawBar, true), $$.redrawLine(drawLine, true), $$.redrawArea(drawArea, true), $$.redrawCircle(cx, cy, true), $$.redrawText(xForText, yForText, options.flow, true), $$.redrawRegion(true), $$.redrawGrid(true)].forEach(function (transitions) {\n          transitions.forEach(function (transition) {\n            transitionsToWait.push(transition);\n          });\n        }); // Wait for end of transitions to call flow and onrendered callback\n\n        waitForDraw = $$.generateWait();\n        transitionsToWait.forEach(function (t) {\n          waitForDraw.add(t);\n        });\n      }).call(waitForDraw, function () {\n        if (flow) {\n          flow();\n        }\n\n        if (config.onrendered) {\n          config.onrendered.call($$);\n        }\n      });\n    } else {\n      $$.redrawBar(drawBar);\n      $$.redrawLine(drawLine);\n      $$.redrawArea(drawArea);\n      $$.redrawCircle(cx, cy);\n      $$.redrawText(xForText, yForText, options.flow);\n      $$.redrawRegion();\n      $$.redrawGrid();\n\n      if (config.onrendered) {\n        config.onrendered.call($$);\n      }\n    } // update fadein condition\n\n\n    $$.mapToIds($$.data.targets).forEach(function (id) {\n      $$.withoutFadeIn[id] = true;\n    });\n  };\n\n  c3_chart_internal_fn.updateAndRedraw = function (options) {\n    var $$ = this,\n        config = $$.config,\n        transitions;\n    options = options || {}; // same with redraw\n\n    options.withTransition = getOption(options, \"withTransition\", true);\n    options.withTransform = getOption(options, \"withTransform\", false);\n    options.withLegend = getOption(options, \"withLegend\", false); // NOT same with redraw\n\n    options.withUpdateXDomain = true;\n    options.withUpdateOrgXDomain = true;\n    options.withTransitionForExit = false;\n    options.withTransitionForTransform = getOption(options, \"withTransitionForTransform\", options.withTransition); // MEMO: this needs to be called before updateLegend and it means this ALWAYS needs to be called)\n\n    $$.updateSizes(); // MEMO: called in updateLegend in redraw if withLegend\n\n    if (!(options.withLegend && config.legend_show)) {\n      transitions = $$.axis.generateTransitions(options.withTransitionForAxis ? config.transition_duration : 0); // Update scales\n\n      $$.updateScales();\n      $$.updateSvgSize(); // Update g positions\n\n      $$.transformAll(options.withTransitionForTransform, transitions);\n    } // Draw with new sizes & scales\n\n\n    $$.redraw(options, transitions);\n  };\n\n  c3_chart_internal_fn.redrawWithoutRescale = function () {\n    this.redraw({\n      withY: false,\n      withSubchart: false,\n      withEventRect: false,\n      withTransitionForAxis: false\n    });\n  };\n\n  c3_chart_internal_fn.isTimeSeries = function () {\n    return this.config.axis_x_type === 'timeseries';\n  };\n\n  c3_chart_internal_fn.isCategorized = function () {\n    return this.config.axis_x_type.indexOf('categor') >= 0;\n  };\n\n  c3_chart_internal_fn.isCustomX = function () {\n    var $$ = this,\n        config = $$.config;\n    return !$$.isTimeSeries() && (config.data_x || notEmpty(config.data_xs));\n  };\n\n  c3_chart_internal_fn.isTimeSeriesY = function () {\n    return this.config.axis_y_type === 'timeseries';\n  };\n\n  c3_chart_internal_fn.getTranslate = function (target) {\n    var $$ = this,\n        config = $$.config,\n        x,\n        y;\n\n    if (target === 'main') {\n      x = asHalfPixel($$.margin.left);\n      y = asHalfPixel($$.margin.top);\n    } else if (target === 'context') {\n      x = asHalfPixel($$.margin2.left);\n      y = asHalfPixel($$.margin2.top);\n    } else if (target === 'legend') {\n      x = $$.margin3.left;\n      y = $$.margin3.top;\n    } else if (target === 'x') {\n      x = 0;\n      y = config.axis_rotated ? 0 : $$.height;\n    } else if (target === 'y') {\n      x = 0;\n      y = config.axis_rotated ? $$.height : 0;\n    } else if (target === 'y2') {\n      x = config.axis_rotated ? 0 : $$.width;\n      y = config.axis_rotated ? 1 : 0;\n    } else if (target === 'subx') {\n      x = 0;\n      y = config.axis_rotated ? 0 : $$.height2;\n    } else if (target === 'arc') {\n      x = $$.arcWidth / 2;\n      y = $$.arcHeight / 2 - ($$.hasType('gauge') ? 6 : 0); // to prevent wrong display of min and max label\n    }\n\n    return \"translate(\" + x + \",\" + y + \")\";\n  };\n\n  c3_chart_internal_fn.initialOpacity = function (d) {\n    return d.value !== null && this.withoutFadeIn[d.id] ? 1 : 0;\n  };\n\n  c3_chart_internal_fn.initialOpacityForCircle = function (d) {\n    return d.value !== null && this.withoutFadeIn[d.id] ? this.opacityForCircle(d) : 0;\n  };\n\n  c3_chart_internal_fn.opacityForCircle = function (d) {\n    var isPointShouldBeShown = isFunction(this.config.point_show) ? this.config.point_show(d) : this.config.point_show;\n    var opacity = isPointShouldBeShown ? 1 : 0;\n    return isValue(d.value) ? this.isScatterType(d) ? 0.5 : opacity : 0;\n  };\n\n  c3_chart_internal_fn.opacityForText = function () {\n    return this.hasDataLabel() ? 1 : 0;\n  };\n\n  c3_chart_internal_fn.xx = function (d) {\n    return d ? this.x(d.x) : null;\n  };\n\n  c3_chart_internal_fn.xv = function (d) {\n    var $$ = this,\n        value = d.value;\n\n    if ($$.isTimeSeries()) {\n      value = $$.parseDate(d.value);\n    } else if ($$.isCategorized() && typeof d.value === 'string') {\n      value = $$.config.axis_x_categories.indexOf(d.value);\n    }\n\n    return Math.ceil($$.x(value));\n  };\n\n  c3_chart_internal_fn.yv = function (d) {\n    var $$ = this,\n        yScale = d.axis && d.axis === 'y2' ? $$.y2 : $$.y;\n    return Math.ceil(yScale(d.value));\n  };\n\n  c3_chart_internal_fn.subxx = function (d) {\n    return d ? this.subX(d.x) : null;\n  };\n\n  c3_chart_internal_fn.transformMain = function (withTransition, transitions) {\n    var $$ = this,\n        xAxis,\n        yAxis,\n        y2Axis;\n\n    if (transitions && transitions.axisX) {\n      xAxis = transitions.axisX;\n    } else {\n      xAxis = $$.main.select('.' + CLASS.axisX);\n\n      if (withTransition) {\n        xAxis = xAxis.transition();\n      }\n    }\n\n    if (transitions && transitions.axisY) {\n      yAxis = transitions.axisY;\n    } else {\n      yAxis = $$.main.select('.' + CLASS.axisY);\n\n      if (withTransition) {\n        yAxis = yAxis.transition();\n      }\n    }\n\n    if (transitions && transitions.axisY2) {\n      y2Axis = transitions.axisY2;\n    } else {\n      y2Axis = $$.main.select('.' + CLASS.axisY2);\n\n      if (withTransition) {\n        y2Axis = y2Axis.transition();\n      }\n    }\n\n    (withTransition ? $$.main.transition() : $$.main).attr(\"transform\", $$.getTranslate('main'));\n    xAxis.attr(\"transform\", $$.getTranslate('x'));\n    yAxis.attr(\"transform\", $$.getTranslate('y'));\n    y2Axis.attr(\"transform\", $$.getTranslate('y2'));\n    $$.main.select('.' + CLASS.chartArcs).attr(\"transform\", $$.getTranslate('arc'));\n  };\n\n  c3_chart_internal_fn.transformAll = function (withTransition, transitions) {\n    var $$ = this;\n    $$.transformMain(withTransition, transitions);\n\n    if ($$.config.subchart_show) {\n      $$.transformContext(withTransition, transitions);\n    }\n\n    if ($$.legend) {\n      $$.transformLegend(withTransition);\n    }\n  };\n\n  c3_chart_internal_fn.updateSvgSize = function () {\n    var $$ = this,\n        brush = $$.svg.select(\".c3-brush .background\");\n    $$.svg.attr('width', $$.currentWidth).attr('height', $$.currentHeight);\n    $$.svg.selectAll(['#' + $$.clipId, '#' + $$.clipIdForGrid]).select('rect').attr('width', $$.width).attr('height', $$.height);\n    $$.svg.select('#' + $$.clipIdForXAxis).select('rect').attr('x', $$.getXAxisClipX.bind($$)).attr('y', $$.getXAxisClipY.bind($$)).attr('width', $$.getXAxisClipWidth.bind($$)).attr('height', $$.getXAxisClipHeight.bind($$));\n    $$.svg.select('#' + $$.clipIdForYAxis).select('rect').attr('x', $$.getYAxisClipX.bind($$)).attr('y', $$.getYAxisClipY.bind($$)).attr('width', $$.getYAxisClipWidth.bind($$)).attr('height', $$.getYAxisClipHeight.bind($$));\n    $$.svg.select('#' + $$.clipIdForSubchart).select('rect').attr('width', $$.width).attr('height', brush.size() ? brush.attr('height') : 0);\n    $$.svg.select('.' + CLASS.zoomRect).attr('width', $$.width).attr('height', $$.height); // MEMO: parent div's height will be bigger than svg when <!DOCTYPE html>\n\n    $$.selectChart.style('max-height', $$.currentHeight + \"px\");\n  };\n\n  c3_chart_internal_fn.updateDimension = function (withoutAxis) {\n    var $$ = this;\n\n    if (!withoutAxis) {\n      if ($$.config.axis_rotated) {\n        $$.axes.x.call($$.xAxis);\n        $$.axes.subx.call($$.subXAxis);\n      } else {\n        $$.axes.y.call($$.yAxis);\n        $$.axes.y2.call($$.y2Axis);\n      }\n    }\n\n    $$.updateSizes();\n    $$.updateScales();\n    $$.updateSvgSize();\n    $$.transformAll(false);\n  };\n\n  c3_chart_internal_fn.observeInserted = function (selection) {\n    var $$ = this,\n        observer;\n\n    if (typeof MutationObserver === 'undefined') {\n      window.console.error(\"MutationObserver not defined.\");\n      return;\n    }\n\n    observer = new MutationObserver(function (mutations) {\n      mutations.forEach(function (mutation) {\n        if (mutation.type === 'childList' && mutation.previousSibling) {\n          observer.disconnect(); // need to wait for completion of load because size calculation requires the actual sizes determined after that completion\n\n          $$.intervalForObserveInserted = window.setInterval(function () {\n            // parentNode will NOT be null when completed\n            if (selection.node().parentNode) {\n              window.clearInterval($$.intervalForObserveInserted);\n              $$.updateDimension();\n\n              if ($$.brush) {\n                $$.brush.update();\n              }\n\n              $$.config.oninit.call($$);\n              $$.redraw({\n                withTransform: true,\n                withUpdateXDomain: true,\n                withUpdateOrgXDomain: true,\n                withTransition: false,\n                withTransitionForTransform: false,\n                withLegend: true\n              });\n              selection.transition().style('opacity', 1);\n            }\n          }, 10);\n        }\n      });\n    });\n    observer.observe(selection.node(), {\n      attributes: true,\n      childList: true,\n      characterData: true\n    });\n  };\n\n  c3_chart_internal_fn.bindResize = function () {\n    var $$ = this,\n        config = $$.config;\n    $$.resizeFunction = $$.generateResize(); // need to call .remove\n\n    $$.resizeFunction.add(function () {\n      config.onresize.call($$);\n    });\n\n    if (config.resize_auto) {\n      $$.resizeFunction.add(function () {\n        if ($$.resizeTimeout !== undefined) {\n          window.clearTimeout($$.resizeTimeout);\n        }\n\n        $$.resizeTimeout = window.setTimeout(function () {\n          delete $$.resizeTimeout;\n          $$.api.flush();\n        }, 100);\n      });\n    }\n\n    $$.resizeFunction.add(function () {\n      config.onresized.call($$);\n    });\n\n    $$.resizeIfElementDisplayed = function () {\n      // if element not displayed skip it\n      if ($$.api == null || !$$.api.element.offsetParent) {\n        return;\n      }\n\n      $$.resizeFunction();\n    };\n\n    if (window.attachEvent) {\n      window.attachEvent('onresize', $$.resizeIfElementDisplayed);\n    } else if (window.addEventListener) {\n      window.addEventListener('resize', $$.resizeIfElementDisplayed, false);\n    } else {\n      // fallback to this, if this is a very old browser\n      var wrapper = window.onresize;\n\n      if (!wrapper) {\n        // create a wrapper that will call all charts\n        wrapper = $$.generateResize();\n      } else if (!wrapper.add || !wrapper.remove) {\n        // there is already a handler registered, make sure we call it too\n        wrapper = $$.generateResize();\n        wrapper.add(window.onresize);\n      } // add this graph to the wrapper, we will be removed if the user calls destroy\n\n\n      wrapper.add($$.resizeFunction);\n\n      window.onresize = function () {\n        // if element not displayed skip it\n        if (!$$.api.element.offsetParent) {\n          return;\n        }\n\n        wrapper();\n      };\n    }\n  };\n\n  c3_chart_internal_fn.generateResize = function () {\n    var resizeFunctions = [];\n\n    function callResizeFunctions() {\n      resizeFunctions.forEach(function (f) {\n        f();\n      });\n    }\n\n    callResizeFunctions.add = function (f) {\n      resizeFunctions.push(f);\n    };\n\n    callResizeFunctions.remove = function (f) {\n      for (var i = 0; i < resizeFunctions.length; i++) {\n        if (resizeFunctions[i] === f) {\n          resizeFunctions.splice(i, 1);\n          break;\n        }\n      }\n    };\n\n    return callResizeFunctions;\n  };\n\n  c3_chart_internal_fn.endall = function (transition, callback) {\n    var n = 0;\n    transition.each(function () {\n      ++n;\n    }).each(\"end\", function () {\n      if (! --n) {\n        callback.apply(this, arguments);\n      }\n    });\n  };\n\n  c3_chart_internal_fn.generateWait = function () {\n    var transitionsToWait = [],\n        f = function f(transition, callback) {\n      var timer = setInterval(function () {\n        var done = 0;\n        transitionsToWait.forEach(function (t) {\n          if (t.empty()) {\n            done += 1;\n            return;\n          }\n\n          try {\n            t.transition();\n          } catch (e) {\n            done += 1;\n          }\n        });\n\n        if (done === transitionsToWait.length) {\n          clearInterval(timer);\n\n          if (callback) {\n            callback();\n          }\n        }\n      }, 10);\n    };\n\n    f.add = function (transition) {\n      transitionsToWait.push(transition);\n    };\n\n    return f;\n  };\n\n  c3_chart_internal_fn.parseDate = function (date) {\n    var $$ = this,\n        parsedDate;\n\n    if (date instanceof Date) {\n      parsedDate = date;\n    } else if (typeof date === 'string') {\n      parsedDate = $$.dataTimeFormat($$.config.data_xFormat).parse(date);\n    } else if ((typeof date === 'undefined' ? 'undefined' : _typeof(date)) === 'object') {\n      parsedDate = new Date(+date);\n    } else if (typeof date === 'number' && !isNaN(date)) {\n      parsedDate = new Date(+date);\n    }\n\n    if (!parsedDate || isNaN(+parsedDate)) {\n      window.console.error(\"Failed to parse x '\" + date + \"' to Date object\");\n    }\n\n    return parsedDate;\n  };\n\n  c3_chart_internal_fn.isTabVisible = function () {\n    var hidden;\n\n    if (typeof document.hidden !== \"undefined\") {\n      // Opera 12.10 and Firefox 18 and later support\n      hidden = \"hidden\";\n    } else if (typeof document.mozHidden !== \"undefined\") {\n      hidden = \"mozHidden\";\n    } else if (typeof document.msHidden !== \"undefined\") {\n      hidden = \"msHidden\";\n    } else if (typeof document.webkitHidden !== \"undefined\") {\n      hidden = \"webkitHidden\";\n    }\n\n    return document[hidden] ? false : true;\n  };\n\n  c3_chart_internal_fn.isValue = isValue;\n  c3_chart_internal_fn.isFunction = isFunction;\n  c3_chart_internal_fn.isString = isString;\n  c3_chart_internal_fn.isUndefined = isUndefined;\n  c3_chart_internal_fn.isDefined = isDefined;\n  c3_chart_internal_fn.ceil10 = ceil10;\n  c3_chart_internal_fn.asHalfPixel = asHalfPixel;\n  c3_chart_internal_fn.diffDomain = diffDomain;\n  c3_chart_internal_fn.isEmpty = isEmpty;\n  c3_chart_internal_fn.notEmpty = notEmpty;\n  c3_chart_internal_fn.notEmpty = notEmpty;\n  c3_chart_internal_fn.getOption = getOption;\n  c3_chart_internal_fn.hasValue = hasValue;\n  c3_chart_internal_fn.sanitise = sanitise;\n  c3_chart_internal_fn.getPathBox = getPathBox;\n  c3_chart_internal_fn.CLASS = CLASS;\n  /* jshint ignore:start */\n  // PhantomJS doesn't have support for Function.prototype.bind, which has caused confusion. Use\n  // this polyfill to avoid the confusion.\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind#Polyfill\n\n  if (!Function.prototype.bind) {\n    Function.prototype.bind = function (oThis) {\n      if (typeof this !== 'function') {\n        // closest thing possible to the ECMAScript 5\n        // internal IsCallable function\n        throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');\n      }\n\n      var aArgs = Array.prototype.slice.call(arguments, 1),\n          fToBind = this,\n          fNOP = function fNOP() {},\n          fBound = function fBound() {\n        return fToBind.apply(this instanceof fNOP ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));\n      };\n\n      fNOP.prototype = this.prototype;\n      fBound.prototype = new fNOP();\n      return fBound;\n    };\n  } // SVGPathSeg API polyfill\n  // https://github.com/progers/pathseg\n  //\n  // This is a drop-in replacement for the SVGPathSeg and SVGPathSegList APIs that were removed from\n  // SVG2 (https://lists.w3.org/Archives/Public/www-svg/2015Jun/0044.html), including the latest spec\n  // changes which were implemented in Firefox 43 and Chrome 46.\n\n\n  (function () {\n    if (!(\"SVGPathSeg\" in window)) {\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSeg\n      window.SVGPathSeg = function (type, typeAsLetter, owningPathSegList) {\n        this.pathSegType = type;\n        this.pathSegTypeAsLetter = typeAsLetter;\n        this._owningPathSegList = owningPathSegList;\n      };\n\n      window.SVGPathSeg.prototype.classname = \"SVGPathSeg\";\n      window.SVGPathSeg.PATHSEG_UNKNOWN = 0;\n      window.SVGPathSeg.PATHSEG_CLOSEPATH = 1;\n      window.SVGPathSeg.PATHSEG_MOVETO_ABS = 2;\n      window.SVGPathSeg.PATHSEG_MOVETO_REL = 3;\n      window.SVGPathSeg.PATHSEG_LINETO_ABS = 4;\n      window.SVGPathSeg.PATHSEG_LINETO_REL = 5;\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS = 6;\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL = 7;\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS = 8;\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL = 9;\n      window.SVGPathSeg.PATHSEG_ARC_ABS = 10;\n      window.SVGPathSeg.PATHSEG_ARC_REL = 11;\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS = 12;\n      window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL = 13;\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS = 14;\n      window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL = 15;\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS = 16;\n      window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL = 17;\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS = 18;\n      window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL = 19; // Notify owning PathSegList on any changes so they can be synchronized back to the path element.\n\n      window.SVGPathSeg.prototype._segmentChanged = function () {\n        if (this._owningPathSegList) this._owningPathSegList.segmentChanged(this);\n      };\n\n      window.SVGPathSegClosePath = function (owningPathSegList) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CLOSEPATH, \"z\", owningPathSegList);\n      };\n\n      window.SVGPathSegClosePath.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegClosePath.prototype.toString = function () {\n        return \"[object SVGPathSegClosePath]\";\n      };\n\n      window.SVGPathSegClosePath.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter;\n      };\n\n      window.SVGPathSegClosePath.prototype.clone = function () {\n        return new window.SVGPathSegClosePath(undefined);\n      };\n\n      window.SVGPathSegMovetoAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_ABS, \"M\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegMovetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegMovetoAbs.prototype.toString = function () {\n        return \"[object SVGPathSegMovetoAbs]\";\n      };\n\n      window.SVGPathSegMovetoAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegMovetoAbs.prototype.clone = function () {\n        return new window.SVGPathSegMovetoAbs(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegMovetoAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegMovetoRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_MOVETO_REL, \"m\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegMovetoRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegMovetoRel.prototype.toString = function () {\n        return \"[object SVGPathSegMovetoRel]\";\n      };\n\n      window.SVGPathSegMovetoRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegMovetoRel.prototype.clone = function () {\n        return new window.SVGPathSegMovetoRel(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegMovetoRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_ABS, \"L\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegLinetoAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoAbs.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoAbs]\";\n      };\n\n      window.SVGPathSegLinetoAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegLinetoAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoAbs(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegLinetoAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_REL, \"l\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegLinetoRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoRel.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoRel]\";\n      };\n\n      window.SVGPathSegLinetoRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegLinetoRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoRel(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegLinetoRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoCubicAbs = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS, \"C\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x1 = x1;\n        this._y1 = y1;\n        this._x2 = x2;\n        this._y2 = y2;\n      };\n\n      window.SVGPathSegCurvetoCubicAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoCubicAbs.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoCubicAbs]\";\n      };\n\n      window.SVGPathSegCurvetoCubicAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x1 + \" \" + this._y1 + \" \" + this._x2 + \" \" + this._y2 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoCubicAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"x1\", {\n        get: function get() {\n          return this._x1;\n        },\n        set: function set(x1) {\n          this._x1 = x1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"y1\", {\n        get: function get() {\n          return this._y1;\n        },\n        set: function set(y1) {\n          this._y1 = y1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"x2\", {\n        get: function get() {\n          return this._x2;\n        },\n        set: function set(x2) {\n          this._x2 = x2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicAbs.prototype, \"y2\", {\n        get: function get() {\n          return this._y2;\n        },\n        set: function set(y2) {\n          this._y2 = y2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoCubicRel = function (owningPathSegList, x, y, x1, y1, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL, \"c\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x1 = x1;\n        this._y1 = y1;\n        this._x2 = x2;\n        this._y2 = y2;\n      };\n\n      window.SVGPathSegCurvetoCubicRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoCubicRel.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoCubicRel]\";\n      };\n\n      window.SVGPathSegCurvetoCubicRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x1 + \" \" + this._y1 + \" \" + this._x2 + \" \" + this._y2 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoCubicRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicRel(undefined, this._x, this._y, this._x1, this._y1, this._x2, this._y2);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"x1\", {\n        get: function get() {\n          return this._x1;\n        },\n        set: function set(x1) {\n          this._x1 = x1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"y1\", {\n        get: function get() {\n          return this._y1;\n        },\n        set: function set(y1) {\n          this._y1 = y1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"x2\", {\n        get: function get() {\n          return this._x2;\n        },\n        set: function set(x2) {\n          this._x2 = x2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicRel.prototype, \"y2\", {\n        get: function get() {\n          return this._y2;\n        },\n        set: function set(y2) {\n          this._y2 = y2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoQuadraticAbs = function (owningPathSegList, x, y, x1, y1) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS, \"Q\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x1 = x1;\n        this._y1 = y1;\n      };\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoQuadraticAbs]\";\n      };\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x1 + \" \" + this._y1 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, this._x, this._y, this._x1, this._y1);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, \"x1\", {\n        get: function get() {\n          return this._x1;\n        },\n        set: function set(x1) {\n          this._x1 = x1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticAbs.prototype, \"y1\", {\n        get: function get() {\n          return this._y1;\n        },\n        set: function set(y1) {\n          this._y1 = y1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoQuadraticRel = function (owningPathSegList, x, y, x1, y1) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL, \"q\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x1 = x1;\n        this._y1 = y1;\n      };\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoQuadraticRel]\";\n      };\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x1 + \" \" + this._y1 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, this._x, this._y, this._x1, this._y1);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, \"x1\", {\n        get: function get() {\n          return this._x1;\n        },\n        set: function set(x1) {\n          this._x1 = x1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticRel.prototype, \"y1\", {\n        get: function get() {\n          return this._y1;\n        },\n        set: function set(y1) {\n          this._y1 = y1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegArcAbs = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_ABS, \"A\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._r1 = r1;\n        this._r2 = r2;\n        this._angle = angle;\n        this._largeArcFlag = largeArcFlag;\n        this._sweepFlag = sweepFlag;\n      };\n\n      window.SVGPathSegArcAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegArcAbs.prototype.toString = function () {\n        return \"[object SVGPathSegArcAbs]\";\n      };\n\n      window.SVGPathSegArcAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._r1 + \" \" + this._r2 + \" \" + this._angle + \" \" + (this._largeArcFlag ? \"1\" : \"0\") + \" \" + (this._sweepFlag ? \"1\" : \"0\") + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegArcAbs.prototype.clone = function () {\n        return new window.SVGPathSegArcAbs(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);\n      };\n\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"r1\", {\n        get: function get() {\n          return this._r1;\n        },\n        set: function set(r1) {\n          this._r1 = r1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"r2\", {\n        get: function get() {\n          return this._r2;\n        },\n        set: function set(r2) {\n          this._r2 = r2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"angle\", {\n        get: function get() {\n          return this._angle;\n        },\n        set: function set(angle) {\n          this._angle = angle;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"largeArcFlag\", {\n        get: function get() {\n          return this._largeArcFlag;\n        },\n        set: function set(largeArcFlag) {\n          this._largeArcFlag = largeArcFlag;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcAbs.prototype, \"sweepFlag\", {\n        get: function get() {\n          return this._sweepFlag;\n        },\n        set: function set(sweepFlag) {\n          this._sweepFlag = sweepFlag;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegArcRel = function (owningPathSegList, x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_ARC_REL, \"a\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._r1 = r1;\n        this._r2 = r2;\n        this._angle = angle;\n        this._largeArcFlag = largeArcFlag;\n        this._sweepFlag = sweepFlag;\n      };\n\n      window.SVGPathSegArcRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegArcRel.prototype.toString = function () {\n        return \"[object SVGPathSegArcRel]\";\n      };\n\n      window.SVGPathSegArcRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._r1 + \" \" + this._r2 + \" \" + this._angle + \" \" + (this._largeArcFlag ? \"1\" : \"0\") + \" \" + (this._sweepFlag ? \"1\" : \"0\") + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegArcRel.prototype.clone = function () {\n        return new window.SVGPathSegArcRel(undefined, this._x, this._y, this._r1, this._r2, this._angle, this._largeArcFlag, this._sweepFlag);\n      };\n\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"r1\", {\n        get: function get() {\n          return this._r1;\n        },\n        set: function set(r1) {\n          this._r1 = r1;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"r2\", {\n        get: function get() {\n          return this._r2;\n        },\n        set: function set(r2) {\n          this._r2 = r2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"angle\", {\n        get: function get() {\n          return this._angle;\n        },\n        set: function set(angle) {\n          this._angle = angle;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"largeArcFlag\", {\n        get: function get() {\n          return this._largeArcFlag;\n        },\n        set: function set(largeArcFlag) {\n          this._largeArcFlag = largeArcFlag;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegArcRel.prototype, \"sweepFlag\", {\n        get: function get() {\n          return this._sweepFlag;\n        },\n        set: function set(sweepFlag) {\n          this._sweepFlag = sweepFlag;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoHorizontalAbs = function (owningPathSegList, x) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS, \"H\", owningPathSegList);\n        this._x = x;\n      };\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoHorizontalAbs]\";\n      };\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x;\n      };\n\n      window.SVGPathSegLinetoHorizontalAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, this._x);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoHorizontalRel = function (owningPathSegList, x) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL, \"h\", owningPathSegList);\n        this._x = x;\n      };\n\n      window.SVGPathSegLinetoHorizontalRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoHorizontalRel.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoHorizontalRel]\";\n      };\n\n      window.SVGPathSegLinetoHorizontalRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x;\n      };\n\n      window.SVGPathSegLinetoHorizontalRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, this._x);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoHorizontalRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoVerticalAbs = function (owningPathSegList, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS, \"V\", owningPathSegList);\n        this._y = y;\n      };\n\n      window.SVGPathSegLinetoVerticalAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoVerticalAbs.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoVerticalAbs]\";\n      };\n\n      window.SVGPathSegLinetoVerticalAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._y;\n      };\n\n      window.SVGPathSegLinetoVerticalAbs.prototype.clone = function () {\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoVerticalAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegLinetoVerticalRel = function (owningPathSegList, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL, \"v\", owningPathSegList);\n        this._y = y;\n      };\n\n      window.SVGPathSegLinetoVerticalRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegLinetoVerticalRel.prototype.toString = function () {\n        return \"[object SVGPathSegLinetoVerticalRel]\";\n      };\n\n      window.SVGPathSegLinetoVerticalRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._y;\n      };\n\n      window.SVGPathSegLinetoVerticalRel.prototype.clone = function () {\n        return new window.SVGPathSegLinetoVerticalRel(undefined, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegLinetoVerticalRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoCubicSmoothAbs = function (owningPathSegList, x, y, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS, \"S\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x2 = x2;\n        this._y2 = y2;\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoCubicSmoothAbs]\";\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x2 + \" \" + this._y2 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, this._x, this._y, this._x2, this._y2);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, \"x2\", {\n        get: function get() {\n          return this._x2;\n        },\n        set: function set(x2) {\n          this._x2 = x2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothAbs.prototype, \"y2\", {\n        get: function get() {\n          return this._y2;\n        },\n        set: function set(y2) {\n          this._y2 = y2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoCubicSmoothRel = function (owningPathSegList, x, y, x2, y2) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL, \"s\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n        this._x2 = x2;\n        this._y2 = y2;\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoCubicSmoothRel]\";\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x2 + \" \" + this._y2 + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoCubicSmoothRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, this._x, this._y, this._x2, this._y2);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, \"x2\", {\n        get: function get() {\n          return this._x2;\n        },\n        set: function set(x2) {\n          this._x2 = x2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoCubicSmoothRel.prototype, \"y2\", {\n        get: function get() {\n          return this._y2;\n        },\n        set: function set(y2) {\n          this._y2 = y2;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS, \"T\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoQuadraticSmoothAbs]\";\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothAbs.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel = function (owningPathSegList, x, y) {\n        window.SVGPathSeg.call(this, window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL, \"t\", owningPathSegList);\n        this._x = x;\n        this._y = y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype = Object.create(window.SVGPathSeg.prototype);\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.toString = function () {\n        return \"[object SVGPathSegCurvetoQuadraticSmoothRel]\";\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype._asPathString = function () {\n        return this.pathSegTypeAsLetter + \" \" + this._x + \" \" + this._y;\n      };\n\n      window.SVGPathSegCurvetoQuadraticSmoothRel.prototype.clone = function () {\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, this._x, this._y);\n      };\n\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, \"x\", {\n        get: function get() {\n          return this._x;\n        },\n        set: function set(x) {\n          this._x = x;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathSegCurvetoQuadraticSmoothRel.prototype, \"y\", {\n        get: function get() {\n          return this._y;\n        },\n        set: function set(y) {\n          this._y = y;\n\n          this._segmentChanged();\n        },\n        enumerable: true\n      }); // Add createSVGPathSeg* functions to window.SVGPathElement.\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-Interfacewindow.SVGPathElement.\n\n      window.SVGPathElement.prototype.createSVGPathSegClosePath = function () {\n        return new window.SVGPathSegClosePath(undefined);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegMovetoAbs = function (x, y) {\n        return new window.SVGPathSegMovetoAbs(undefined, x, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegMovetoRel = function (x, y) {\n        return new window.SVGPathSegMovetoRel(undefined, x, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoAbs = function (x, y) {\n        return new window.SVGPathSegLinetoAbs(undefined, x, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoRel = function (x, y) {\n        return new window.SVGPathSegLinetoRel(undefined, x, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicAbs = function (x, y, x1, y1, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicAbs(undefined, x, y, x1, y1, x2, y2);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicRel = function (x, y, x1, y1, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicRel(undefined, x, y, x1, y1, x2, y2);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticAbs = function (x, y, x1, y1) {\n        return new window.SVGPathSegCurvetoQuadraticAbs(undefined, x, y, x1, y1);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticRel = function (x, y, x1, y1) {\n        return new window.SVGPathSegCurvetoQuadraticRel(undefined, x, y, x1, y1);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegArcAbs = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        return new window.SVGPathSegArcAbs(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegArcRel = function (x, y, r1, r2, angle, largeArcFlag, sweepFlag) {\n        return new window.SVGPathSegArcRel(undefined, x, y, r1, r2, angle, largeArcFlag, sweepFlag);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalAbs = function (x) {\n        return new window.SVGPathSegLinetoHorizontalAbs(undefined, x);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoHorizontalRel = function (x) {\n        return new window.SVGPathSegLinetoHorizontalRel(undefined, x);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalAbs = function (y) {\n        return new window.SVGPathSegLinetoVerticalAbs(undefined, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegLinetoVerticalRel = function (y) {\n        return new window.SVGPathSegLinetoVerticalRel(undefined, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothAbs = function (x, y, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicSmoothAbs(undefined, x, y, x2, y2);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoCubicSmoothRel = function (x, y, x2, y2) {\n        return new window.SVGPathSegCurvetoCubicSmoothRel(undefined, x, y, x2, y2);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothAbs = function (x, y) {\n        return new window.SVGPathSegCurvetoQuadraticSmoothAbs(undefined, x, y);\n      };\n\n      window.SVGPathElement.prototype.createSVGPathSegCurvetoQuadraticSmoothRel = function (x, y) {\n        return new window.SVGPathSegCurvetoQuadraticSmoothRel(undefined, x, y);\n      };\n\n      if (!(\"getPathSegAtLength\" in window.SVGPathElement.prototype)) {\n        // Add getPathSegAtLength to SVGPathElement.\n        // Spec: https://www.w3.org/TR/SVG11/single-page.html#paths-__svg__SVGPathElement__getPathSegAtLength\n        // This polyfill requires SVGPathElement.getTotalLength to implement the distance-along-a-path algorithm.\n        window.SVGPathElement.prototype.getPathSegAtLength = function (distance) {\n          if (distance === undefined || !isFinite(distance)) throw \"Invalid arguments.\";\n          var measurementElement = document.createElementNS(\"http://www.w3.org/2000/svg\", \"path\");\n          measurementElement.setAttribute(\"d\", this.getAttribute(\"d\"));\n          var lastPathSegment = measurementElement.pathSegList.numberOfItems - 1; // If the path is empty, return 0.\n\n          if (lastPathSegment <= 0) return 0;\n\n          do {\n            measurementElement.pathSegList.removeItem(lastPathSegment);\n            if (distance > measurementElement.getTotalLength()) break;\n            lastPathSegment--;\n          } while (lastPathSegment > 0);\n\n          return lastPathSegment;\n        };\n      }\n    }\n\n    if (!(\"SVGPathSegList\" in window)) {\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGPathSegList\n      window.SVGPathSegList = function (pathElement) {\n        this._pathElement = pathElement;\n        this._list = this._parsePath(this._pathElement.getAttribute(\"d\")); // Use a MutationObserver to catch changes to the path's \"d\" attribute.\n\n        this._mutationObserverConfig = {\n          \"attributes\": true,\n          \"attributeFilter\": [\"d\"]\n        };\n        this._pathElementMutationObserver = new MutationObserver(this._updateListFromPathMutations.bind(this));\n\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);\n      };\n\n      window.SVGPathSegList.prototype.classname = \"SVGPathSegList\";\n      Object.defineProperty(window.SVGPathSegList.prototype, \"numberOfItems\", {\n        get: function get() {\n          this._checkPathSynchronizedToList();\n\n          return this._list.length;\n        },\n        enumerable: true\n      }); // Add the pathSegList accessors to window.SVGPathElement.\n      // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-InterfaceSVGAnimatedPathData\n\n      Object.defineProperty(window.SVGPathElement.prototype, \"pathSegList\", {\n        get: function get() {\n          if (!this._pathSegList) this._pathSegList = new window.SVGPathSegList(this);\n          return this._pathSegList;\n        },\n        enumerable: true\n      }); // FIXME: The following are not implemented and simply return window.SVGPathElement.pathSegList.\n\n      Object.defineProperty(window.SVGPathElement.prototype, \"normalizedPathSegList\", {\n        get: function get() {\n          return this.pathSegList;\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathElement.prototype, \"animatedPathSegList\", {\n        get: function get() {\n          return this.pathSegList;\n        },\n        enumerable: true\n      });\n      Object.defineProperty(window.SVGPathElement.prototype, \"animatedNormalizedPathSegList\", {\n        get: function get() {\n          return this.pathSegList;\n        },\n        enumerable: true\n      }); // Process any pending mutations to the path element and update the list as needed.\n      // This should be the first call of all public functions and is needed because\n      // MutationObservers are not synchronous so we can have pending asynchronous mutations.\n\n      window.SVGPathSegList.prototype._checkPathSynchronizedToList = function () {\n        this._updateListFromPathMutations(this._pathElementMutationObserver.takeRecords());\n      };\n\n      window.SVGPathSegList.prototype._updateListFromPathMutations = function (mutationRecords) {\n        if (!this._pathElement) return;\n        var hasPathMutations = false;\n        mutationRecords.forEach(function (record) {\n          if (record.attributeName == \"d\") hasPathMutations = true;\n        });\n        if (hasPathMutations) this._list = this._parsePath(this._pathElement.getAttribute(\"d\"));\n      }; // Serialize the list and update the path's 'd' attribute.\n\n\n      window.SVGPathSegList.prototype._writeListToPath = function () {\n        this._pathElementMutationObserver.disconnect();\n\n        this._pathElement.setAttribute(\"d\", window.SVGPathSegList._pathSegArrayAsString(this._list));\n\n        this._pathElementMutationObserver.observe(this._pathElement, this._mutationObserverConfig);\n      }; // When a path segment changes the list needs to be synchronized back to the path element.\n\n\n      window.SVGPathSegList.prototype.segmentChanged = function (pathSeg) {\n        this._writeListToPath();\n      };\n\n      window.SVGPathSegList.prototype.clear = function () {\n        this._checkPathSynchronizedToList();\n\n        this._list.forEach(function (pathSeg) {\n          pathSeg._owningPathSegList = null;\n        });\n\n        this._list = [];\n\n        this._writeListToPath();\n      };\n\n      window.SVGPathSegList.prototype.initialize = function (newItem) {\n        this._checkPathSynchronizedToList();\n\n        this._list = [newItem];\n        newItem._owningPathSegList = this;\n\n        this._writeListToPath();\n\n        return newItem;\n      };\n\n      window.SVGPathSegList.prototype._checkValidIndex = function (index) {\n        if (isNaN(index) || index < 0 || index >= this.numberOfItems) throw \"INDEX_SIZE_ERR\";\n      };\n\n      window.SVGPathSegList.prototype.getItem = function (index) {\n        this._checkPathSynchronizedToList();\n\n        this._checkValidIndex(index);\n\n        return this._list[index];\n      };\n\n      window.SVGPathSegList.prototype.insertItemBefore = function (newItem, index) {\n        this._checkPathSynchronizedToList(); // Spec: If the index is greater than or equal to numberOfItems, then the new item is appended to the end of the list.\n\n\n        if (index > this.numberOfItems) index = this.numberOfItems;\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone();\n        }\n\n        this._list.splice(index, 0, newItem);\n\n        newItem._owningPathSegList = this;\n\n        this._writeListToPath();\n\n        return newItem;\n      };\n\n      window.SVGPathSegList.prototype.replaceItem = function (newItem, index) {\n        this._checkPathSynchronizedToList();\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone();\n        }\n\n        this._checkValidIndex(index);\n\n        this._list[index] = newItem;\n        newItem._owningPathSegList = this;\n\n        this._writeListToPath();\n\n        return newItem;\n      };\n\n      window.SVGPathSegList.prototype.removeItem = function (index) {\n        this._checkPathSynchronizedToList();\n\n        this._checkValidIndex(index);\n\n        var item = this._list[index];\n\n        this._list.splice(index, 1);\n\n        this._writeListToPath();\n\n        return item;\n      };\n\n      window.SVGPathSegList.prototype.appendItem = function (newItem) {\n        this._checkPathSynchronizedToList();\n\n        if (newItem._owningPathSegList) {\n          // SVG2 spec says to make a copy.\n          newItem = newItem.clone();\n        }\n\n        this._list.push(newItem);\n\n        newItem._owningPathSegList = this; // TODO: Optimize this to just append to the existing attribute.\n\n        this._writeListToPath();\n\n        return newItem;\n      };\n\n      window.SVGPathSegList._pathSegArrayAsString = function (pathSegArray) {\n        var string = \"\";\n        var first = true;\n        pathSegArray.forEach(function (pathSeg) {\n          if (first) {\n            first = false;\n            string += pathSeg._asPathString();\n          } else {\n            string += \" \" + pathSeg._asPathString();\n          }\n        });\n        return string;\n      }; // This closely follows SVGPathParser::parsePath from Source/core/svg/SVGPathParser.cpp.\n\n\n      window.SVGPathSegList.prototype._parsePath = function (string) {\n        if (!string || string.length == 0) return [];\n        var owningPathSegList = this;\n\n        var Builder = function Builder() {\n          this.pathSegList = [];\n        };\n\n        Builder.prototype.appendSegment = function (pathSeg) {\n          this.pathSegList.push(pathSeg);\n        };\n\n        var Source = function Source(string) {\n          this._string = string;\n          this._currentIndex = 0;\n          this._endIndex = this._string.length;\n          this._previousCommand = window.SVGPathSeg.PATHSEG_UNKNOWN;\n\n          this._skipOptionalSpaces();\n        };\n\n        Source.prototype._isCurrentSpace = function () {\n          var character = this._string[this._currentIndex];\n          return character <= \" \" && (character == \" \" || character == \"\\n\" || character == \"\\t\" || character == \"\\r\" || character == \"\\f\");\n        };\n\n        Source.prototype._skipOptionalSpaces = function () {\n          while (this._currentIndex < this._endIndex && this._isCurrentSpace()) {\n            this._currentIndex++;\n          }\n\n          return this._currentIndex < this._endIndex;\n        };\n\n        Source.prototype._skipOptionalSpacesOrDelimiter = function () {\n          if (this._currentIndex < this._endIndex && !this._isCurrentSpace() && this._string.charAt(this._currentIndex) != \",\") return false;\n\n          if (this._skipOptionalSpaces()) {\n            if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == \",\") {\n              this._currentIndex++;\n\n              this._skipOptionalSpaces();\n            }\n          }\n\n          return this._currentIndex < this._endIndex;\n        };\n\n        Source.prototype.hasMoreData = function () {\n          return this._currentIndex < this._endIndex;\n        };\n\n        Source.prototype.peekSegmentType = function () {\n          var lookahead = this._string[this._currentIndex];\n          return this._pathSegTypeFromChar(lookahead);\n        };\n\n        Source.prototype._pathSegTypeFromChar = function (lookahead) {\n          switch (lookahead) {\n            case \"Z\":\n            case \"z\":\n              return window.SVGPathSeg.PATHSEG_CLOSEPATH;\n\n            case \"M\":\n              return window.SVGPathSeg.PATHSEG_MOVETO_ABS;\n\n            case \"m\":\n              return window.SVGPathSeg.PATHSEG_MOVETO_REL;\n\n            case \"L\":\n              return window.SVGPathSeg.PATHSEG_LINETO_ABS;\n\n            case \"l\":\n              return window.SVGPathSeg.PATHSEG_LINETO_REL;\n\n            case \"C\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS;\n\n            case \"c\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL;\n\n            case \"Q\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS;\n\n            case \"q\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL;\n\n            case \"A\":\n              return window.SVGPathSeg.PATHSEG_ARC_ABS;\n\n            case \"a\":\n              return window.SVGPathSeg.PATHSEG_ARC_REL;\n\n            case \"H\":\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS;\n\n            case \"h\":\n              return window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL;\n\n            case \"V\":\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS;\n\n            case \"v\":\n              return window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL;\n\n            case \"S\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS;\n\n            case \"s\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL;\n\n            case \"T\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS;\n\n            case \"t\":\n              return window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL;\n\n            default:\n              return window.SVGPathSeg.PATHSEG_UNKNOWN;\n          }\n        };\n\n        Source.prototype._nextCommandHelper = function (lookahead, previousCommand) {\n          // Check for remaining coordinates in the current command.\n          if ((lookahead == \"+\" || lookahead == \"-\" || lookahead == \".\" || lookahead >= \"0\" && lookahead <= \"9\") && previousCommand != window.SVGPathSeg.PATHSEG_CLOSEPATH) {\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_ABS) return window.SVGPathSeg.PATHSEG_LINETO_ABS;\n            if (previousCommand == window.SVGPathSeg.PATHSEG_MOVETO_REL) return window.SVGPathSeg.PATHSEG_LINETO_REL;\n            return previousCommand;\n          }\n\n          return window.SVGPathSeg.PATHSEG_UNKNOWN;\n        };\n\n        Source.prototype.initialCommandIsMoveTo = function () {\n          // If the path is empty it is still valid, so return true.\n          if (!this.hasMoreData()) return true;\n          var command = this.peekSegmentType(); // Path must start with moveTo.\n\n          return command == window.SVGPathSeg.PATHSEG_MOVETO_ABS || command == window.SVGPathSeg.PATHSEG_MOVETO_REL;\n        }; // Parse a number from an SVG path. This very closely follows genericParseNumber(...) from Source/core/svg/SVGParserUtilities.cpp.\n        // Spec: http://www.w3.org/TR/SVG11/single-page.html#paths-PathDataBNF\n\n\n        Source.prototype._parseNumber = function () {\n          var exponent = 0;\n          var integer = 0;\n          var frac = 1;\n          var decimal = 0;\n          var sign = 1;\n          var expsign = 1;\n          var startIndex = this._currentIndex;\n\n          this._skipOptionalSpaces(); // Read the sign.\n\n\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == \"+\") this._currentIndex++;else if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == \"-\") {\n            this._currentIndex++;\n            sign = -1;\n          }\n          if (this._currentIndex == this._endIndex || (this._string.charAt(this._currentIndex) < \"0\" || this._string.charAt(this._currentIndex) > \"9\") && this._string.charAt(this._currentIndex) != \".\") // The first character of a number must be one of [0-9+-.].\n            return undefined; // Read the integer part, build right-to-left.\n\n          var startIntPartIndex = this._currentIndex;\n\n          while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= \"0\" && this._string.charAt(this._currentIndex) <= \"9\") {\n            this._currentIndex++;\n          } // Advance to first non-digit.\n\n\n          if (this._currentIndex != startIntPartIndex) {\n            var scanIntPartIndex = this._currentIndex - 1;\n            var multiplier = 1;\n\n            while (scanIntPartIndex >= startIntPartIndex) {\n              integer += multiplier * (this._string.charAt(scanIntPartIndex--) - \"0\");\n              multiplier *= 10;\n            }\n          } // Read the decimals.\n\n\n          if (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) == \".\") {\n            this._currentIndex++; // There must be a least one digit following the .\n\n            if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < \"0\" || this._string.charAt(this._currentIndex) > \"9\") return undefined;\n\n            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= \"0\" && this._string.charAt(this._currentIndex) <= \"9\") {\n              frac *= 10;\n              decimal += (this._string.charAt(this._currentIndex) - \"0\") / frac;\n              this._currentIndex += 1;\n            }\n          } // Read the exponent part.\n\n\n          if (this._currentIndex != startIndex && this._currentIndex + 1 < this._endIndex && (this._string.charAt(this._currentIndex) == \"e\" || this._string.charAt(this._currentIndex) == \"E\") && this._string.charAt(this._currentIndex + 1) != \"x\" && this._string.charAt(this._currentIndex + 1) != \"m\") {\n            this._currentIndex++; // Read the sign of the exponent.\n\n            if (this._string.charAt(this._currentIndex) == \"+\") {\n              this._currentIndex++;\n            } else if (this._string.charAt(this._currentIndex) == \"-\") {\n              this._currentIndex++;\n              expsign = -1;\n            } // There must be an exponent.\n\n\n            if (this._currentIndex >= this._endIndex || this._string.charAt(this._currentIndex) < \"0\" || this._string.charAt(this._currentIndex) > \"9\") return undefined;\n\n            while (this._currentIndex < this._endIndex && this._string.charAt(this._currentIndex) >= \"0\" && this._string.charAt(this._currentIndex) <= \"9\") {\n              exponent *= 10;\n              exponent += this._string.charAt(this._currentIndex) - \"0\";\n              this._currentIndex++;\n            }\n          }\n\n          var number = integer + decimal;\n          number *= sign;\n          if (exponent) number *= Math.pow(10, expsign * exponent);\n          if (startIndex == this._currentIndex) return undefined;\n\n          this._skipOptionalSpacesOrDelimiter();\n\n          return number;\n        };\n\n        Source.prototype._parseArcFlag = function () {\n          if (this._currentIndex >= this._endIndex) return undefined;\n          var flag = false;\n\n          var flagChar = this._string.charAt(this._currentIndex++);\n\n          if (flagChar == \"0\") flag = false;else if (flagChar == \"1\") flag = true;else return undefined;\n\n          this._skipOptionalSpacesOrDelimiter();\n\n          return flag;\n        };\n\n        Source.prototype.parseSegment = function () {\n          var lookahead = this._string[this._currentIndex];\n\n          var command = this._pathSegTypeFromChar(lookahead);\n\n          if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) {\n            // Possibly an implicit command. Not allowed if this is the first command.\n            if (this._previousCommand == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;\n            command = this._nextCommandHelper(lookahead, this._previousCommand);\n            if (command == window.SVGPathSeg.PATHSEG_UNKNOWN) return null;\n          } else {\n            this._currentIndex++;\n          }\n\n          this._previousCommand = command;\n\n          switch (command) {\n            case window.SVGPathSeg.PATHSEG_MOVETO_REL:\n              return new window.SVGPathSegMovetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_MOVETO_ABS:\n              return new window.SVGPathSegMovetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_REL:\n              return new window.SVGPathSegLinetoRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_ABS:\n              return new window.SVGPathSegLinetoAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_REL:\n              return new window.SVGPathSegLinetoHorizontalRel(owningPathSegList, this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_HORIZONTAL_ABS:\n              return new window.SVGPathSegLinetoHorizontalAbs(owningPathSegList, this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_REL:\n              return new window.SVGPathSegLinetoVerticalRel(owningPathSegList, this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_LINETO_VERTICAL_ABS:\n              return new window.SVGPathSegLinetoVerticalAbs(owningPathSegList, this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_CLOSEPATH:\n              this._skipOptionalSpaces();\n\n              return new window.SVGPathSegClosePath(owningPathSegList);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoCubicRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoCubicAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.x2, points.y2);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_REL:\n              var points = {\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoCubicSmoothRel(owningPathSegList, points.x, points.y, points.x2, points.y2);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_CUBIC_SMOOTH_ABS:\n              var points = {\n                x2: this._parseNumber(),\n                y2: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoCubicSmoothAbs(owningPathSegList, points.x, points.y, points.x2, points.y2);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoQuadraticRel(owningPathSegList, points.x, points.y, points.x1, points.y1);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegCurvetoQuadraticAbs(owningPathSegList, points.x, points.y, points.x1, points.y1);\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_REL:\n              return new window.SVGPathSegCurvetoQuadraticSmoothRel(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_CURVETO_QUADRATIC_SMOOTH_ABS:\n              return new window.SVGPathSegCurvetoQuadraticSmoothAbs(owningPathSegList, this._parseNumber(), this._parseNumber());\n\n            case window.SVGPathSeg.PATHSEG_ARC_REL:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                arcAngle: this._parseNumber(),\n                arcLarge: this._parseArcFlag(),\n                arcSweep: this._parseArcFlag(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegArcRel(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);\n\n            case window.SVGPathSeg.PATHSEG_ARC_ABS:\n              var points = {\n                x1: this._parseNumber(),\n                y1: this._parseNumber(),\n                arcAngle: this._parseNumber(),\n                arcLarge: this._parseArcFlag(),\n                arcSweep: this._parseArcFlag(),\n                x: this._parseNumber(),\n                y: this._parseNumber()\n              };\n              return new window.SVGPathSegArcAbs(owningPathSegList, points.x, points.y, points.x1, points.y1, points.arcAngle, points.arcLarge, points.arcSweep);\n\n            default:\n              throw \"Unknown path seg type.\";\n          }\n        };\n\n        var builder = new Builder();\n        var source = new Source(string);\n        if (!source.initialCommandIsMoveTo()) return [];\n\n        while (source.hasMoreData()) {\n          var pathSeg = source.parseSegment();\n          if (!pathSeg) return [];\n          builder.appendSegment(pathSeg);\n        }\n\n        return builder.pathSegList;\n      };\n    }\n  })(); // String.padEnd polyfill for IE11\n  //\n  // https://github.com/uxitten/polyfill/blob/master/string.polyfill.js\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/padEnd\n\n\n  if (!String.prototype.padEnd) {\n    String.prototype.padEnd = function padEnd(targetLength, padString) {\n      targetLength = targetLength >> 0; //floor if number or convert non-number to 0;\n\n      padString = String(typeof padString !== 'undefined' ? padString : ' ');\n\n      if (this.length > targetLength) {\n        return String(this);\n      } else {\n        targetLength = targetLength - this.length;\n\n        if (targetLength > padString.length) {\n          padString += padString.repeat(targetLength / padString.length); //append to original to ensure we are longer than needed\n        }\n\n        return String(this) + padString.slice(0, targetLength);\n      }\n    };\n  }\n  /* jshint ignore:end */\n\n\n  c3_chart_fn.axis = function () {};\n\n  c3_chart_fn.axis.labels = function (labels) {\n    var $$ = this.internal;\n\n    if (arguments.length) {\n      Object.keys(labels).forEach(function (axisId) {\n        $$.axis.setLabelText(axisId, labels[axisId]);\n      });\n      $$.axis.updateLabels();\n    } // TODO: return some values?\n\n  };\n\n  c3_chart_fn.axis.max = function (max) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (arguments.length) {\n      if ((typeof max === 'undefined' ? 'undefined' : _typeof(max)) === 'object') {\n        if (isValue(max.x)) {\n          config.axis_x_max = max.x;\n        }\n\n        if (isValue(max.y)) {\n          config.axis_y_max = max.y;\n        }\n\n        if (isValue(max.y2)) {\n          config.axis_y2_max = max.y2;\n        }\n      } else {\n        config.axis_y_max = config.axis_y2_max = max;\n      }\n\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      });\n    } else {\n      return {\n        x: config.axis_x_max,\n        y: config.axis_y_max,\n        y2: config.axis_y2_max\n      };\n    }\n  };\n\n  c3_chart_fn.axis.min = function (min) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (arguments.length) {\n      if ((typeof min === 'undefined' ? 'undefined' : _typeof(min)) === 'object') {\n        if (isValue(min.x)) {\n          config.axis_x_min = min.x;\n        }\n\n        if (isValue(min.y)) {\n          config.axis_y_min = min.y;\n        }\n\n        if (isValue(min.y2)) {\n          config.axis_y2_min = min.y2;\n        }\n      } else {\n        config.axis_y_min = config.axis_y2_min = min;\n      }\n\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      });\n    } else {\n      return {\n        x: config.axis_x_min,\n        y: config.axis_y_min,\n        y2: config.axis_y2_min\n      };\n    }\n  };\n\n  c3_chart_fn.axis.range = function (range) {\n    if (arguments.length) {\n      if (isDefined(range.max)) {\n        this.axis.max(range.max);\n      }\n\n      if (isDefined(range.min)) {\n        this.axis.min(range.min);\n      }\n    } else {\n      return {\n        max: this.axis.max(),\n        min: this.axis.min()\n      };\n    }\n  };\n\n  c3_chart_fn.category = function (i, category) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (arguments.length > 1) {\n      config.axis_x_categories[i] = category;\n      $$.redraw();\n    }\n\n    return config.axis_x_categories[i];\n  };\n\n  c3_chart_fn.categories = function (categories) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (!arguments.length) {\n      return config.axis_x_categories;\n    }\n\n    config.axis_x_categories = categories;\n    $$.redraw();\n    return config.axis_x_categories;\n  };\n\n  c3_chart_fn.resize = function (size) {\n    var $$ = this.internal,\n        config = $$.config;\n    config.size_width = size ? size.width : null;\n    config.size_height = size ? size.height : null;\n    this.flush();\n  };\n\n  c3_chart_fn.flush = function () {\n    var $$ = this.internal;\n    $$.updateAndRedraw({\n      withLegend: true,\n      withTransition: false,\n      withTransitionForTransform: false\n    });\n  };\n\n  c3_chart_fn.destroy = function () {\n    var $$ = this.internal;\n    window.clearInterval($$.intervalForObserveInserted);\n\n    if ($$.resizeTimeout !== undefined) {\n      window.clearTimeout($$.resizeTimeout);\n    }\n\n    if (window.detachEvent) {\n      window.detachEvent('onresize', $$.resizeIfElementDisplayed);\n    } else if (window.removeEventListener) {\n      window.removeEventListener('resize', $$.resizeIfElementDisplayed);\n    } else {\n      var wrapper = window.onresize; // check if no one else removed our wrapper and remove our resizeFunction from it\n\n      if (wrapper && wrapper.add && wrapper.remove) {\n        wrapper.remove($$.resizeFunction);\n      }\n    } // remove the inner resize functions\n\n\n    $$.resizeFunction.remove();\n    $$.selectChart.classed('c3', false).html(\"\"); // MEMO: this is needed because the reference of some elements will not be released, then memory leak will happen.\n\n    Object.keys($$).forEach(function (key) {\n      $$[key] = null;\n    });\n    return null;\n  }; // TODO: fix\n\n\n  c3_chart_fn.color = function (id) {\n    var $$ = this.internal;\n    return $$.color(id); // more patterns\n  };\n\n  c3_chart_fn.data = function (targetIds) {\n    var targets = this.internal.data.targets;\n    return typeof targetIds === 'undefined' ? targets : targets.filter(function (t) {\n      return [].concat(targetIds).indexOf(t.id) >= 0;\n    });\n  };\n\n  c3_chart_fn.data.shown = function (targetIds) {\n    return this.internal.filterTargetsToShow(this.data(targetIds));\n  };\n\n  c3_chart_fn.data.values = function (targetId) {\n    var targets,\n        values = null;\n\n    if (targetId) {\n      targets = this.data(targetId);\n      values = targets[0] ? targets[0].values.map(function (d) {\n        return d.value;\n      }) : null;\n    }\n\n    return values;\n  };\n\n  c3_chart_fn.data.names = function (names) {\n    this.internal.clearLegendItemTextBoxCache();\n    return this.internal.updateDataAttributes('names', names);\n  };\n\n  c3_chart_fn.data.colors = function (colors) {\n    return this.internal.updateDataAttributes('colors', colors);\n  };\n\n  c3_chart_fn.data.axes = function (axes) {\n    return this.internal.updateDataAttributes('axes', axes);\n  };\n\n  c3_chart_fn.flow = function (args) {\n    var $$ = this.internal,\n        targets,\n        data,\n        notfoundIds = [],\n        orgDataCount = $$.getMaxDataCount(),\n        dataCount,\n        domain,\n        baseTarget,\n        baseValue,\n        length = 0,\n        tail = 0,\n        diff,\n        to;\n\n    if (args.json) {\n      data = $$.convertJsonToData(args.json, args.keys);\n    } else if (args.rows) {\n      data = $$.convertRowsToData(args.rows);\n    } else if (args.columns) {\n      data = $$.convertColumnsToData(args.columns);\n    } else {\n      return;\n    }\n\n    targets = $$.convertDataToTargets(data, true); // Update/Add data\n\n    $$.data.targets.forEach(function (t) {\n      var found = false,\n          i,\n          j;\n\n      for (i = 0; i < targets.length; i++) {\n        if (t.id === targets[i].id) {\n          found = true;\n\n          if (t.values[t.values.length - 1]) {\n            tail = t.values[t.values.length - 1].index + 1;\n          }\n\n          length = targets[i].values.length;\n\n          for (j = 0; j < length; j++) {\n            targets[i].values[j].index = tail + j;\n\n            if (!$$.isTimeSeries()) {\n              targets[i].values[j].x = tail + j;\n            }\n          }\n\n          t.values = t.values.concat(targets[i].values);\n          targets.splice(i, 1);\n          break;\n        }\n      }\n\n      if (!found) {\n        notfoundIds.push(t.id);\n      }\n    }); // Append null for not found targets\n\n    $$.data.targets.forEach(function (t) {\n      var i, j;\n\n      for (i = 0; i < notfoundIds.length; i++) {\n        if (t.id === notfoundIds[i]) {\n          tail = t.values[t.values.length - 1].index + 1;\n\n          for (j = 0; j < length; j++) {\n            t.values.push({\n              id: t.id,\n              index: tail + j,\n              x: $$.isTimeSeries() ? $$.getOtherTargetX(tail + j) : tail + j,\n              value: null\n            });\n          }\n        }\n      }\n    }); // Generate null values for new target\n\n    if ($$.data.targets.length) {\n      targets.forEach(function (t) {\n        var i,\n            missing = [];\n\n        for (i = $$.data.targets[0].values[0].index; i < tail; i++) {\n          missing.push({\n            id: t.id,\n            index: i,\n            x: $$.isTimeSeries() ? $$.getOtherTargetX(i) : i,\n            value: null\n          });\n        }\n\n        t.values.forEach(function (v) {\n          v.index += tail;\n\n          if (!$$.isTimeSeries()) {\n            v.x += tail;\n          }\n        });\n        t.values = missing.concat(t.values);\n      });\n    }\n\n    $$.data.targets = $$.data.targets.concat(targets); // add remained\n    // check data count because behavior needs to change when it's only one\n\n    dataCount = $$.getMaxDataCount();\n    baseTarget = $$.data.targets[0];\n    baseValue = baseTarget.values[0]; // Update length to flow if needed\n\n    if (isDefined(args.to)) {\n      length = 0;\n      to = $$.isTimeSeries() ? $$.parseDate(args.to) : args.to;\n      baseTarget.values.forEach(function (v) {\n        if (v.x < to) {\n          length++;\n        }\n      });\n    } else if (isDefined(args.length)) {\n      length = args.length;\n    } // If only one data, update the domain to flow from left edge of the chart\n\n\n    if (!orgDataCount) {\n      if ($$.isTimeSeries()) {\n        if (baseTarget.values.length > 1) {\n          diff = baseTarget.values[baseTarget.values.length - 1].x - baseValue.x;\n        } else {\n          diff = baseValue.x - $$.getXDomain($$.data.targets)[0];\n        }\n      } else {\n        diff = 1;\n      }\n\n      domain = [baseValue.x - diff, baseValue.x];\n      $$.updateXDomain(null, true, true, false, domain);\n    } else if (orgDataCount === 1) {\n      if ($$.isTimeSeries()) {\n        diff = (baseTarget.values[baseTarget.values.length - 1].x - baseValue.x) / 2;\n        domain = [new Date(+baseValue.x - diff), new Date(+baseValue.x + diff)];\n        $$.updateXDomain(null, true, true, false, domain);\n      }\n    } // Set targets\n\n\n    $$.updateTargets($$.data.targets); // Redraw with new targets\n\n    $$.redraw({\n      flow: {\n        index: baseValue.index,\n        length: length,\n        duration: isValue(args.duration) ? args.duration : $$.config.transition_duration,\n        done: args.done,\n        orgDataCount: orgDataCount\n      },\n      withLegend: true,\n      withTransition: orgDataCount > 1,\n      withTrimXDomain: false,\n      withUpdateXAxis: true\n    });\n  };\n\n  c3_chart_internal_fn.generateFlow = function (args) {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3;\n    return function () {\n      var targets = args.targets,\n          flow = args.flow,\n          drawBar = args.drawBar,\n          drawLine = args.drawLine,\n          drawArea = args.drawArea,\n          cx = args.cx,\n          cy = args.cy,\n          xv = args.xv,\n          xForText = args.xForText,\n          yForText = args.yForText,\n          duration = args.duration;\n\n      var translateX,\n          scaleX = 1,\n          transform,\n          flowIndex = flow.index,\n          flowLength = flow.length,\n          flowStart = $$.getValueOnIndex($$.data.targets[0].values, flowIndex),\n          flowEnd = $$.getValueOnIndex($$.data.targets[0].values, flowIndex + flowLength),\n          orgDomain = $$.x.domain(),\n          domain,\n          durationForFlow = flow.duration || duration,\n          done = flow.done || function () {},\n          wait = $$.generateWait();\n\n      var xgrid = $$.xgrid || d3.selectAll([]),\n          xgridLines = $$.xgridLines || d3.selectAll([]),\n          mainRegion = $$.mainRegion || d3.selectAll([]),\n          mainText = $$.mainText || d3.selectAll([]),\n          mainBar = $$.mainBar || d3.selectAll([]),\n          mainLine = $$.mainLine || d3.selectAll([]),\n          mainArea = $$.mainArea || d3.selectAll([]),\n          mainCircle = $$.mainCircle || d3.selectAll([]); // set flag\n\n      $$.flowing = true; // remove head data after rendered\n\n      $$.data.targets.forEach(function (d) {\n        d.values.splice(0, flowLength);\n      }); // update x domain to generate axis elements for flow\n\n      domain = $$.updateXDomain(targets, true, true); // update elements related to x scale\n\n      if ($$.updateXGrid) {\n        $$.updateXGrid(true);\n      } // generate transform to flow\n\n\n      if (!flow.orgDataCount) {\n        // if empty\n        if ($$.data.targets[0].values.length !== 1) {\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);\n        } else {\n          if ($$.isTimeSeries()) {\n            flowStart = $$.getValueOnIndex($$.data.targets[0].values, 0);\n            flowEnd = $$.getValueOnIndex($$.data.targets[0].values, $$.data.targets[0].values.length - 1);\n            translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);\n          } else {\n            translateX = diffDomain(domain) / 2;\n          }\n        }\n      } else if (flow.orgDataCount === 1 || (flowStart && flowStart.x) === (flowEnd && flowEnd.x)) {\n        translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);\n      } else {\n        if ($$.isTimeSeries()) {\n          translateX = $$.x(orgDomain[0]) - $$.x(domain[0]);\n        } else {\n          translateX = $$.x(flowStart.x) - $$.x(flowEnd.x);\n        }\n      }\n\n      scaleX = diffDomain(orgDomain) / diffDomain(domain);\n      transform = 'translate(' + translateX + ',0) scale(' + scaleX + ',1)';\n      $$.hideXGridFocus();\n      d3.transition().ease('linear').duration(durationForFlow).each(function () {\n        wait.add($$.axes.x.transition().call($$.xAxis));\n        wait.add(mainBar.transition().attr('transform', transform));\n        wait.add(mainLine.transition().attr('transform', transform));\n        wait.add(mainArea.transition().attr('transform', transform));\n        wait.add(mainCircle.transition().attr('transform', transform));\n        wait.add(mainText.transition().attr('transform', transform));\n        wait.add(mainRegion.filter($$.isRegionOnX).transition().attr('transform', transform));\n        wait.add(xgrid.transition().attr('transform', transform));\n        wait.add(xgridLines.transition().attr('transform', transform));\n      }).call(wait, function () {\n        var i,\n            shapes = [],\n            texts = [],\n            eventRects = []; // remove flowed elements\n\n        if (flowLength) {\n          for (i = 0; i < flowLength; i++) {\n            shapes.push('.' + CLASS.shape + '-' + (flowIndex + i));\n            texts.push('.' + CLASS.text + '-' + (flowIndex + i));\n            eventRects.push('.' + CLASS.eventRect + '-' + (flowIndex + i));\n          }\n\n          $$.svg.selectAll('.' + CLASS.shapes).selectAll(shapes).remove();\n          $$.svg.selectAll('.' + CLASS.texts).selectAll(texts).remove();\n          $$.svg.selectAll('.' + CLASS.eventRects).selectAll(eventRects).remove();\n          $$.svg.select('.' + CLASS.xgrid).remove();\n        } // draw again for removing flowed elements and reverting attr\n\n\n        xgrid.attr('transform', null).attr($$.xgridAttr);\n        xgridLines.attr('transform', null);\n        xgridLines.select('line').attr(\"x1\", config.axis_rotated ? 0 : xv).attr(\"x2\", config.axis_rotated ? $$.width : xv);\n        xgridLines.select('text').attr(\"x\", config.axis_rotated ? $$.width : 0).attr(\"y\", xv);\n        mainBar.attr('transform', null).attr(\"d\", drawBar);\n        mainLine.attr('transform', null).attr(\"d\", drawLine);\n        mainArea.attr('transform', null).attr(\"d\", drawArea);\n        mainCircle.attr('transform', null).attr(\"cx\", cx).attr(\"cy\", cy);\n        mainText.attr('transform', null).attr('x', xForText).attr('y', yForText).style('fill-opacity', $$.opacityForText.bind($$));\n        mainRegion.attr('transform', null);\n        mainRegion.select('rect').filter($$.isRegionOnX).attr(\"x\", $$.regionX.bind($$)).attr(\"width\", $$.regionWidth.bind($$));\n\n        if (config.interaction_enabled) {\n          $$.redrawEventRect();\n        } // callback for end of flow\n\n\n        done();\n        $$.flowing = false;\n      });\n    };\n  };\n\n  c3_chart_fn.focus = function (targetIds) {\n    var $$ = this.internal,\n        candidates;\n    targetIds = $$.mapToTargetIds(targetIds);\n    candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), this.revert();\n    this.defocus();\n    candidates.classed(CLASS.focused, true).classed(CLASS.defocused, false);\n\n    if ($$.hasArcType()) {\n      $$.expandArc(targetIds);\n    }\n\n    $$.toggleFocusLegend(targetIds, true);\n    $$.focusedTargetIds = targetIds;\n    $$.defocusedTargetIds = $$.defocusedTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0;\n    });\n  };\n\n  c3_chart_fn.defocus = function (targetIds) {\n    var $$ = this.internal,\n        candidates;\n    targetIds = $$.mapToTargetIds(targetIds);\n    candidates = $$.svg.selectAll($$.selectorTargets(targetIds.filter($$.isTargetToShow, $$))), candidates.classed(CLASS.focused, false).classed(CLASS.defocused, true);\n\n    if ($$.hasArcType()) {\n      $$.unexpandArc(targetIds);\n    }\n\n    $$.toggleFocusLegend(targetIds, false);\n    $$.focusedTargetIds = $$.focusedTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0;\n    });\n    $$.defocusedTargetIds = targetIds;\n  };\n\n  c3_chart_fn.revert = function (targetIds) {\n    var $$ = this.internal,\n        candidates;\n    targetIds = $$.mapToTargetIds(targetIds);\n    candidates = $$.svg.selectAll($$.selectorTargets(targetIds)); // should be for all targets\n\n    candidates.classed(CLASS.focused, false).classed(CLASS.defocused, false);\n\n    if ($$.hasArcType()) {\n      $$.unexpandArc(targetIds);\n    }\n\n    if ($$.config.legend_show) {\n      $$.showLegend(targetIds.filter($$.isLegendToShow.bind($$)));\n      $$.legend.selectAll($$.selectorLegends(targetIds)).filter(function () {\n        return $$.d3.select(this).classed(CLASS.legendItemFocused);\n      }).classed(CLASS.legendItemFocused, false);\n    }\n\n    $$.focusedTargetIds = [];\n    $$.defocusedTargetIds = [];\n  };\n\n  c3_chart_fn.xgrids = function (grids) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (!grids) {\n      return config.grid_x_lines;\n    }\n\n    config.grid_x_lines = grids;\n    $$.redrawWithoutRescale();\n    return config.grid_x_lines;\n  };\n\n  c3_chart_fn.xgrids.add = function (grids) {\n    var $$ = this.internal;\n    return this.xgrids($$.config.grid_x_lines.concat(grids ? grids : []));\n  };\n\n  c3_chart_fn.xgrids.remove = function (params) {\n    // TODO: multiple\n    var $$ = this.internal;\n    $$.removeGridLines(params, true);\n  };\n\n  c3_chart_fn.ygrids = function (grids) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (!grids) {\n      return config.grid_y_lines;\n    }\n\n    config.grid_y_lines = grids;\n    $$.redrawWithoutRescale();\n    return config.grid_y_lines;\n  };\n\n  c3_chart_fn.ygrids.add = function (grids) {\n    var $$ = this.internal;\n    return this.ygrids($$.config.grid_y_lines.concat(grids ? grids : []));\n  };\n\n  c3_chart_fn.ygrids.remove = function (params) {\n    // TODO: multiple\n    var $$ = this.internal;\n    $$.removeGridLines(params, false);\n  };\n\n  c3_chart_fn.groups = function (groups) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (isUndefined(groups)) {\n      return config.data_groups;\n    }\n\n    config.data_groups = groups;\n    $$.redraw();\n    return config.data_groups;\n  };\n\n  c3_chart_fn.legend = function () {};\n\n  c3_chart_fn.legend.show = function (targetIds) {\n    var $$ = this.internal;\n    $$.showLegend($$.mapToTargetIds(targetIds));\n    $$.updateAndRedraw({\n      withLegend: true\n    });\n  };\n\n  c3_chart_fn.legend.hide = function (targetIds) {\n    var $$ = this.internal;\n    $$.hideLegend($$.mapToTargetIds(targetIds));\n    $$.updateAndRedraw({\n      withLegend: true\n    });\n  };\n\n  c3_chart_fn.load = function (args) {\n    var $$ = this.internal,\n        config = $$.config; // update xs if specified\n\n    if (args.xs) {\n      $$.addXs(args.xs);\n    } // update names if exists\n\n\n    if ('names' in args) {\n      c3_chart_fn.data.names.bind(this)(args.names);\n    } // update classes if exists\n\n\n    if ('classes' in args) {\n      Object.keys(args.classes).forEach(function (id) {\n        config.data_classes[id] = args.classes[id];\n      });\n    } // update categories if exists\n\n\n    if ('categories' in args && $$.isCategorized()) {\n      config.axis_x_categories = args.categories;\n    } // update axes if exists\n\n\n    if ('axes' in args) {\n      Object.keys(args.axes).forEach(function (id) {\n        config.data_axes[id] = args.axes[id];\n      });\n    } // update colors if exists\n\n\n    if ('colors' in args) {\n      Object.keys(args.colors).forEach(function (id) {\n        config.data_colors[id] = args.colors[id];\n      });\n    } // use cache if exists\n\n\n    if ('cacheIds' in args && $$.hasCaches(args.cacheIds)) {\n      $$.load($$.getCaches(args.cacheIds), args.done);\n      return;\n    } // unload if needed\n\n\n    if ('unload' in args) {\n      // TODO: do not unload if target will load (included in url/rows/columns)\n      $$.unload($$.mapToTargetIds(typeof args.unload === 'boolean' && args.unload ? null : args.unload), function () {\n        $$.loadFromArgs(args);\n      });\n    } else {\n      $$.loadFromArgs(args);\n    }\n  };\n\n  c3_chart_fn.unload = function (args) {\n    var $$ = this.internal;\n    args = args || {};\n\n    if (args instanceof Array) {\n      args = {\n        ids: args\n      };\n    } else if (typeof args === 'string') {\n      args = {\n        ids: [args]\n      };\n    }\n\n    $$.unload($$.mapToTargetIds(args.ids), function () {\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true,\n        withLegend: true\n      });\n\n      if (args.done) {\n        args.done();\n      }\n    });\n  };\n\n  c3_chart_fn.regions = function (regions) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (!regions) {\n      return config.regions;\n    }\n\n    config.regions = regions;\n    $$.redrawWithoutRescale();\n    return config.regions;\n  };\n\n  c3_chart_fn.regions.add = function (regions) {\n    var $$ = this.internal,\n        config = $$.config;\n\n    if (!regions) {\n      return config.regions;\n    }\n\n    config.regions = config.regions.concat(regions);\n    $$.redrawWithoutRescale();\n    return config.regions;\n  };\n\n  c3_chart_fn.regions.remove = function (options) {\n    var $$ = this.internal,\n        config = $$.config,\n        duration,\n        classes,\n        regions;\n    options = options || {};\n    duration = $$.getOption(options, \"duration\", config.transition_duration);\n    classes = $$.getOption(options, \"classes\", [CLASS.region]);\n    regions = $$.main.select('.' + CLASS.regions).selectAll(classes.map(function (c) {\n      return '.' + c;\n    }));\n    (duration ? regions.transition().duration(duration) : regions).style('opacity', 0).remove();\n    config.regions = config.regions.filter(function (region) {\n      var found = false;\n\n      if (!region['class']) {\n        return true;\n      }\n\n      region['class'].split(' ').forEach(function (c) {\n        if (classes.indexOf(c) >= 0) {\n          found = true;\n        }\n      });\n      return !found;\n    });\n    return config.regions;\n  };\n\n  c3_chart_fn.selected = function (targetId) {\n    var $$ = this.internal,\n        d3 = $$.d3;\n    return d3.merge($$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(targetId)).selectAll('.' + CLASS.shape).filter(function () {\n      return d3.select(this).classed(CLASS.SELECTED);\n    }).map(function (d) {\n      return d.map(function (d) {\n        var data = d.__data__;\n        return data.data ? data.data : data;\n      });\n    }));\n  };\n\n  c3_chart_fn.select = function (ids, indices, resetOther) {\n    var $$ = this.internal,\n        d3 = $$.d3,\n        config = $$.config;\n\n    if (!config.data_selection_enabled) {\n      return;\n    }\n\n    $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {\n      var shape = d3.select(this),\n          id = d.data ? d.data.id : d.id,\n          toggle = $$.getToggle(this, d).bind($$),\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\n          isSelected = shape.classed(CLASS.SELECTED); // line/area selection not supported yet\n\n      if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\n        return;\n      }\n\n      if (isTargetId && isTargetIndex) {\n        if (config.data_selection_isselectable(d) && !isSelected) {\n          toggle(true, shape.classed(CLASS.SELECTED, true), d, i);\n        }\n      } else if (isDefined(resetOther) && resetOther) {\n        if (isSelected) {\n          toggle(false, shape.classed(CLASS.SELECTED, false), d, i);\n        }\n      }\n    });\n  };\n\n  c3_chart_fn.unselect = function (ids, indices) {\n    var $$ = this.internal,\n        d3 = $$.d3,\n        config = $$.config;\n\n    if (!config.data_selection_enabled) {\n      return;\n    }\n\n    $$.main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).each(function (d, i) {\n      var shape = d3.select(this),\n          id = d.data ? d.data.id : d.id,\n          toggle = $$.getToggle(this, d).bind($$),\n          isTargetId = config.data_selection_grouped || !ids || ids.indexOf(id) >= 0,\n          isTargetIndex = !indices || indices.indexOf(i) >= 0,\n          isSelected = shape.classed(CLASS.SELECTED); // line/area selection not supported yet\n\n      if (shape.classed(CLASS.line) || shape.classed(CLASS.area)) {\n        return;\n      }\n\n      if (isTargetId && isTargetIndex) {\n        if (config.data_selection_isselectable(d)) {\n          if (isSelected) {\n            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);\n          }\n        }\n      }\n    });\n  };\n\n  c3_chart_fn.show = function (targetIds, options) {\n    var $$ = this.internal,\n        targets;\n    targetIds = $$.mapToTargetIds(targetIds);\n    options = options || {};\n    $$.removeHiddenTargetIds(targetIds);\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds));\n    targets.transition().style('opacity', 1, 'important').call($$.endall, function () {\n      targets.style('opacity', null).style('opacity', 1);\n    });\n\n    if (options.withLegend) {\n      $$.showLegend(targetIds);\n    }\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    });\n  };\n\n  c3_chart_fn.hide = function (targetIds, options) {\n    var $$ = this.internal,\n        targets;\n    targetIds = $$.mapToTargetIds(targetIds);\n    options = options || {};\n    $$.addHiddenTargetIds(targetIds);\n    targets = $$.svg.selectAll($$.selectorTargets(targetIds));\n    targets.transition().style('opacity', 0, 'important').call($$.endall, function () {\n      targets.style('opacity', null).style('opacity', 0);\n    });\n\n    if (options.withLegend) {\n      $$.hideLegend(targetIds);\n    }\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    });\n  };\n\n  c3_chart_fn.toggle = function (targetIds, options) {\n    var that = this,\n        $$ = this.internal;\n    $$.mapToTargetIds(targetIds).forEach(function (targetId) {\n      $$.isTargetToShow(targetId) ? that.hide(targetId, options) : that.show(targetId, options);\n    });\n  };\n\n  c3_chart_fn.tooltip = function () {};\n\n  c3_chart_fn.tooltip.show = function (args) {\n    var $$ = this.internal,\n        index,\n        mouse; // determine mouse position on the chart\n\n    if (args.mouse) {\n      mouse = args.mouse;\n    } // determine focus data\n\n\n    if (args.data) {\n      if ($$.isMultipleX()) {\n        // if multiple xs, target point will be determined by mouse\n        mouse = [$$.x(args.data.x), $$.getYScale(args.data.id)(args.data.value)];\n        index = null;\n      } else {\n        // TODO: when tooltip_grouped = false\n        index = isValue(args.data.index) ? args.data.index : $$.getIndexByX(args.data.x);\n      }\n    } else if (typeof args.x !== 'undefined') {\n      index = $$.getIndexByX(args.x);\n    } else if (typeof args.index !== 'undefined') {\n      index = args.index;\n    } // emulate mouse events to show\n\n\n    $$.dispatchEvent('mouseover', index, mouse);\n    $$.dispatchEvent('mousemove', index, mouse);\n    $$.config.tooltip_onshow.call($$, args.data);\n  };\n\n  c3_chart_fn.tooltip.hide = function () {\n    // TODO: get target data by checking the state of focus\n    this.internal.dispatchEvent('mouseout', 0);\n    this.internal.config.tooltip_onhide.call(this);\n  };\n\n  c3_chart_fn.transform = function (type, targetIds) {\n    var $$ = this.internal,\n        options = ['pie', 'donut'].indexOf(type) >= 0 ? {\n      withTransform: true\n    } : null;\n    $$.transformTo(targetIds, type, options);\n  };\n\n  c3_chart_internal_fn.transformTo = function (targetIds, type, optionsForRedraw) {\n    var $$ = this,\n        withTransitionForAxis = !$$.hasArcType(),\n        options = optionsForRedraw || {\n      withTransitionForAxis: withTransitionForAxis\n    };\n    options.withTransitionForTransform = false;\n    $$.transiting = false;\n    $$.setTargetType(targetIds, type);\n    $$.updateTargets($$.data.targets); // this is needed when transforming to arc\n\n    $$.updateAndRedraw(options);\n  };\n\n  c3_chart_fn.x = function (x) {\n    var $$ = this.internal;\n\n    if (arguments.length) {\n      $$.updateTargetX($$.data.targets, x);\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      });\n    }\n\n    return $$.data.xs;\n  };\n\n  c3_chart_fn.xs = function (xs) {\n    var $$ = this.internal;\n\n    if (arguments.length) {\n      $$.updateTargetXs($$.data.targets, xs);\n      $$.redraw({\n        withUpdateOrgXDomain: true,\n        withUpdateXDomain: true\n      });\n    }\n\n    return $$.data.xs;\n  };\n\n  c3_chart_fn.zoom = function (domain) {\n    var $$ = this.internal;\n\n    if (domain) {\n      if ($$.isTimeSeries()) {\n        domain = domain.map(function (x) {\n          return $$.parseDate(x);\n        });\n      }\n\n      $$.brush.extent(domain);\n      $$.redraw({\n        withUpdateXDomain: true,\n        withY: $$.config.zoom_rescale\n      });\n      $$.config.zoom_onzoom.call(this, $$.x.orgDomain());\n    }\n\n    return $$.brush.extent();\n  };\n\n  c3_chart_fn.zoom.enable = function (enabled) {\n    var $$ = this.internal;\n    $$.config.zoom_enabled = enabled;\n    $$.updateAndRedraw();\n  };\n\n  c3_chart_fn.unzoom = function () {\n    var $$ = this.internal;\n    $$.brush.clear().update();\n    $$.redraw({\n      withUpdateXDomain: true\n    });\n  };\n\n  c3_chart_fn.zoom.max = function (max) {\n    var $$ = this.internal,\n        config = $$.config,\n        d3 = $$.d3;\n\n    if (max === 0 || max) {\n      config.zoom_x_max = d3.max([$$.orgXDomain[1], max]);\n    } else {\n      return config.zoom_x_max;\n    }\n  };\n\n  c3_chart_fn.zoom.min = function (min) {\n    var $$ = this.internal,\n        config = $$.config,\n        d3 = $$.d3;\n\n    if (min === 0 || min) {\n      config.zoom_x_min = d3.min([$$.orgXDomain[0], min]);\n    } else {\n      return config.zoom_x_min;\n    }\n  };\n\n  c3_chart_fn.zoom.range = function (range) {\n    if (arguments.length) {\n      if (isDefined(range.max)) {\n        this.domain.max(range.max);\n      }\n\n      if (isDefined(range.min)) {\n        this.domain.min(range.min);\n      }\n    } else {\n      return {\n        max: this.domain.max(),\n        min: this.domain.min()\n      };\n    }\n  };\n\n  c3_chart_internal_fn.initPie = function () {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.pie = d3.layout.pie().value(function (d) {\n      return d.values.reduce(function (a, b) {\n        return a + b.value;\n      }, 0);\n    });\n    $$.pie.sort($$.getOrderFunction() || null);\n  };\n\n  c3_chart_internal_fn.updateRadius = function () {\n    var $$ = this,\n        config = $$.config,\n        w = config.gauge_width || config.donut_width,\n        gaugeArcWidth = $$.filterTargetsToShow($$.data.targets).length * $$.config.gauge_arcs_minWidth;\n    $$.radiusExpanded = Math.min($$.arcWidth, $$.arcHeight) / 2 * ($$.hasType('gauge') ? 0.85 : 1);\n    $$.radius = $$.radiusExpanded * 0.95;\n    $$.innerRadiusRatio = w ? ($$.radius - w) / $$.radius : 0.6;\n    $$.innerRadius = $$.hasType('donut') || $$.hasType('gauge') ? $$.radius * $$.innerRadiusRatio : 0;\n    $$.gaugeArcWidth = w ? w : gaugeArcWidth <= $$.radius - $$.innerRadius ? $$.radius - $$.innerRadius : gaugeArcWidth <= $$.radius ? gaugeArcWidth : $$.radius;\n  };\n\n  c3_chart_internal_fn.updateArc = function () {\n    var $$ = this;\n    $$.svgArc = $$.getSvgArc();\n    $$.svgArcExpanded = $$.getSvgArcExpanded();\n    $$.svgArcExpandedSub = $$.getSvgArcExpanded(0.98);\n  };\n\n  c3_chart_internal_fn.updateAngle = function (d) {\n    var $$ = this,\n        config = $$.config,\n        found = false,\n        index = 0,\n        gMin,\n        gMax,\n        gTic,\n        gValue;\n\n    if (!config) {\n      return null;\n    }\n\n    $$.pie($$.filterTargetsToShow($$.data.targets)).forEach(function (t) {\n      if (!found && t.data.id === d.data.id) {\n        found = true;\n        d = t;\n        d.index = index;\n      }\n\n      index++;\n    });\n\n    if (isNaN(d.startAngle)) {\n      d.startAngle = 0;\n    }\n\n    if (isNaN(d.endAngle)) {\n      d.endAngle = d.startAngle;\n    }\n\n    if ($$.isGaugeType(d.data)) {\n      gMin = config.gauge_min;\n      gMax = config.gauge_max;\n      gTic = Math.PI * (config.gauge_fullCircle ? 2 : 1) / (gMax - gMin);\n      gValue = d.value < gMin ? 0 : d.value < gMax ? d.value - gMin : gMax - gMin;\n      d.startAngle = config.gauge_startingAngle;\n      d.endAngle = d.startAngle + gTic * gValue;\n    }\n\n    return found ? d : null;\n  };\n\n  c3_chart_internal_fn.getSvgArc = function () {\n    var $$ = this,\n        hasGaugeType = $$.hasType('gauge'),\n        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\n        arc = $$.d3.svg.arc().outerRadius(function (d) {\n      return hasGaugeType ? $$.radius - singleArcWidth * d.index : $$.radius;\n    }).innerRadius(function (d) {\n      return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;\n    }),\n        newArc = function newArc(d, withoutUpdate) {\n      var updated;\n\n      if (withoutUpdate) {\n        return arc(d);\n      } // for interpolate\n\n\n      updated = $$.updateAngle(d);\n      return updated ? arc(updated) : \"M 0 0\";\n    }; // TODO: extends all function\n\n\n    newArc.centroid = arc.centroid;\n    return newArc;\n  };\n\n  c3_chart_internal_fn.getSvgArcExpanded = function (rate) {\n    rate = rate || 1;\n    var $$ = this,\n        hasGaugeType = $$.hasType('gauge'),\n        singleArcWidth = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length,\n        expandWidth = Math.min($$.radiusExpanded * rate - $$.radius, singleArcWidth * 0.8 - (1 - rate) * 100),\n        arc = $$.d3.svg.arc().outerRadius(function (d) {\n      return hasGaugeType ? $$.radius - singleArcWidth * d.index + expandWidth : $$.radiusExpanded * rate;\n    }).innerRadius(function (d) {\n      return hasGaugeType ? $$.radius - singleArcWidth * (d.index + 1) : $$.innerRadius;\n    });\n    return function (d) {\n      var updated = $$.updateAngle(d);\n      return updated ? arc(updated) : \"M 0 0\";\n    };\n  };\n\n  c3_chart_internal_fn.getArc = function (d, withoutUpdate, force) {\n    return force || this.isArcType(d.data) ? this.svgArc(d, withoutUpdate) : \"M 0 0\";\n  };\n\n  c3_chart_internal_fn.transformForArcLabel = function (d) {\n    var $$ = this,\n        config = $$.config,\n        updated = $$.updateAngle(d),\n        c,\n        x,\n        y,\n        h,\n        ratio,\n        translate = \"\",\n        hasGauge = $$.hasType('gauge');\n\n    if (updated && !hasGauge) {\n      c = this.svgArc.centroid(updated);\n      x = isNaN(c[0]) ? 0 : c[0];\n      y = isNaN(c[1]) ? 0 : c[1];\n      h = Math.sqrt(x * x + y * y);\n\n      if ($$.hasType('donut') && config.donut_label_ratio) {\n        ratio = isFunction(config.donut_label_ratio) ? config.donut_label_ratio(d, $$.radius, h) : config.donut_label_ratio;\n      } else if ($$.hasType('pie') && config.pie_label_ratio) {\n        ratio = isFunction(config.pie_label_ratio) ? config.pie_label_ratio(d, $$.radius, h) : config.pie_label_ratio;\n      } else {\n        ratio = $$.radius && h ? (36 / $$.radius > 0.375 ? 1.175 - 36 / $$.radius : 0.8) * $$.radius / h : 0;\n      }\n\n      translate = \"translate(\" + x * ratio + ',' + y * ratio + \")\";\n    } else if (updated && hasGauge && $$.filterTargetsToShow($$.data.targets).length > 1) {\n      var y1 = Math.sin(updated.endAngle - Math.PI / 2);\n      x = Math.cos(updated.endAngle - Math.PI / 2) * ($$.radiusExpanded + 25);\n      y = y1 * ($$.radiusExpanded + 15 - Math.abs(y1 * 10)) + 3;\n      translate = \"translate(\" + x + ',' + y + \")\";\n    }\n\n    return translate;\n  };\n\n  c3_chart_internal_fn.getArcRatio = function (d) {\n    var $$ = this,\n        config = $$.config,\n        whole = Math.PI * ($$.hasType('gauge') && !config.gauge_fullCircle ? 1 : 2);\n    return d ? (d.endAngle - d.startAngle) / whole : null;\n  };\n\n  c3_chart_internal_fn.convertToArcData = function (d) {\n    return this.addName({\n      id: d.data.id,\n      value: d.value,\n      ratio: this.getArcRatio(d),\n      index: d.index\n    });\n  };\n\n  c3_chart_internal_fn.textForArcLabel = function (d) {\n    var $$ = this,\n        updated,\n        value,\n        ratio,\n        id,\n        format;\n\n    if (!$$.shouldShowArcLabel()) {\n      return \"\";\n    }\n\n    updated = $$.updateAngle(d);\n    value = updated ? updated.value : null;\n    ratio = $$.getArcRatio(updated);\n    id = d.data.id;\n\n    if (!$$.hasType('gauge') && !$$.meetsArcLabelThreshold(ratio)) {\n      return \"\";\n    }\n\n    format = $$.getArcLabelFormat();\n    return format ? format(value, ratio, id) : $$.defaultArcValueFormat(value, ratio);\n  };\n\n  c3_chart_internal_fn.textForGaugeMinMax = function (value, isMax) {\n    var $$ = this,\n        format = $$.getGaugeLabelExtents();\n    return format ? format(value, isMax) : value;\n  };\n\n  c3_chart_internal_fn.expandArc = function (targetIds) {\n    var $$ = this,\n        interval; // MEMO: avoid to cancel transition\n\n    if ($$.transiting) {\n      interval = window.setInterval(function () {\n        if (!$$.transiting) {\n          window.clearInterval(interval);\n\n          if ($$.legend.selectAll('.c3-legend-item-focused').size() > 0) {\n            $$.expandArc(targetIds);\n          }\n        }\n      }, 10);\n      return;\n    }\n\n    targetIds = $$.mapToTargetIds(targetIds);\n    $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).each(function (d) {\n      if (!$$.shouldExpand(d.data.id)) {\n        return;\n      }\n\n      $$.d3.select(this).selectAll('path').transition().duration($$.expandDuration(d.data.id)).attr(\"d\", $$.svgArcExpanded).transition().duration($$.expandDuration(d.data.id) * 2).attr(\"d\", $$.svgArcExpandedSub).each(function (d) {\n        if ($$.isDonutType(d.data)) {// callback here\n        }\n      });\n    });\n  };\n\n  c3_chart_internal_fn.unexpandArc = function (targetIds) {\n    var $$ = this;\n\n    if ($$.transiting) {\n      return;\n    }\n\n    targetIds = $$.mapToTargetIds(targetIds);\n    $$.svg.selectAll($$.selectorTargets(targetIds, '.' + CLASS.chartArc)).selectAll('path').transition().duration(function (d) {\n      return $$.expandDuration(d.data.id);\n    }).attr(\"d\", $$.svgArc);\n    $$.svg.selectAll('.' + CLASS.arc);\n  };\n\n  c3_chart_internal_fn.expandDuration = function (id) {\n    var $$ = this,\n        config = $$.config;\n\n    if ($$.isDonutType(id)) {\n      return config.donut_expand_duration;\n    } else if ($$.isGaugeType(id)) {\n      return config.gauge_expand_duration;\n    } else if ($$.isPieType(id)) {\n      return config.pie_expand_duration;\n    } else {\n      return 50;\n    }\n  };\n\n  c3_chart_internal_fn.shouldExpand = function (id) {\n    var $$ = this,\n        config = $$.config;\n    return $$.isDonutType(id) && config.donut_expand || $$.isGaugeType(id) && config.gauge_expand || $$.isPieType(id) && config.pie_expand;\n  };\n\n  c3_chart_internal_fn.shouldShowArcLabel = function () {\n    var $$ = this,\n        config = $$.config,\n        shouldShow = true;\n\n    if ($$.hasType('donut')) {\n      shouldShow = config.donut_label_show;\n    } else if ($$.hasType('pie')) {\n      shouldShow = config.pie_label_show;\n    } // when gauge, always true\n\n\n    return shouldShow;\n  };\n\n  c3_chart_internal_fn.meetsArcLabelThreshold = function (ratio) {\n    var $$ = this,\n        config = $$.config,\n        threshold = $$.hasType('donut') ? config.donut_label_threshold : config.pie_label_threshold;\n    return ratio >= threshold;\n  };\n\n  c3_chart_internal_fn.getArcLabelFormat = function () {\n    var $$ = this,\n        config = $$.config,\n        format = config.pie_label_format;\n\n    if ($$.hasType('gauge')) {\n      format = config.gauge_label_format;\n    } else if ($$.hasType('donut')) {\n      format = config.donut_label_format;\n    }\n\n    return format;\n  };\n\n  c3_chart_internal_fn.getGaugeLabelExtents = function () {\n    var $$ = this,\n        config = $$.config;\n    return config.gauge_label_extents;\n  };\n\n  c3_chart_internal_fn.getArcTitle = function () {\n    var $$ = this;\n    return $$.hasType('donut') ? $$.config.donut_title : \"\";\n  };\n\n  c3_chart_internal_fn.updateTargetsForArc = function (targets) {\n    var $$ = this,\n        main = $$.main,\n        mainPieUpdate,\n        mainPieEnter,\n        classChartArc = $$.classChartArc.bind($$),\n        classArcs = $$.classArcs.bind($$),\n        classFocus = $$.classFocus.bind($$);\n    mainPieUpdate = main.select('.' + CLASS.chartArcs).selectAll('.' + CLASS.chartArc).data($$.pie(targets)).attr(\"class\", function (d) {\n      return classChartArc(d) + classFocus(d.data);\n    });\n    mainPieEnter = mainPieUpdate.enter().append(\"g\").attr(\"class\", classChartArc);\n    mainPieEnter.append('g').attr('class', classArcs);\n    mainPieEnter.append(\"text\").attr(\"dy\", $$.hasType('gauge') ? \"-.1em\" : \".35em\").style(\"opacity\", 0).style(\"text-anchor\", \"middle\").style(\"pointer-events\", \"none\"); // MEMO: can not keep same color..., but not bad to update color in redraw\n    //mainPieUpdate.exit().remove();\n  };\n\n  c3_chart_internal_fn.initArc = function () {\n    var $$ = this;\n    $$.arcs = $$.main.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartArcs).attr(\"transform\", $$.getTranslate('arc'));\n    $$.arcs.append('text').attr('class', CLASS.chartArcsTitle).style(\"text-anchor\", \"middle\").text($$.getArcTitle());\n  };\n\n  c3_chart_internal_fn.redrawArc = function (duration, durationForExit, withTransform) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config,\n        main = $$.main,\n        mainArc,\n        backgroundArc,\n        mainArcLabelLine,\n        hasGaugeType = $$.hasType('gauge');\n    mainArc = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arc).data($$.arcData.bind($$));\n    mainArc.enter().append('path').attr(\"class\", $$.classArc.bind($$)).style(\"fill\", function (d) {\n      return $$.color(d.data);\n    }).style(\"cursor\", function (d) {\n      return config.interaction_enabled && config.data_selection_isselectable(d) ? \"pointer\" : null;\n    }).each(function (d) {\n      if ($$.isGaugeType(d.data)) {\n        d.startAngle = d.endAngle = config.gauge_startingAngle;\n      }\n\n      this._current = d;\n    });\n\n    if (hasGaugeType) {\n      mainArcLabelLine = main.selectAll('.' + CLASS.arcs).selectAll('.' + CLASS.arcLabelLine).data($$.arcData.bind($$));\n      mainArcLabelLine.enter().append('rect').attr(\"class\", function (d) {\n        return CLASS.arcLabelLine + ' ' + CLASS.target + ' ' + CLASS.target + '-' + d.data.id;\n      });\n\n      if ($$.filterTargetsToShow($$.data.targets).length === 1) {\n        mainArcLabelLine.style(\"display\", \"none\");\n      } else {\n        mainArcLabelLine.style(\"fill\", function (d) {\n          return config.color_pattern.length > 0 ? $$.levelColor(d.data.values[0].value) : $$.color(d.data);\n        }).style(\"display\", config.gauge_labelLine_show ? \"\" : \"none\").each(function (d) {\n          var lineLength = 0,\n              lineThickness = 2,\n              x = 0,\n              y = 0,\n              transform = \"\";\n\n          if ($$.hiddenTargetIds.indexOf(d.data.id) < 0) {\n            var updated = $$.updateAngle(d),\n                innerLineLength = $$.gaugeArcWidth / $$.filterTargetsToShow($$.data.targets).length * (updated.index + 1),\n                lineAngle = updated.endAngle - Math.PI / 2,\n                arcInnerRadius = $$.radius - innerLineLength,\n                linePositioningAngle = lineAngle - (arcInnerRadius === 0 ? 0 : 1 / arcInnerRadius);\n            lineLength = $$.radiusExpanded - $$.radius + innerLineLength;\n            x = Math.cos(linePositioningAngle) * arcInnerRadius;\n            y = Math.sin(linePositioningAngle) * arcInnerRadius;\n            transform = \"rotate(\" + lineAngle * 180 / Math.PI + \", \" + x + \", \" + y + \")\";\n          }\n\n          d3.select(this).attr({\n            x: x,\n            y: y,\n            width: lineLength,\n            height: lineThickness,\n            transform: transform\n          }).style(\"stroke-dasharray\", \"0, \" + (lineLength + lineThickness) + \", 0\");\n        });\n      }\n    }\n\n    mainArc.attr(\"transform\", function (d) {\n      return !$$.isGaugeType(d.data) && withTransform ? \"scale(0)\" : \"\";\n    }).on('mouseover', config.interaction_enabled ? function (d) {\n      var updated, arcData;\n\n      if ($$.transiting) {\n        // skip while transiting\n        return;\n      }\n\n      updated = $$.updateAngle(d);\n\n      if (updated) {\n        arcData = $$.convertToArcData(updated); // transitions\n\n        $$.expandArc(updated.data.id);\n        $$.api.focus(updated.data.id);\n        $$.toggleFocusLegend(updated.data.id, true);\n        $$.config.data_onmouseover(arcData, this);\n      }\n    } : null).on('mousemove', config.interaction_enabled ? function (d) {\n      var updated = $$.updateAngle(d),\n          arcData,\n          selectedData;\n\n      if (updated) {\n        arcData = $$.convertToArcData(updated), selectedData = [arcData];\n        $$.showTooltip(selectedData, this);\n      }\n    } : null).on('mouseout', config.interaction_enabled ? function (d) {\n      var updated, arcData;\n\n      if ($$.transiting) {\n        // skip while transiting\n        return;\n      }\n\n      updated = $$.updateAngle(d);\n\n      if (updated) {\n        arcData = $$.convertToArcData(updated); // transitions\n\n        $$.unexpandArc(updated.data.id);\n        $$.api.revert();\n        $$.revertLegend();\n        $$.hideTooltip();\n        $$.config.data_onmouseout(arcData, this);\n      }\n    } : null).on('click', config.interaction_enabled ? function (d, i) {\n      var updated = $$.updateAngle(d),\n          arcData;\n\n      if (updated) {\n        arcData = $$.convertToArcData(updated);\n\n        if ($$.toggleShape) {\n          $$.toggleShape(this, arcData, i);\n        }\n\n        $$.config.data_onclick.call($$.api, arcData, this);\n      }\n    } : null).each(function () {\n      $$.transiting = true;\n    }).transition().duration(duration).attrTween(\"d\", function (d) {\n      var updated = $$.updateAngle(d),\n          interpolate;\n\n      if (!updated) {\n        return function () {\n          return \"M 0 0\";\n        };\n      } //                if (this._current === d) {\n      //                    this._current = {\n      //                        startAngle: Math.PI*2,\n      //                        endAngle: Math.PI*2,\n      //                    };\n      //                }\n\n\n      if (isNaN(this._current.startAngle)) {\n        this._current.startAngle = 0;\n      }\n\n      if (isNaN(this._current.endAngle)) {\n        this._current.endAngle = this._current.startAngle;\n      }\n\n      interpolate = d3.interpolate(this._current, updated);\n      this._current = interpolate(0);\n      return function (t) {\n        var interpolated = interpolate(t);\n        interpolated.data = d.data; // data.id will be updated by interporator\n\n        return $$.getArc(interpolated, true);\n      };\n    }).attr(\"transform\", withTransform ? \"scale(1)\" : \"\").style(\"fill\", function (d) {\n      return $$.levelColor ? $$.levelColor(d.data.values[0].value) : $$.color(d.data.id);\n    }) // Where gauge reading color would receive customization.\n    .call($$.endall, function () {\n      $$.transiting = false;\n    });\n    mainArc.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n    main.selectAll('.' + CLASS.chartArc).select('text').style(\"opacity\", 0).attr('class', function (d) {\n      return $$.isGaugeType(d.data) ? CLASS.gaugeValue : '';\n    }).text($$.textForArcLabel.bind($$)).attr(\"transform\", $$.transformForArcLabel.bind($$)).style('font-size', function (d) {\n      return $$.isGaugeType(d.data) && $$.filterTargetsToShow($$.data.targets).length === 1 ? Math.round($$.radius / 5) + 'px' : '';\n    }).transition().duration(duration).style(\"opacity\", function (d) {\n      return $$.isTargetToShow(d.data.id) && $$.isArcType(d.data) ? 1 : 0;\n    });\n    main.select('.' + CLASS.chartArcsTitle).style(\"opacity\", $$.hasType('donut') || hasGaugeType ? 1 : 0);\n\n    if (hasGaugeType) {\n      var index = 0;\n      backgroundArc = $$.arcs.select('g.' + CLASS.chartArcsBackground).selectAll('path.' + CLASS.chartArcsBackground).data($$.data.targets);\n      backgroundArc.enter().append(\"path\");\n      backgroundArc.attr(\"class\", function (d, i) {\n        return CLASS.chartArcsBackground + ' ' + CLASS.chartArcsBackground + '-' + i;\n      }).attr(\"d\", function (d1) {\n        if ($$.hiddenTargetIds.indexOf(d1.id) >= 0) {\n          return \"M 0 0\";\n        }\n\n        var d = {\n          data: [{\n            value: config.gauge_max\n          }],\n          startAngle: config.gauge_startingAngle,\n          endAngle: -1 * config.gauge_startingAngle * (config.gauge_fullCircle ? Math.PI : 1),\n          index: index++\n        };\n        return $$.getArc(d, true, true);\n      });\n      backgroundArc.exit().remove();\n      $$.arcs.select('.' + CLASS.chartArcsGaugeUnit).attr(\"dy\", \".75em\").text(config.gauge_label_show ? config.gauge_units : '');\n      $$.arcs.select('.' + CLASS.chartArcsGaugeMin).attr(\"dx\", -1 * ($$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2)) + \"px\").attr(\"dy\", \"1.2em\").text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_min, false) : '');\n      $$.arcs.select('.' + CLASS.chartArcsGaugeMax).attr(\"dx\", $$.innerRadius + ($$.radius - $$.innerRadius) / (config.gauge_fullCircle ? 1 : 2) + \"px\").attr(\"dy\", \"1.2em\").text(config.gauge_label_show ? $$.textForGaugeMinMax(config.gauge_max, true) : '');\n    }\n  };\n\n  c3_chart_internal_fn.initGauge = function () {\n    var arcs = this.arcs;\n\n    if (this.hasType('gauge')) {\n      arcs.append('g').attr(\"class\", CLASS.chartArcsBackground);\n      arcs.append(\"text\").attr(\"class\", CLASS.chartArcsGaugeUnit).style(\"text-anchor\", \"middle\").style(\"pointer-events\", \"none\");\n      arcs.append(\"text\").attr(\"class\", CLASS.chartArcsGaugeMin).style(\"text-anchor\", \"middle\").style(\"pointer-events\", \"none\");\n      arcs.append(\"text\").attr(\"class\", CLASS.chartArcsGaugeMax).style(\"text-anchor\", \"middle\").style(\"pointer-events\", \"none\");\n    }\n  };\n\n  c3_chart_internal_fn.getGaugeLabelHeight = function () {\n    return this.config.gauge_label_show ? 20 : 0;\n  };\n\n  c3_chart_internal_fn.hasCaches = function (ids) {\n    for (var i = 0; i < ids.length; i++) {\n      if (!(ids[i] in this.cache)) {\n        return false;\n      }\n    }\n\n    return true;\n  };\n\n  c3_chart_internal_fn.addCache = function (id, target) {\n    this.cache[id] = this.cloneTarget(target);\n  };\n\n  c3_chart_internal_fn.getCaches = function (ids) {\n    var targets = [],\n        i;\n\n    for (i = 0; i < ids.length; i++) {\n      if (ids[i] in this.cache) {\n        targets.push(this.cloneTarget(this.cache[ids[i]]));\n      }\n    }\n\n    return targets;\n  };\n\n  c3_chart_internal_fn.categoryName = function (i) {\n    var config = this.config;\n    return i < config.axis_x_categories.length ? config.axis_x_categories[i] : i;\n  };\n\n  c3_chart_internal_fn.generateClass = function (prefix, targetId) {\n    return \" \" + prefix + \" \" + prefix + this.getTargetSelectorSuffix(targetId);\n  };\n\n  c3_chart_internal_fn.classText = function (d) {\n    return this.generateClass(CLASS.text, d.index);\n  };\n\n  c3_chart_internal_fn.classTexts = function (d) {\n    return this.generateClass(CLASS.texts, d.id);\n  };\n\n  c3_chart_internal_fn.classShape = function (d) {\n    return this.generateClass(CLASS.shape, d.index);\n  };\n\n  c3_chart_internal_fn.classShapes = function (d) {\n    return this.generateClass(CLASS.shapes, d.id);\n  };\n\n  c3_chart_internal_fn.classLine = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.line, d.id);\n  };\n\n  c3_chart_internal_fn.classLines = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.lines, d.id);\n  };\n\n  c3_chart_internal_fn.classCircle = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.circle, d.index);\n  };\n\n  c3_chart_internal_fn.classCircles = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.circles, d.id);\n  };\n\n  c3_chart_internal_fn.classBar = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.bar, d.index);\n  };\n\n  c3_chart_internal_fn.classBars = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.bars, d.id);\n  };\n\n  c3_chart_internal_fn.classArc = function (d) {\n    return this.classShape(d.data) + this.generateClass(CLASS.arc, d.data.id);\n  };\n\n  c3_chart_internal_fn.classArcs = function (d) {\n    return this.classShapes(d.data) + this.generateClass(CLASS.arcs, d.data.id);\n  };\n\n  c3_chart_internal_fn.classArea = function (d) {\n    return this.classShape(d) + this.generateClass(CLASS.area, d.id);\n  };\n\n  c3_chart_internal_fn.classAreas = function (d) {\n    return this.classShapes(d) + this.generateClass(CLASS.areas, d.id);\n  };\n\n  c3_chart_internal_fn.classRegion = function (d, i) {\n    return this.generateClass(CLASS.region, i) + ' ' + ('class' in d ? d['class'] : '');\n  };\n\n  c3_chart_internal_fn.classEvent = function (d) {\n    return this.generateClass(CLASS.eventRect, d.index);\n  };\n\n  c3_chart_internal_fn.classTarget = function (id) {\n    var $$ = this;\n    var additionalClassSuffix = $$.config.data_classes[id],\n        additionalClass = '';\n\n    if (additionalClassSuffix) {\n      additionalClass = ' ' + CLASS.target + '-' + additionalClassSuffix;\n    }\n\n    return $$.generateClass(CLASS.target, id) + additionalClass;\n  };\n\n  c3_chart_internal_fn.classFocus = function (d) {\n    return this.classFocused(d) + this.classDefocused(d);\n  };\n\n  c3_chart_internal_fn.classFocused = function (d) {\n    return ' ' + (this.focusedTargetIds.indexOf(d.id) >= 0 ? CLASS.focused : '');\n  };\n\n  c3_chart_internal_fn.classDefocused = function (d) {\n    return ' ' + (this.defocusedTargetIds.indexOf(d.id) >= 0 ? CLASS.defocused : '');\n  };\n\n  c3_chart_internal_fn.classChartText = function (d) {\n    return CLASS.chartText + this.classTarget(d.id);\n  };\n\n  c3_chart_internal_fn.classChartLine = function (d) {\n    return CLASS.chartLine + this.classTarget(d.id);\n  };\n\n  c3_chart_internal_fn.classChartBar = function (d) {\n    return CLASS.chartBar + this.classTarget(d.id);\n  };\n\n  c3_chart_internal_fn.classChartArc = function (d) {\n    return CLASS.chartArc + this.classTarget(d.data.id);\n  };\n\n  c3_chart_internal_fn.getTargetSelectorSuffix = function (targetId) {\n    return targetId || targetId === 0 ? ('-' + targetId).replace(/[\\s?!@#$%^&*()_=+,.<>'\":;\\[\\]\\/|~`{}\\\\]/g, '-') : '';\n  };\n\n  c3_chart_internal_fn.selectorTarget = function (id, prefix) {\n    return (prefix || '') + '.' + CLASS.target + this.getTargetSelectorSuffix(id);\n  };\n\n  c3_chart_internal_fn.selectorTargets = function (ids, prefix) {\n    var $$ = this;\n    ids = ids || [];\n    return ids.length ? ids.map(function (id) {\n      return $$.selectorTarget(id, prefix);\n    }) : null;\n  };\n\n  c3_chart_internal_fn.selectorLegend = function (id) {\n    return '.' + CLASS.legendItem + this.getTargetSelectorSuffix(id);\n  };\n\n  c3_chart_internal_fn.selectorLegends = function (ids) {\n    var $$ = this;\n    return ids && ids.length ? ids.map(function (id) {\n      return $$.selectorLegend(id);\n    }) : null;\n  };\n\n  c3_chart_internal_fn.getClipPath = function (id) {\n    var isIE9 = window.navigator.appVersion.toLowerCase().indexOf(\"msie 9.\") >= 0;\n    return \"url(\" + (isIE9 ? \"\" : document.URL.split('#')[0]) + \"#\" + id + \")\";\n  };\n\n  c3_chart_internal_fn.appendClip = function (parent, id) {\n    return parent.append(\"clipPath\").attr(\"id\", id).append(\"rect\");\n  };\n\n  c3_chart_internal_fn.getAxisClipX = function (forHorizontal) {\n    // axis line width + padding for left\n    var left = Math.max(30, this.margin.left);\n    return forHorizontal ? -(1 + left) : -(left - 1);\n  };\n\n  c3_chart_internal_fn.getAxisClipY = function (forHorizontal) {\n    return forHorizontal ? -20 : -this.margin.top;\n  };\n\n  c3_chart_internal_fn.getXAxisClipX = function () {\n    var $$ = this;\n    return $$.getAxisClipX(!$$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getXAxisClipY = function () {\n    var $$ = this;\n    return $$.getAxisClipY(!$$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getYAxisClipX = function () {\n    var $$ = this;\n    return $$.config.axis_y_inner ? -1 : $$.getAxisClipX($$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getYAxisClipY = function () {\n    var $$ = this;\n    return $$.getAxisClipY($$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getAxisClipWidth = function (forHorizontal) {\n    var $$ = this,\n        left = Math.max(30, $$.margin.left),\n        right = Math.max(30, $$.margin.right); // width + axis line width + padding for left/right\n\n    return forHorizontal ? $$.width + 2 + left + right : $$.margin.left + 20;\n  };\n\n  c3_chart_internal_fn.getAxisClipHeight = function (forHorizontal) {\n    // less than 20 is not enough to show the axis label 'outer' without legend\n    return (forHorizontal ? this.margin.bottom : this.margin.top + this.height) + 20;\n  };\n\n  c3_chart_internal_fn.getXAxisClipWidth = function () {\n    var $$ = this;\n    return $$.getAxisClipWidth(!$$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getXAxisClipHeight = function () {\n    var $$ = this;\n    return $$.getAxisClipHeight(!$$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.getYAxisClipWidth = function () {\n    var $$ = this;\n    return $$.getAxisClipWidth($$.config.axis_rotated) + ($$.config.axis_y_inner ? 20 : 0);\n  };\n\n  c3_chart_internal_fn.getYAxisClipHeight = function () {\n    var $$ = this;\n    return $$.getAxisClipHeight($$.config.axis_rotated);\n  };\n\n  c3_chart_internal_fn.generateColor = function () {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3,\n        colors = config.data_colors,\n        pattern = notEmpty(config.color_pattern) ? config.color_pattern : d3.scale.category10().range(),\n        callback = config.data_color,\n        ids = [];\n    return function (d) {\n      var id = d.id || d.data && d.data.id || d,\n          color; // if callback function is provided\n\n      if (colors[id] instanceof Function) {\n        color = colors[id](d);\n      } // if specified, choose that color\n      else if (colors[id]) {\n          color = colors[id];\n        } // if not specified, choose from pattern\n        else {\n            if (ids.indexOf(id) < 0) {\n              ids.push(id);\n            }\n\n            color = pattern[ids.indexOf(id) % pattern.length];\n            colors[id] = color;\n          }\n\n      return callback instanceof Function ? callback(color, d) : color;\n    };\n  };\n\n  c3_chart_internal_fn.generateLevelColor = function () {\n    var $$ = this,\n        config = $$.config,\n        colors = config.color_pattern,\n        threshold = config.color_threshold,\n        asValue = threshold.unit === 'value',\n        values = threshold.values && threshold.values.length ? threshold.values : [],\n        max = threshold.max || 100;\n    return notEmpty(config.color_threshold) ? function (value) {\n      var i,\n          v,\n          color = colors[colors.length - 1];\n\n      for (i = 0; i < values.length; i++) {\n        v = asValue ? value : value * 100 / max;\n\n        if (v < values[i]) {\n          color = colors[i];\n          break;\n        }\n      }\n\n      return color;\n    } : null;\n  };\n\n  c3_chart_internal_fn.getDefaultConfig = function () {\n    var config = {\n      bindto: '#chart',\n      svg_classname: undefined,\n      size_width: undefined,\n      size_height: undefined,\n      padding_left: undefined,\n      padding_right: undefined,\n      padding_top: undefined,\n      padding_bottom: undefined,\n      resize_auto: true,\n      zoom_enabled: false,\n      zoom_extent: undefined,\n      zoom_privileged: false,\n      zoom_rescale: false,\n      zoom_onzoom: function zoom_onzoom() {},\n      zoom_onzoomstart: function zoom_onzoomstart() {},\n      zoom_onzoomend: function zoom_onzoomend() {},\n      zoom_x_min: undefined,\n      zoom_x_max: undefined,\n      interaction_brighten: true,\n      interaction_enabled: true,\n      onmouseover: function onmouseover() {},\n      onmouseout: function onmouseout() {},\n      onresize: function onresize() {},\n      onresized: function onresized() {},\n      oninit: function oninit() {},\n      onrendered: function onrendered() {},\n      transition_duration: 350,\n      data_x: undefined,\n      data_xs: {},\n      data_xFormat: '%Y-%m-%d',\n      data_xLocaltime: true,\n      data_xSort: true,\n      data_idConverter: function data_idConverter(id) {\n        return id;\n      },\n      data_names: {},\n      data_classes: {},\n      data_groups: [],\n      data_axes: {},\n      data_type: undefined,\n      data_types: {},\n      data_labels: {},\n      data_order: 'desc',\n      data_regions: {},\n      data_color: undefined,\n      data_colors: {},\n      data_hide: false,\n      data_filter: undefined,\n      data_selection_enabled: false,\n      data_selection_grouped: false,\n      data_selection_isselectable: function data_selection_isselectable() {\n        return true;\n      },\n      data_selection_multiple: true,\n      data_selection_draggable: false,\n      data_onclick: function data_onclick() {},\n      data_onmouseover: function data_onmouseover() {},\n      data_onmouseout: function data_onmouseout() {},\n      data_onselected: function data_onselected() {},\n      data_onunselected: function data_onunselected() {},\n      data_url: undefined,\n      data_headers: undefined,\n      data_json: undefined,\n      data_rows: undefined,\n      data_columns: undefined,\n      data_mimeType: undefined,\n      data_keys: undefined,\n      // configuration for no plot-able data supplied.\n      data_empty_label_text: \"\",\n      // subchart\n      subchart_show: false,\n      subchart_size_height: 60,\n      subchart_axis_x_show: true,\n      subchart_onbrush: function subchart_onbrush() {},\n      // color\n      color_pattern: [],\n      color_threshold: {},\n      // legend\n      legend_show: true,\n      legend_hide: false,\n      legend_position: 'bottom',\n      legend_inset_anchor: 'top-left',\n      legend_inset_x: 10,\n      legend_inset_y: 0,\n      legend_inset_step: undefined,\n      legend_item_onclick: undefined,\n      legend_item_onmouseover: undefined,\n      legend_item_onmouseout: undefined,\n      legend_equally: false,\n      legend_padding: 0,\n      legend_item_tile_width: 10,\n      legend_item_tile_height: 10,\n      // axis\n      axis_rotated: false,\n      axis_x_show: true,\n      axis_x_type: 'indexed',\n      axis_x_localtime: true,\n      axis_x_categories: [],\n      axis_x_tick_centered: false,\n      axis_x_tick_format: undefined,\n      axis_x_tick_culling: {},\n      axis_x_tick_culling_max: 10,\n      axis_x_tick_count: undefined,\n      axis_x_tick_fit: true,\n      axis_x_tick_values: null,\n      axis_x_tick_rotate: 0,\n      axis_x_tick_outer: true,\n      axis_x_tick_multiline: true,\n      axis_x_tick_multilineMax: 0,\n      axis_x_tick_width: null,\n      axis_x_max: undefined,\n      axis_x_min: undefined,\n      axis_x_padding: {},\n      axis_x_height: undefined,\n      axis_x_extent: undefined,\n      axis_x_label: {},\n      axis_x_inner: undefined,\n      axis_y_show: true,\n      axis_y_type: undefined,\n      axis_y_max: undefined,\n      axis_y_min: undefined,\n      axis_y_inverted: false,\n      axis_y_center: undefined,\n      axis_y_inner: undefined,\n      axis_y_label: {},\n      axis_y_tick_format: undefined,\n      axis_y_tick_outer: true,\n      axis_y_tick_values: null,\n      axis_y_tick_rotate: 0,\n      axis_y_tick_count: undefined,\n      axis_y_tick_time_value: undefined,\n      axis_y_tick_time_interval: undefined,\n      axis_y_padding: {},\n      axis_y_default: undefined,\n      axis_y2_show: false,\n      axis_y2_max: undefined,\n      axis_y2_min: undefined,\n      axis_y2_inverted: false,\n      axis_y2_center: undefined,\n      axis_y2_inner: undefined,\n      axis_y2_label: {},\n      axis_y2_tick_format: undefined,\n      axis_y2_tick_outer: true,\n      axis_y2_tick_values: null,\n      axis_y2_tick_count: undefined,\n      axis_y2_padding: {},\n      axis_y2_default: undefined,\n      // grid\n      grid_x_show: false,\n      grid_x_type: 'tick',\n      grid_x_lines: [],\n      grid_y_show: false,\n      // not used\n      // grid_y_type: 'tick',\n      grid_y_lines: [],\n      grid_y_ticks: 10,\n      grid_focus_show: true,\n      grid_lines_front: true,\n      // point - point of each data\n      point_show: true,\n      point_r: 2.5,\n      point_sensitivity: 10,\n      point_focus_expand_enabled: true,\n      point_focus_expand_r: undefined,\n      point_select_r: undefined,\n      // line\n      line_connectNull: false,\n      line_step_type: 'step',\n      // bar\n      bar_width: undefined,\n      bar_width_ratio: 0.6,\n      bar_width_max: undefined,\n      bar_zerobased: true,\n      bar_space: 0,\n      // area\n      area_zerobased: true,\n      area_above: false,\n      // pie\n      pie_label_show: true,\n      pie_label_format: undefined,\n      pie_label_threshold: 0.05,\n      pie_label_ratio: undefined,\n      pie_expand: {},\n      pie_expand_duration: 50,\n      // gauge\n      gauge_fullCircle: false,\n      gauge_label_show: true,\n      gauge_labelLine_show: true,\n      gauge_label_format: undefined,\n      gauge_min: 0,\n      gauge_max: 100,\n      gauge_startingAngle: -1 * Math.PI / 2,\n      gauge_label_extents: undefined,\n      gauge_units: undefined,\n      gauge_width: undefined,\n      gauge_arcs_minWidth: 5,\n      gauge_expand: {},\n      gauge_expand_duration: 50,\n      // donut\n      donut_label_show: true,\n      donut_label_format: undefined,\n      donut_label_threshold: 0.05,\n      donut_label_ratio: undefined,\n      donut_width: undefined,\n      donut_title: \"\",\n      donut_expand: {},\n      donut_expand_duration: 50,\n      // spline\n      spline_interpolation_type: 'cardinal',\n      // region - region to change style\n      regions: [],\n      // tooltip - show when mouseover on each data\n      tooltip_show: true,\n      tooltip_grouped: true,\n      tooltip_order: undefined,\n      tooltip_format_title: undefined,\n      tooltip_format_name: undefined,\n      tooltip_format_value: undefined,\n      tooltip_position: undefined,\n      tooltip_contents: function tooltip_contents(d, defaultTitleFormat, defaultValueFormat, color) {\n        return this.getTooltipContent ? this.getTooltipContent(d, defaultTitleFormat, defaultValueFormat, color) : '';\n      },\n      tooltip_init_show: false,\n      tooltip_init_x: 0,\n      tooltip_init_position: {\n        top: '0px',\n        left: '50px'\n      },\n      tooltip_onshow: function tooltip_onshow() {},\n      tooltip_onhide: function tooltip_onhide() {},\n      // title\n      title_text: undefined,\n      title_padding: {\n        top: 0,\n        right: 0,\n        bottom: 0,\n        left: 0\n      },\n      title_position: 'top-center'\n    };\n    Object.keys(this.additionalConfig).forEach(function (key) {\n      config[key] = this.additionalConfig[key];\n    }, this);\n    return config;\n  };\n\n  c3_chart_internal_fn.additionalConfig = {};\n\n  c3_chart_internal_fn.loadConfig = function (config) {\n    var this_config = this.config,\n        target,\n        keys,\n        read;\n\n    function find() {\n      var key = keys.shift(); //        console.log(\"key =>\", key, \", target =>\", target);\n\n      if (key && target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && key in target) {\n        target = target[key];\n        return find();\n      } else if (!key) {\n        return target;\n      } else {\n        return undefined;\n      }\n    }\n\n    Object.keys(this_config).forEach(function (key) {\n      target = config;\n      keys = key.split('_');\n      read = find(); //        console.log(\"CONFIG : \", key, read);\n\n      if (isDefined(read)) {\n        this_config[key] = read;\n      }\n    });\n  };\n\n  c3_chart_internal_fn.convertUrlToData = function (url, mimeType, headers, keys, done) {\n    var $$ = this,\n        type = mimeType ? mimeType : 'csv';\n    var req = $$.d3.xhr(url);\n\n    if (headers) {\n      Object.keys(headers).forEach(function (header) {\n        req.header(header, headers[header]);\n      });\n    }\n\n    req.get(function (error, data) {\n      var d;\n      var dataResponse = data.response || data.responseText; // Fixes IE9 XHR issue; see #1345\n\n      if (!data) {\n        throw new Error(error.responseURL + ' ' + error.status + ' (' + error.statusText + ')');\n      }\n\n      if (type === 'json') {\n        d = $$.convertJsonToData(JSON.parse(dataResponse), keys);\n      } else if (type === 'tsv') {\n        d = $$.convertTsvToData(dataResponse);\n      } else {\n        d = $$.convertCsvToData(dataResponse);\n      }\n\n      done.call($$, d);\n    });\n  };\n\n  c3_chart_internal_fn.convertXsvToData = function (xsv, parser) {\n    var rows = parser.parseRows(xsv),\n        d;\n\n    if (rows.length === 1) {\n      d = [{}];\n      rows[0].forEach(function (id) {\n        d[0][id] = null;\n      });\n    } else {\n      d = parser.parse(xsv);\n    }\n\n    return d;\n  };\n\n  c3_chart_internal_fn.convertCsvToData = function (csv) {\n    return this.convertXsvToData(csv, this.d3.csv);\n  };\n\n  c3_chart_internal_fn.convertTsvToData = function (tsv) {\n    return this.convertXsvToData(tsv, this.d3.tsv);\n  };\n\n  c3_chart_internal_fn.convertJsonToData = function (json, keys) {\n    var $$ = this,\n        new_rows = [],\n        targetKeys,\n        data;\n\n    if (keys) {\n      // when keys specified, json would be an array that includes objects\n      if (keys.x) {\n        targetKeys = keys.value.concat(keys.x);\n        $$.config.data_x = keys.x;\n      } else {\n        targetKeys = keys.value;\n      }\n\n      new_rows.push(targetKeys);\n      json.forEach(function (o) {\n        var new_row = [];\n        targetKeys.forEach(function (key) {\n          // convert undefined to null because undefined data will be removed in convertDataToTargets()\n          var v = $$.findValueInJson(o, key);\n\n          if (isUndefined(v)) {\n            v = null;\n          }\n\n          new_row.push(v);\n        });\n        new_rows.push(new_row);\n      });\n      data = $$.convertRowsToData(new_rows);\n    } else {\n      Object.keys(json).forEach(function (key) {\n        new_rows.push([key].concat(json[key]));\n      });\n      data = $$.convertColumnsToData(new_rows);\n    }\n\n    return data;\n  };\n\n  c3_chart_internal_fn.findValueInJson = function (object, path) {\n    path = path.replace(/\\[(\\w+)\\]/g, '.$1'); // convert indexes to properties (replace [] with .)\n\n    path = path.replace(/^\\./, ''); // strip a leading dot\n\n    var pathArray = path.split('.');\n\n    for (var i = 0; i < pathArray.length; ++i) {\n      var k = pathArray[i];\n\n      if (k in object) {\n        object = object[k];\n      } else {\n        return;\n      }\n    }\n\n    return object;\n  };\n  /**\n   * Converts the rows to normalized data.\n   * @param {any[][]} rows The row data\n   * @return {Object[]}\n   */\n\n\n  c3_chart_internal_fn.convertRowsToData = function (rows) {\n    var newRows = [];\n    var keys = rows[0];\n\n    for (var i = 1; i < rows.length; i++) {\n      var newRow = {};\n\n      for (var j = 0; j < rows[i].length; j++) {\n        if (isUndefined(rows[i][j])) {\n          throw new Error(\"Source data is missing a component at (\" + i + \",\" + j + \")!\");\n        }\n\n        newRow[keys[j]] = rows[i][j];\n      }\n\n      newRows.push(newRow);\n    }\n\n    return newRows;\n  };\n  /**\n   * Converts the columns to normalized data.\n   * @param {any[][]} columns The column data\n   * @return {Object[]}\n   */\n\n\n  c3_chart_internal_fn.convertColumnsToData = function (columns) {\n    var newRows = [];\n\n    for (var i = 0; i < columns.length; i++) {\n      var key = columns[i][0];\n\n      for (var j = 1; j < columns[i].length; j++) {\n        if (isUndefined(newRows[j - 1])) {\n          newRows[j - 1] = {};\n        }\n\n        if (isUndefined(columns[i][j])) {\n          throw new Error(\"Source data is missing a component at (\" + i + \",\" + j + \")!\");\n        }\n\n        newRows[j - 1][key] = columns[i][j];\n      }\n    }\n\n    return newRows;\n  };\n\n  c3_chart_internal_fn.convertDataToTargets = function (data, appendXs) {\n    var $$ = this,\n        config = $$.config,\n        ids = $$.d3.keys(data[0]).filter($$.isNotX, $$),\n        xs = $$.d3.keys(data[0]).filter($$.isX, $$),\n        targets; // save x for update data by load when custom x and c3.x API\n\n    ids.forEach(function (id) {\n      var xKey = $$.getXKey(id);\n\n      if ($$.isCustomX() || $$.isTimeSeries()) {\n        // if included in input data\n        if (xs.indexOf(xKey) >= 0) {\n          $$.data.xs[id] = (appendXs && $$.data.xs[id] ? $$.data.xs[id] : []).concat(data.map(function (d) {\n            return d[xKey];\n          }).filter(isValue).map(function (rawX, i) {\n            return $$.generateTargetX(rawX, id, i);\n          }));\n        } // if not included in input data, find from preloaded data of other id's x\n        else if (config.data_x) {\n            $$.data.xs[id] = $$.getOtherTargetXs();\n          } // if not included in input data, find from preloaded data\n          else if (notEmpty(config.data_xs)) {\n              $$.data.xs[id] = $$.getXValuesOfXKey(xKey, $$.data.targets);\n            } // MEMO: if no x included, use same x of current will be used\n\n      } else {\n        $$.data.xs[id] = data.map(function (d, i) {\n          return i;\n        });\n      }\n    }); // check x is defined\n\n    ids.forEach(function (id) {\n      if (!$$.data.xs[id]) {\n        throw new Error('x is not defined for id = \"' + id + '\".');\n      }\n    }); // convert to target\n\n    targets = ids.map(function (id, index) {\n      var convertedId = config.data_idConverter(id);\n      return {\n        id: convertedId,\n        id_org: id,\n        values: data.map(function (d, i) {\n          var xKey = $$.getXKey(id),\n              rawX = d[xKey],\n              value = d[id] !== null && !isNaN(d[id]) ? +d[id] : null,\n              x; // use x as categories if custom x and categorized\n\n          if ($$.isCustomX() && $$.isCategorized() && !isUndefined(rawX)) {\n            if (index === 0 && i === 0) {\n              config.axis_x_categories = [];\n            }\n\n            x = config.axis_x_categories.indexOf(rawX);\n\n            if (x === -1) {\n              x = config.axis_x_categories.length;\n              config.axis_x_categories.push(rawX);\n            }\n          } else {\n            x = $$.generateTargetX(rawX, id, i);\n          } // mark as x = undefined if value is undefined and filter to remove after mapped\n\n\n          if (isUndefined(d[id]) || $$.data.xs[id].length <= i) {\n            x = undefined;\n          }\n\n          return {\n            x: x,\n            value: value,\n            id: convertedId\n          };\n        }).filter(function (v) {\n          return isDefined(v.x);\n        })\n      };\n    }); // finish targets\n\n    targets.forEach(function (t) {\n      var i; // sort values by its x\n\n      if (config.data_xSort) {\n        t.values = t.values.sort(function (v1, v2) {\n          var x1 = v1.x || v1.x === 0 ? v1.x : Infinity,\n              x2 = v2.x || v2.x === 0 ? v2.x : Infinity;\n          return x1 - x2;\n        });\n      } // indexing each value\n\n\n      i = 0;\n      t.values.forEach(function (v) {\n        v.index = i++;\n      }); // this needs to be sorted because its index and value.index is identical\n\n      $$.data.xs[t.id].sort(function (v1, v2) {\n        return v1 - v2;\n      });\n    }); // cache information about values\n\n    $$.hasNegativeValue = $$.hasNegativeValueInTargets(targets);\n    $$.hasPositiveValue = $$.hasPositiveValueInTargets(targets); // set target types\n\n    if (config.data_type) {\n      $$.setTargetType($$.mapToIds(targets).filter(function (id) {\n        return !(id in config.data_types);\n      }), config.data_type);\n    } // cache as original id keyed\n\n\n    targets.forEach(function (d) {\n      $$.addCache(d.id_org, d);\n    });\n    return targets;\n  };\n\n  c3_chart_internal_fn.isX = function (key) {\n    var $$ = this,\n        config = $$.config;\n    return config.data_x && key === config.data_x || notEmpty(config.data_xs) && hasValue(config.data_xs, key);\n  };\n\n  c3_chart_internal_fn.isNotX = function (key) {\n    return !this.isX(key);\n  };\n\n  c3_chart_internal_fn.getXKey = function (id) {\n    var $$ = this,\n        config = $$.config;\n    return config.data_x ? config.data_x : notEmpty(config.data_xs) ? config.data_xs[id] : null;\n  };\n\n  c3_chart_internal_fn.getXValuesOfXKey = function (key, targets) {\n    var $$ = this,\n        xValues,\n        ids = targets && notEmpty(targets) ? $$.mapToIds(targets) : [];\n    ids.forEach(function (id) {\n      if ($$.getXKey(id) === key) {\n        xValues = $$.data.xs[id];\n      }\n    });\n    return xValues;\n  };\n\n  c3_chart_internal_fn.getIndexByX = function (x) {\n    var $$ = this,\n        data = $$.filterByX($$.data.targets, x);\n    return data.length ? data[0].index : null;\n  };\n\n  c3_chart_internal_fn.getXValue = function (id, i) {\n    var $$ = this;\n    return id in $$.data.xs && $$.data.xs[id] && isValue($$.data.xs[id][i]) ? $$.data.xs[id][i] : i;\n  };\n\n  c3_chart_internal_fn.getOtherTargetXs = function () {\n    var $$ = this,\n        idsForX = Object.keys($$.data.xs);\n    return idsForX.length ? $$.data.xs[idsForX[0]] : null;\n  };\n\n  c3_chart_internal_fn.getOtherTargetX = function (index) {\n    var xs = this.getOtherTargetXs();\n    return xs && index < xs.length ? xs[index] : null;\n  };\n\n  c3_chart_internal_fn.addXs = function (xs) {\n    var $$ = this;\n    Object.keys(xs).forEach(function (id) {\n      $$.config.data_xs[id] = xs[id];\n    });\n  };\n\n  c3_chart_internal_fn.hasMultipleX = function (xs) {\n    return this.d3.set(Object.keys(xs).map(function (id) {\n      return xs[id];\n    })).size() > 1;\n  };\n\n  c3_chart_internal_fn.isMultipleX = function () {\n    return notEmpty(this.config.data_xs) || !this.config.data_xSort || this.hasType('scatter');\n  };\n\n  c3_chart_internal_fn.addName = function (data) {\n    var $$ = this,\n        name;\n\n    if (data) {\n      name = $$.config.data_names[data.id];\n      data.name = name !== undefined ? name : data.id;\n    }\n\n    return data;\n  };\n\n  c3_chart_internal_fn.getValueOnIndex = function (values, index) {\n    var valueOnIndex = values.filter(function (v) {\n      return v.index === index;\n    });\n    return valueOnIndex.length ? valueOnIndex[0] : null;\n  };\n\n  c3_chart_internal_fn.updateTargetX = function (targets, x) {\n    var $$ = this;\n    targets.forEach(function (t) {\n      t.values.forEach(function (v, i) {\n        v.x = $$.generateTargetX(x[i], t.id, i);\n      });\n      $$.data.xs[t.id] = x;\n    });\n  };\n\n  c3_chart_internal_fn.updateTargetXs = function (targets, xs) {\n    var $$ = this;\n    targets.forEach(function (t) {\n      if (xs[t.id]) {\n        $$.updateTargetX([t], xs[t.id]);\n      }\n    });\n  };\n\n  c3_chart_internal_fn.generateTargetX = function (rawX, id, index) {\n    var $$ = this,\n        x;\n\n    if ($$.isTimeSeries()) {\n      x = rawX ? $$.parseDate(rawX) : $$.parseDate($$.getXValue(id, index));\n    } else if ($$.isCustomX() && !$$.isCategorized()) {\n      x = isValue(rawX) ? +rawX : $$.getXValue(id, index);\n    } else {\n      x = index;\n    }\n\n    return x;\n  };\n\n  c3_chart_internal_fn.cloneTarget = function (target) {\n    return {\n      id: target.id,\n      id_org: target.id_org,\n      values: target.values.map(function (d) {\n        return {\n          x: d.x,\n          value: d.value,\n          id: d.id\n        };\n      })\n    };\n  };\n\n  c3_chart_internal_fn.updateXs = function () {\n    var $$ = this;\n\n    if ($$.data.targets.length) {\n      $$.xs = [];\n      $$.data.targets[0].values.forEach(function (v) {\n        $$.xs[v.index] = v.x;\n      });\n    }\n  };\n\n  c3_chart_internal_fn.getPrevX = function (i) {\n    var x = this.xs[i - 1];\n    return typeof x !== 'undefined' ? x : null;\n  };\n\n  c3_chart_internal_fn.getNextX = function (i) {\n    var x = this.xs[i + 1];\n    return typeof x !== 'undefined' ? x : null;\n  };\n\n  c3_chart_internal_fn.getMaxDataCount = function () {\n    var $$ = this;\n    return $$.d3.max($$.data.targets, function (t) {\n      return t.values.length;\n    });\n  };\n\n  c3_chart_internal_fn.getMaxDataCountTarget = function (targets) {\n    var length = targets.length,\n        max = 0,\n        maxTarget;\n\n    if (length > 1) {\n      targets.forEach(function (t) {\n        if (t.values.length > max) {\n          maxTarget = t;\n          max = t.values.length;\n        }\n      });\n    } else {\n      maxTarget = length ? targets[0] : null;\n    }\n\n    return maxTarget;\n  };\n\n  c3_chart_internal_fn.getEdgeX = function (targets) {\n    var $$ = this;\n    return !targets.length ? [0, 0] : [$$.d3.min(targets, function (t) {\n      return t.values[0].x;\n    }), $$.d3.max(targets, function (t) {\n      return t.values[t.values.length - 1].x;\n    })];\n  };\n\n  c3_chart_internal_fn.mapToIds = function (targets) {\n    return targets.map(function (d) {\n      return d.id;\n    });\n  };\n\n  c3_chart_internal_fn.mapToTargetIds = function (ids) {\n    var $$ = this;\n    return ids ? [].concat(ids) : $$.mapToIds($$.data.targets);\n  };\n\n  c3_chart_internal_fn.hasTarget = function (targets, id) {\n    var ids = this.mapToIds(targets),\n        i;\n\n    for (i = 0; i < ids.length; i++) {\n      if (ids[i] === id) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n\n  c3_chart_internal_fn.isTargetToShow = function (targetId) {\n    return this.hiddenTargetIds.indexOf(targetId) < 0;\n  };\n\n  c3_chart_internal_fn.isLegendToShow = function (targetId) {\n    return this.hiddenLegendIds.indexOf(targetId) < 0;\n  };\n\n  c3_chart_internal_fn.filterTargetsToShow = function (targets) {\n    var $$ = this;\n    return targets.filter(function (t) {\n      return $$.isTargetToShow(t.id);\n    });\n  };\n\n  c3_chart_internal_fn.mapTargetsToUniqueXs = function (targets) {\n    var $$ = this;\n    var xs = $$.d3.set($$.d3.merge(targets.map(function (t) {\n      return t.values.map(function (v) {\n        return +v.x;\n      });\n    }))).values();\n    xs = $$.isTimeSeries() ? xs.map(function (x) {\n      return new Date(+x);\n    }) : xs.map(function (x) {\n      return +x;\n    });\n    return xs.sort(function (a, b) {\n      return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\n    });\n  };\n\n  c3_chart_internal_fn.addHiddenTargetIds = function (targetIds) {\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);\n\n    for (var i = 0; i < targetIds.length; i++) {\n      if (this.hiddenTargetIds.indexOf(targetIds[i]) < 0) {\n        this.hiddenTargetIds = this.hiddenTargetIds.concat(targetIds[i]);\n      }\n    }\n  };\n\n  c3_chart_internal_fn.removeHiddenTargetIds = function (targetIds) {\n    this.hiddenTargetIds = this.hiddenTargetIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0;\n    });\n  };\n\n  c3_chart_internal_fn.addHiddenLegendIds = function (targetIds) {\n    targetIds = targetIds instanceof Array ? targetIds : new Array(targetIds);\n\n    for (var i = 0; i < targetIds.length; i++) {\n      if (this.hiddenLegendIds.indexOf(targetIds[i]) < 0) {\n        this.hiddenLegendIds = this.hiddenLegendIds.concat(targetIds[i]);\n      }\n    }\n  };\n\n  c3_chart_internal_fn.removeHiddenLegendIds = function (targetIds) {\n    this.hiddenLegendIds = this.hiddenLegendIds.filter(function (id) {\n      return targetIds.indexOf(id) < 0;\n    });\n  };\n\n  c3_chart_internal_fn.getValuesAsIdKeyed = function (targets) {\n    var ys = {};\n    targets.forEach(function (t) {\n      ys[t.id] = [];\n      t.values.forEach(function (v) {\n        ys[t.id].push(v.value);\n      });\n    });\n    return ys;\n  };\n\n  c3_chart_internal_fn.checkValueInTargets = function (targets, checker) {\n    var ids = Object.keys(targets),\n        i,\n        j,\n        values;\n\n    for (i = 0; i < ids.length; i++) {\n      values = targets[ids[i]].values;\n\n      for (j = 0; j < values.length; j++) {\n        if (checker(values[j].value)) {\n          return true;\n        }\n      }\n    }\n\n    return false;\n  };\n\n  c3_chart_internal_fn.hasNegativeValueInTargets = function (targets) {\n    return this.checkValueInTargets(targets, function (v) {\n      return v < 0;\n    });\n  };\n\n  c3_chart_internal_fn.hasPositiveValueInTargets = function (targets) {\n    return this.checkValueInTargets(targets, function (v) {\n      return v > 0;\n    });\n  };\n\n  c3_chart_internal_fn.isOrderDesc = function () {\n    var config = this.config;\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'desc';\n  };\n\n  c3_chart_internal_fn.isOrderAsc = function () {\n    var config = this.config;\n    return typeof config.data_order === 'string' && config.data_order.toLowerCase() === 'asc';\n  };\n\n  c3_chart_internal_fn.getOrderFunction = function () {\n    var $$ = this,\n        config = $$.config,\n        orderAsc = $$.isOrderAsc(),\n        orderDesc = $$.isOrderDesc();\n\n    if (orderAsc || orderDesc) {\n      return function (t1, t2) {\n        var reducer = function reducer(p, c) {\n          return p + Math.abs(c.value);\n        };\n\n        var t1Sum = t1.values.reduce(reducer, 0),\n            t2Sum = t2.values.reduce(reducer, 0);\n        return orderDesc ? t2Sum - t1Sum : t1Sum - t2Sum;\n      };\n    } else if (isFunction(config.data_order)) {\n      return config.data_order;\n    } else if (isArray(config.data_order)) {\n      var order = config.data_order;\n      return function (t1, t2) {\n        return order.indexOf(t1.id) - order.indexOf(t2.id);\n      };\n    }\n  };\n\n  c3_chart_internal_fn.orderTargets = function (targets) {\n    var fct = this.getOrderFunction();\n\n    if (fct) {\n      targets.sort(fct);\n\n      if (this.isOrderAsc() || this.isOrderDesc()) {\n        targets.reverse();\n      }\n    }\n\n    return targets;\n  };\n\n  c3_chart_internal_fn.filterByX = function (targets, x) {\n    return this.d3.merge(targets.map(function (t) {\n      return t.values;\n    })).filter(function (v) {\n      return v.x - x === 0;\n    });\n  };\n\n  c3_chart_internal_fn.filterRemoveNull = function (data) {\n    return data.filter(function (d) {\n      return isValue(d.value);\n    });\n  };\n\n  c3_chart_internal_fn.filterByXDomain = function (targets, xDomain) {\n    return targets.map(function (t) {\n      return {\n        id: t.id,\n        id_org: t.id_org,\n        values: t.values.filter(function (v) {\n          return xDomain[0] <= v.x && v.x <= xDomain[1];\n        })\n      };\n    });\n  };\n\n  c3_chart_internal_fn.hasDataLabel = function () {\n    var config = this.config;\n\n    if (typeof config.data_labels === 'boolean' && config.data_labels) {\n      return true;\n    } else if (_typeof(config.data_labels) === 'object' && notEmpty(config.data_labels)) {\n      return true;\n    }\n\n    return false;\n  };\n\n  c3_chart_internal_fn.getDataLabelLength = function (min, max, key) {\n    var $$ = this,\n        lengths = [0, 0],\n        paddingCoef = 1.3;\n    $$.selectChart.select('svg').selectAll('.dummy').data([min, max]).enter().append('text').text(function (d) {\n      return $$.dataLabelFormat(d.id)(d);\n    }).each(function (d, i) {\n      lengths[i] = this.getBoundingClientRect()[key] * paddingCoef;\n    }).remove();\n    return lengths;\n  };\n\n  c3_chart_internal_fn.isNoneArc = function (d) {\n    return this.hasTarget(this.data.targets, d.id);\n  }, c3_chart_internal_fn.isArc = function (d) {\n    return 'data' in d && this.hasTarget(this.data.targets, d.data.id);\n  };\n\n  c3_chart_internal_fn.findSameXOfValues = function (values, index) {\n    var i,\n        targetX = values[index].x,\n        sames = [];\n\n    for (i = index - 1; i >= 0; i--) {\n      if (targetX !== values[i].x) {\n        break;\n      }\n\n      sames.push(values[i]);\n    }\n\n    for (i = index; i < values.length; i++) {\n      if (targetX !== values[i].x) {\n        break;\n      }\n\n      sames.push(values[i]);\n    }\n\n    return sames;\n  };\n\n  c3_chart_internal_fn.findClosestFromTargets = function (targets, pos) {\n    var $$ = this,\n        candidates; // map to array of closest points of each target\n\n    candidates = targets.map(function (target) {\n      return $$.findClosest(target.values, pos);\n    }); // decide closest point and return\n\n    return $$.findClosest(candidates, pos);\n  };\n\n  c3_chart_internal_fn.findClosest = function (values, pos) {\n    var $$ = this,\n        minDist = $$.config.point_sensitivity,\n        closest; // find mouseovering bar\n\n    values.filter(function (v) {\n      return v && $$.isBarType(v.id);\n    }).forEach(function (v) {\n      var shape = $$.main.select('.' + CLASS.bars + $$.getTargetSelectorSuffix(v.id) + ' .' + CLASS.bar + '-' + v.index).node();\n\n      if (!closest && $$.isWithinBar(shape)) {\n        closest = v;\n      }\n    }); // find closest point from non-bar\n\n    values.filter(function (v) {\n      return v && !$$.isBarType(v.id);\n    }).forEach(function (v) {\n      var d = $$.dist(v, pos);\n\n      if (d < minDist) {\n        minDist = d;\n        closest = v;\n      }\n    });\n    return closest;\n  };\n\n  c3_chart_internal_fn.dist = function (data, pos) {\n    var $$ = this,\n        config = $$.config,\n        xIndex = config.axis_rotated ? 1 : 0,\n        yIndex = config.axis_rotated ? 0 : 1,\n        y = $$.circleY(data, data.index),\n        x = $$.x(data.x);\n    return Math.sqrt(Math.pow(x - pos[xIndex], 2) + Math.pow(y - pos[yIndex], 2));\n  };\n\n  c3_chart_internal_fn.convertValuesToStep = function (values) {\n    var converted = [].concat(values),\n        i;\n\n    if (!this.isCategorized()) {\n      return values;\n    }\n\n    for (i = values.length + 1; 0 < i; i--) {\n      converted[i] = converted[i - 1];\n    }\n\n    converted[0] = {\n      x: converted[0].x - 1,\n      value: converted[0].value,\n      id: converted[0].id\n    };\n    converted[values.length + 1] = {\n      x: converted[values.length].x + 1,\n      value: converted[values.length].value,\n      id: converted[values.length].id\n    };\n    return converted;\n  };\n\n  c3_chart_internal_fn.updateDataAttributes = function (name, attrs) {\n    var $$ = this,\n        config = $$.config,\n        current = config['data_' + name];\n\n    if (typeof attrs === 'undefined') {\n      return current;\n    }\n\n    Object.keys(attrs).forEach(function (id) {\n      current[id] = attrs[id];\n    });\n    $$.redraw({\n      withLegend: true\n    });\n    return current;\n  };\n\n  c3_chart_internal_fn.load = function (targets, args) {\n    var $$ = this;\n\n    if (targets) {\n      // filter loading targets if needed\n      if (args.filter) {\n        targets = targets.filter(args.filter);\n      } // set type if args.types || args.type specified\n\n\n      if (args.type || args.types) {\n        targets.forEach(function (t) {\n          var type = args.types && args.types[t.id] ? args.types[t.id] : args.type;\n          $$.setTargetType(t.id, type);\n        });\n      } // Update/Add data\n\n\n      $$.data.targets.forEach(function (d) {\n        for (var i = 0; i < targets.length; i++) {\n          if (d.id === targets[i].id) {\n            d.values = targets[i].values;\n            targets.splice(i, 1);\n            break;\n          }\n        }\n      });\n      $$.data.targets = $$.data.targets.concat(targets); // add remained\n    } // Set targets\n\n\n    $$.updateTargets($$.data.targets); // Redraw with new targets\n\n    $$.redraw({\n      withUpdateOrgXDomain: true,\n      withUpdateXDomain: true,\n      withLegend: true\n    });\n\n    if (args.done) {\n      args.done();\n    }\n  };\n\n  c3_chart_internal_fn.loadFromArgs = function (args) {\n    var $$ = this;\n\n    if (args.data) {\n      $$.load($$.convertDataToTargets(args.data), args);\n    } else if (args.url) {\n      $$.convertUrlToData(args.url, args.mimeType, args.headers, args.keys, function (data) {\n        $$.load($$.convertDataToTargets(data), args);\n      });\n    } else if (args.json) {\n      $$.load($$.convertDataToTargets($$.convertJsonToData(args.json, args.keys)), args);\n    } else if (args.rows) {\n      $$.load($$.convertDataToTargets($$.convertRowsToData(args.rows)), args);\n    } else if (args.columns) {\n      $$.load($$.convertDataToTargets($$.convertColumnsToData(args.columns)), args);\n    } else {\n      $$.load(null, args);\n    }\n  };\n\n  c3_chart_internal_fn.unload = function (targetIds, done) {\n    var $$ = this;\n\n    if (!done) {\n      done = function done() {};\n    } // filter existing target\n\n\n    targetIds = targetIds.filter(function (id) {\n      return $$.hasTarget($$.data.targets, id);\n    }); // If no target, call done and return\n\n    if (!targetIds || targetIds.length === 0) {\n      done();\n      return;\n    }\n\n    $$.svg.selectAll(targetIds.map(function (id) {\n      return $$.selectorTarget(id);\n    })).transition().style('opacity', 0).remove().call($$.endall, done);\n    targetIds.forEach(function (id) {\n      // Reset fadein for future load\n      $$.withoutFadeIn[id] = false; // Remove target's elements\n\n      if ($$.legend) {\n        $$.legend.selectAll('.' + CLASS.legendItem + $$.getTargetSelectorSuffix(id)).remove();\n      } // Remove target\n\n\n      $$.data.targets = $$.data.targets.filter(function (t) {\n        return t.id !== id;\n      });\n    });\n  };\n\n  c3_chart_internal_fn.getYDomainMin = function (targets) {\n    var $$ = this,\n        config = $$.config,\n        ids = $$.mapToIds(targets),\n        ys = $$.getValuesAsIdKeyed(targets),\n        j,\n        k,\n        baseId,\n        idsInGroup,\n        id,\n        hasNegativeValue;\n\n    if (config.data_groups.length > 0) {\n      hasNegativeValue = $$.hasNegativeValueInTargets(targets);\n\n      for (j = 0; j < config.data_groups.length; j++) {\n        // Determine baseId\n        idsInGroup = config.data_groups[j].filter(function (id) {\n          return ids.indexOf(id) >= 0;\n        });\n\n        if (idsInGroup.length === 0) {\n          continue;\n        }\n\n        baseId = idsInGroup[0]; // Consider negative values\n\n        if (hasNegativeValue && ys[baseId]) {\n          ys[baseId].forEach(function (v, i) {\n            ys[baseId][i] = v < 0 ? v : 0;\n          });\n        } // Compute min\n\n\n        for (k = 1; k < idsInGroup.length; k++) {\n          id = idsInGroup[k];\n\n          if (!ys[id]) {\n            continue;\n          }\n\n          ys[id].forEach(function (v, i) {\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasNegativeValue && +v > 0)) {\n              ys[baseId][i] += +v;\n            }\n          });\n        }\n      }\n    }\n\n    return $$.d3.min(Object.keys(ys).map(function (key) {\n      return $$.d3.min(ys[key]);\n    }));\n  };\n\n  c3_chart_internal_fn.getYDomainMax = function (targets) {\n    var $$ = this,\n        config = $$.config,\n        ids = $$.mapToIds(targets),\n        ys = $$.getValuesAsIdKeyed(targets),\n        j,\n        k,\n        baseId,\n        idsInGroup,\n        id,\n        hasPositiveValue;\n\n    if (config.data_groups.length > 0) {\n      hasPositiveValue = $$.hasPositiveValueInTargets(targets);\n\n      for (j = 0; j < config.data_groups.length; j++) {\n        // Determine baseId\n        idsInGroup = config.data_groups[j].filter(function (id) {\n          return ids.indexOf(id) >= 0;\n        });\n\n        if (idsInGroup.length === 0) {\n          continue;\n        }\n\n        baseId = idsInGroup[0]; // Consider positive values\n\n        if (hasPositiveValue && ys[baseId]) {\n          ys[baseId].forEach(function (v, i) {\n            ys[baseId][i] = v > 0 ? v : 0;\n          });\n        } // Compute max\n\n\n        for (k = 1; k < idsInGroup.length; k++) {\n          id = idsInGroup[k];\n\n          if (!ys[id]) {\n            continue;\n          }\n\n          ys[id].forEach(function (v, i) {\n            if ($$.axis.getId(id) === $$.axis.getId(baseId) && ys[baseId] && !(hasPositiveValue && +v < 0)) {\n              ys[baseId][i] += +v;\n            }\n          });\n        }\n      }\n    }\n\n    return $$.d3.max(Object.keys(ys).map(function (key) {\n      return $$.d3.max(ys[key]);\n    }));\n  };\n\n  c3_chart_internal_fn.getYDomain = function (targets, axisId, xDomain) {\n    var $$ = this,\n        config = $$.config,\n        targetsByAxisId = targets.filter(function (t) {\n      return $$.axis.getId(t.id) === axisId;\n    }),\n        yTargets = xDomain ? $$.filterByXDomain(targetsByAxisId, xDomain) : targetsByAxisId,\n        yMin = axisId === 'y2' ? config.axis_y2_min : config.axis_y_min,\n        yMax = axisId === 'y2' ? config.axis_y2_max : config.axis_y_max,\n        yDomainMin = $$.getYDomainMin(yTargets),\n        yDomainMax = $$.getYDomainMax(yTargets),\n        domain,\n        domainLength,\n        padding,\n        padding_top,\n        padding_bottom,\n        center = axisId === 'y2' ? config.axis_y2_center : config.axis_y_center,\n        yDomainAbs,\n        lengths,\n        diff,\n        ratio,\n        isAllPositive,\n        isAllNegative,\n        isZeroBased = $$.hasType('bar', yTargets) && config.bar_zerobased || $$.hasType('area', yTargets) && config.area_zerobased,\n        isInverted = axisId === 'y2' ? config.axis_y2_inverted : config.axis_y_inverted,\n        showHorizontalDataLabel = $$.hasDataLabel() && config.axis_rotated,\n        showVerticalDataLabel = $$.hasDataLabel() && !config.axis_rotated; // MEMO: avoid inverting domain unexpectedly\n\n    yDomainMin = isValue(yMin) ? yMin : isValue(yMax) ? yDomainMin < yMax ? yDomainMin : yMax - 10 : yDomainMin;\n    yDomainMax = isValue(yMax) ? yMax : isValue(yMin) ? yMin < yDomainMax ? yDomainMax : yMin + 10 : yDomainMax;\n\n    if (yTargets.length === 0) {\n      // use current domain if target of axisId is none\n      return axisId === 'y2' ? $$.y2.domain() : $$.y.domain();\n    }\n\n    if (isNaN(yDomainMin)) {\n      // set minimum to zero when not number\n      yDomainMin = 0;\n    }\n\n    if (isNaN(yDomainMax)) {\n      // set maximum to have same value as yDomainMin\n      yDomainMax = yDomainMin;\n    }\n\n    if (yDomainMin === yDomainMax) {\n      yDomainMin < 0 ? yDomainMax = 0 : yDomainMin = 0;\n    }\n\n    isAllPositive = yDomainMin >= 0 && yDomainMax >= 0;\n    isAllNegative = yDomainMin <= 0 && yDomainMax <= 0; // Cancel zerobased if axis_*_min / axis_*_max specified\n\n    if (isValue(yMin) && isAllPositive || isValue(yMax) && isAllNegative) {\n      isZeroBased = false;\n    } // Bar/Area chart should be 0-based if all positive|negative\n\n\n    if (isZeroBased) {\n      if (isAllPositive) {\n        yDomainMin = 0;\n      }\n\n      if (isAllNegative) {\n        yDomainMax = 0;\n      }\n    }\n\n    domainLength = Math.abs(yDomainMax - yDomainMin);\n    padding = padding_top = padding_bottom = domainLength * 0.1;\n\n    if (typeof center !== 'undefined') {\n      yDomainAbs = Math.max(Math.abs(yDomainMin), Math.abs(yDomainMax));\n      yDomainMax = center + yDomainAbs;\n      yDomainMin = center - yDomainAbs;\n    } // add padding for data label\n\n\n    if (showHorizontalDataLabel) {\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'width');\n      diff = diffDomain($$.y.range());\n      ratio = [lengths[0] / diff, lengths[1] / diff];\n      padding_top += domainLength * (ratio[1] / (1 - ratio[0] - ratio[1]));\n      padding_bottom += domainLength * (ratio[0] / (1 - ratio[0] - ratio[1]));\n    } else if (showVerticalDataLabel) {\n      lengths = $$.getDataLabelLength(yDomainMin, yDomainMax, 'height');\n      padding_top += $$.axis.convertPixelsToAxisPadding(lengths[1], domainLength);\n      padding_bottom += $$.axis.convertPixelsToAxisPadding(lengths[0], domainLength);\n    }\n\n    if (axisId === 'y' && notEmpty(config.axis_y_padding)) {\n      padding_top = $$.axis.getPadding(config.axis_y_padding, 'top', padding_top, domainLength);\n      padding_bottom = $$.axis.getPadding(config.axis_y_padding, 'bottom', padding_bottom, domainLength);\n    }\n\n    if (axisId === 'y2' && notEmpty(config.axis_y2_padding)) {\n      padding_top = $$.axis.getPadding(config.axis_y2_padding, 'top', padding_top, domainLength);\n      padding_bottom = $$.axis.getPadding(config.axis_y2_padding, 'bottom', padding_bottom, domainLength);\n    } // Bar/Area chart should be 0-based if all positive|negative\n\n\n    if (isZeroBased) {\n      if (isAllPositive) {\n        padding_bottom = yDomainMin;\n      }\n\n      if (isAllNegative) {\n        padding_top = -yDomainMax;\n      }\n    }\n\n    domain = [yDomainMin - padding_bottom, yDomainMax + padding_top];\n    return isInverted ? domain.reverse() : domain;\n  };\n\n  c3_chart_internal_fn.getXDomainMin = function (targets) {\n    var $$ = this,\n        config = $$.config;\n    return isDefined(config.axis_x_min) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_min) : config.axis_x_min : $$.d3.min(targets, function (t) {\n      return $$.d3.min(t.values, function (v) {\n        return v.x;\n      });\n    });\n  };\n\n  c3_chart_internal_fn.getXDomainMax = function (targets) {\n    var $$ = this,\n        config = $$.config;\n    return isDefined(config.axis_x_max) ? $$.isTimeSeries() ? this.parseDate(config.axis_x_max) : config.axis_x_max : $$.d3.max(targets, function (t) {\n      return $$.d3.max(t.values, function (v) {\n        return v.x;\n      });\n    });\n  };\n\n  c3_chart_internal_fn.getXDomainPadding = function (domain) {\n    var $$ = this,\n        config = $$.config,\n        diff = domain[1] - domain[0],\n        maxDataCount,\n        padding,\n        paddingLeft,\n        paddingRight;\n\n    if ($$.isCategorized()) {\n      padding = 0;\n    } else if ($$.hasType('bar')) {\n      maxDataCount = $$.getMaxDataCount();\n      padding = maxDataCount > 1 ? diff / (maxDataCount - 1) / 2 : 0.5;\n    } else {\n      padding = diff * 0.01;\n    }\n\n    if (_typeof(config.axis_x_padding) === 'object' && notEmpty(config.axis_x_padding)) {\n      paddingLeft = isValue(config.axis_x_padding.left) ? config.axis_x_padding.left : padding;\n      paddingRight = isValue(config.axis_x_padding.right) ? config.axis_x_padding.right : padding;\n    } else if (typeof config.axis_x_padding === 'number') {\n      paddingLeft = paddingRight = config.axis_x_padding;\n    } else {\n      paddingLeft = paddingRight = padding;\n    }\n\n    return {\n      left: paddingLeft,\n      right: paddingRight\n    };\n  };\n\n  c3_chart_internal_fn.getXDomain = function (targets) {\n    var $$ = this,\n        xDomain = [$$.getXDomainMin(targets), $$.getXDomainMax(targets)],\n        firstX = xDomain[0],\n        lastX = xDomain[1],\n        padding = $$.getXDomainPadding(xDomain),\n        min = 0,\n        max = 0; // show center of x domain if min and max are the same\n\n    if (firstX - lastX === 0 && !$$.isCategorized()) {\n      if ($$.isTimeSeries()) {\n        firstX = new Date(firstX.getTime() * 0.5);\n        lastX = new Date(lastX.getTime() * 1.5);\n      } else {\n        firstX = firstX === 0 ? 1 : firstX * 0.5;\n        lastX = lastX === 0 ? -1 : lastX * 1.5;\n      }\n    }\n\n    if (firstX || firstX === 0) {\n      min = $$.isTimeSeries() ? new Date(firstX.getTime() - padding.left) : firstX - padding.left;\n    }\n\n    if (lastX || lastX === 0) {\n      max = $$.isTimeSeries() ? new Date(lastX.getTime() + padding.right) : lastX + padding.right;\n    }\n\n    return [min, max];\n  };\n\n  c3_chart_internal_fn.updateXDomain = function (targets, withUpdateXDomain, withUpdateOrgXDomain, withTrim, domain) {\n    var $$ = this,\n        config = $$.config;\n\n    if (withUpdateOrgXDomain) {\n      $$.x.domain(domain ? domain : $$.d3.extent($$.getXDomain(targets)));\n      $$.orgXDomain = $$.x.domain();\n\n      if (config.zoom_enabled) {\n        $$.zoom.scale($$.x).updateScaleExtent();\n      }\n\n      $$.subX.domain($$.x.domain());\n\n      if ($$.brush) {\n        $$.brush.scale($$.subX);\n      }\n    }\n\n    if (withUpdateXDomain) {\n      $$.x.domain(domain ? domain : !$$.brush || $$.brush.empty() ? $$.orgXDomain : $$.brush.extent());\n\n      if (config.zoom_enabled) {\n        $$.zoom.scale($$.x).updateScaleExtent();\n      }\n    } // Trim domain when too big by zoom mousemove event\n\n\n    if (withTrim) {\n      $$.x.domain($$.trimXDomain($$.x.orgDomain()));\n    }\n\n    return $$.x.domain();\n  };\n\n  c3_chart_internal_fn.trimXDomain = function (domain) {\n    var zoomDomain = this.getZoomDomain(),\n        min = zoomDomain[0],\n        max = zoomDomain[1];\n\n    if (domain[0] <= min) {\n      domain[1] = +domain[1] + (min - domain[0]);\n      domain[0] = min;\n    }\n\n    if (max <= domain[1]) {\n      domain[0] = +domain[0] - (domain[1] - max);\n      domain[1] = max;\n    }\n\n    return domain;\n  };\n\n  c3_chart_internal_fn.drag = function (mouse) {\n    var $$ = this,\n        config = $$.config,\n        main = $$.main,\n        d3 = $$.d3;\n    var sx, sy, mx, my, minX, maxX, minY, maxY;\n\n    if ($$.hasArcType()) {\n      return;\n    }\n\n    if (!config.data_selection_enabled) {\n      return;\n    } // do nothing if not selectable\n\n\n    if (config.zoom_enabled && !$$.zoom.altDomain) {\n      return;\n    } // skip if zoomable because of conflict drag dehavior\n\n\n    if (!config.data_selection_multiple) {\n      return;\n    } // skip when single selection because drag is used for multiple selection\n\n\n    sx = $$.dragStart[0];\n    sy = $$.dragStart[1];\n    mx = mouse[0];\n    my = mouse[1];\n    minX = Math.min(sx, mx);\n    maxX = Math.max(sx, mx);\n    minY = config.data_selection_grouped ? $$.margin.top : Math.min(sy, my);\n    maxY = config.data_selection_grouped ? $$.height : Math.max(sy, my);\n    main.select('.' + CLASS.dragarea).attr('x', minX).attr('y', minY).attr('width', maxX - minX).attr('height', maxY - minY); // TODO: binary search when multiple xs\n\n    main.selectAll('.' + CLASS.shapes).selectAll('.' + CLASS.shape).filter(function (d) {\n      return config.data_selection_isselectable(d);\n    }).each(function (d, i) {\n      var shape = d3.select(this),\n          isSelected = shape.classed(CLASS.SELECTED),\n          isIncluded = shape.classed(CLASS.INCLUDED),\n          _x,\n          _y,\n          _w,\n          _h,\n          toggle,\n          isWithin = false,\n          box;\n\n      if (shape.classed(CLASS.circle)) {\n        _x = shape.attr(\"cx\") * 1;\n        _y = shape.attr(\"cy\") * 1;\n        toggle = $$.togglePoint;\n        isWithin = minX < _x && _x < maxX && minY < _y && _y < maxY;\n      } else if (shape.classed(CLASS.bar)) {\n        box = getPathBox(this);\n        _x = box.x;\n        _y = box.y;\n        _w = box.width;\n        _h = box.height;\n        toggle = $$.togglePath;\n        isWithin = !(maxX < _x || _x + _w < minX) && !(maxY < _y || _y + _h < minY);\n      } else {\n        // line/area selection not supported yet\n        return;\n      }\n\n      if (isWithin ^ isIncluded) {\n        shape.classed(CLASS.INCLUDED, !isIncluded); // TODO: included/unincluded callback here\n\n        shape.classed(CLASS.SELECTED, !isSelected);\n        toggle.call($$, !isSelected, shape, d, i);\n      }\n    });\n  };\n\n  c3_chart_internal_fn.dragstart = function (mouse) {\n    var $$ = this,\n        config = $$.config;\n\n    if ($$.hasArcType()) {\n      return;\n    }\n\n    if (!config.data_selection_enabled) {\n      return;\n    } // do nothing if not selectable\n\n\n    $$.dragStart = mouse;\n    $$.main.select('.' + CLASS.chart).append('rect').attr('class', CLASS.dragarea).style('opacity', 0.1);\n    $$.dragging = true;\n  };\n\n  c3_chart_internal_fn.dragend = function () {\n    var $$ = this,\n        config = $$.config;\n\n    if ($$.hasArcType()) {\n      return;\n    }\n\n    if (!config.data_selection_enabled) {\n      return;\n    } // do nothing if not selectable\n\n\n    $$.main.select('.' + CLASS.dragarea).transition().duration(100).style('opacity', 0).remove();\n    $$.main.selectAll('.' + CLASS.shape).classed(CLASS.INCLUDED, false);\n    $$.dragging = false;\n  };\n\n  c3_chart_internal_fn.getYFormat = function (forArc) {\n    var $$ = this,\n        formatForY = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.yFormat,\n        formatForY2 = forArc && !$$.hasType('gauge') ? $$.defaultArcValueFormat : $$.y2Format;\n    return function (v, ratio, id) {\n      var format = $$.axis.getId(id) === 'y2' ? formatForY2 : formatForY;\n      return format.call($$, v, ratio);\n    };\n  };\n\n  c3_chart_internal_fn.yFormat = function (v) {\n    var $$ = this,\n        config = $$.config,\n        format = config.axis_y_tick_format ? config.axis_y_tick_format : $$.defaultValueFormat;\n    return format(v);\n  };\n\n  c3_chart_internal_fn.y2Format = function (v) {\n    var $$ = this,\n        config = $$.config,\n        format = config.axis_y2_tick_format ? config.axis_y2_tick_format : $$.defaultValueFormat;\n    return format(v);\n  };\n\n  c3_chart_internal_fn.defaultValueFormat = function (v) {\n    return isValue(v) ? +v : \"\";\n  };\n\n  c3_chart_internal_fn.defaultArcValueFormat = function (v, ratio) {\n    return (ratio * 100).toFixed(1) + '%';\n  };\n\n  c3_chart_internal_fn.dataLabelFormat = function (targetId) {\n    var $$ = this,\n        data_labels = $$.config.data_labels,\n        format,\n        defaultFormat = function defaultFormat(v) {\n      return isValue(v) ? +v : \"\";\n    }; // find format according to axis id\n\n\n    if (typeof data_labels.format === 'function') {\n      format = data_labels.format;\n    } else if (_typeof(data_labels.format) === 'object') {\n      if (data_labels.format[targetId]) {\n        format = data_labels.format[targetId] === true ? defaultFormat : data_labels.format[targetId];\n      } else {\n        format = function format() {\n          return '';\n        };\n      }\n    } else {\n      format = defaultFormat;\n    }\n\n    return format;\n  };\n\n  c3_chart_internal_fn.initGrid = function () {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3;\n    $$.grid = $$.main.append('g').attr(\"clip-path\", $$.clipPathForGrid).attr('class', CLASS.grid);\n\n    if (config.grid_x_show) {\n      $$.grid.append(\"g\").attr(\"class\", CLASS.xgrids);\n    }\n\n    if (config.grid_y_show) {\n      $$.grid.append('g').attr('class', CLASS.ygrids);\n    }\n\n    if (config.grid_focus_show) {\n      $$.grid.append('g').attr(\"class\", CLASS.xgridFocus).append('line').attr('class', CLASS.xgridFocus);\n    }\n\n    $$.xgrid = d3.selectAll([]);\n\n    if (!config.grid_lines_front) {\n      $$.initGridLines();\n    }\n  };\n\n  c3_chart_internal_fn.initGridLines = function () {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.gridLines = $$.main.append('g').attr(\"clip-path\", $$.clipPathForGrid).attr('class', CLASS.grid + ' ' + CLASS.gridLines);\n    $$.gridLines.append('g').attr(\"class\", CLASS.xgridLines);\n    $$.gridLines.append('g').attr('class', CLASS.ygridLines);\n    $$.xgridLines = d3.selectAll([]);\n  };\n\n  c3_chart_internal_fn.updateXGrid = function (withoutUpdate) {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3,\n        xgridData = $$.generateGridData(config.grid_x_type, $$.x),\n        tickOffset = $$.isCategorized() ? $$.xAxis.tickOffset() : 0;\n    $$.xgridAttr = config.axis_rotated ? {\n      'x1': 0,\n      'x2': $$.width,\n      'y1': function y1(d) {\n        return $$.x(d) - tickOffset;\n      },\n      'y2': function y2(d) {\n        return $$.x(d) - tickOffset;\n      }\n    } : {\n      'x1': function x1(d) {\n        return $$.x(d) + tickOffset;\n      },\n      'x2': function x2(d) {\n        return $$.x(d) + tickOffset;\n      },\n      'y1': 0,\n      'y2': $$.height\n    };\n    $$.xgrid = $$.main.select('.' + CLASS.xgrids).selectAll('.' + CLASS.xgrid).data(xgridData);\n    $$.xgrid.enter().append('line').attr(\"class\", CLASS.xgrid);\n\n    if (!withoutUpdate) {\n      $$.xgrid.attr($$.xgridAttr).style(\"opacity\", function () {\n        return +d3.select(this).attr(config.axis_rotated ? 'y1' : 'x1') === (config.axis_rotated ? $$.height : 0) ? 0 : 1;\n      });\n    }\n\n    $$.xgrid.exit().remove();\n  };\n\n  c3_chart_internal_fn.updateYGrid = function () {\n    var $$ = this,\n        config = $$.config,\n        gridValues = $$.yAxis.tickValues() || $$.y.ticks(config.grid_y_ticks);\n    $$.ygrid = $$.main.select('.' + CLASS.ygrids).selectAll('.' + CLASS.ygrid).data(gridValues);\n    $$.ygrid.enter().append('line').attr('class', CLASS.ygrid);\n    $$.ygrid.attr(\"x1\", config.axis_rotated ? $$.y : 0).attr(\"x2\", config.axis_rotated ? $$.y : $$.width).attr(\"y1\", config.axis_rotated ? 0 : $$.y).attr(\"y2\", config.axis_rotated ? $$.height : $$.y);\n    $$.ygrid.exit().remove();\n    $$.smoothLines($$.ygrid, 'grid');\n  };\n\n  c3_chart_internal_fn.gridTextAnchor = function (d) {\n    return d.position ? d.position : \"end\";\n  };\n\n  c3_chart_internal_fn.gridTextDx = function (d) {\n    return d.position === 'start' ? 4 : d.position === 'middle' ? 0 : -4;\n  };\n\n  c3_chart_internal_fn.xGridTextX = function (d) {\n    return d.position === 'start' ? -this.height : d.position === 'middle' ? -this.height / 2 : 0;\n  };\n\n  c3_chart_internal_fn.yGridTextX = function (d) {\n    return d.position === 'start' ? 0 : d.position === 'middle' ? this.width / 2 : this.width;\n  };\n\n  c3_chart_internal_fn.updateGrid = function (duration) {\n    var $$ = this,\n        main = $$.main,\n        config = $$.config,\n        xgridLine,\n        ygridLine,\n        yv; // hide if arc type\n\n    $$.grid.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');\n    main.select('line.' + CLASS.xgridFocus).style(\"visibility\", \"hidden\");\n\n    if (config.grid_x_show) {\n      $$.updateXGrid();\n    }\n\n    $$.xgridLines = main.select('.' + CLASS.xgridLines).selectAll('.' + CLASS.xgridLine).data(config.grid_x_lines); // enter\n\n    xgridLine = $$.xgridLines.enter().append('g').attr(\"class\", function (d) {\n      return CLASS.xgridLine + (d['class'] ? ' ' + d['class'] : '');\n    });\n    xgridLine.append('line').style(\"opacity\", 0);\n    xgridLine.append('text').attr(\"text-anchor\", $$.gridTextAnchor).attr(\"transform\", config.axis_rotated ? \"\" : \"rotate(-90)\").attr('dx', $$.gridTextDx).attr('dy', -5).style(\"opacity\", 0); // udpate\n    // done in d3.transition() of the end of this function\n    // exit\n\n    $$.xgridLines.exit().transition().duration(duration).style(\"opacity\", 0).remove(); // Y-Grid\n\n    if (config.grid_y_show) {\n      $$.updateYGrid();\n    }\n\n    $$.ygridLines = main.select('.' + CLASS.ygridLines).selectAll('.' + CLASS.ygridLine).data(config.grid_y_lines); // enter\n\n    ygridLine = $$.ygridLines.enter().append('g').attr(\"class\", function (d) {\n      return CLASS.ygridLine + (d['class'] ? ' ' + d['class'] : '');\n    });\n    ygridLine.append('line').style(\"opacity\", 0);\n    ygridLine.append('text').attr(\"text-anchor\", $$.gridTextAnchor).attr(\"transform\", config.axis_rotated ? \"rotate(-90)\" : \"\").attr('dx', $$.gridTextDx).attr('dy', -5).style(\"opacity\", 0); // update\n\n    yv = $$.yv.bind($$);\n    $$.ygridLines.select('line').transition().duration(duration).attr(\"x1\", config.axis_rotated ? yv : 0).attr(\"x2\", config.axis_rotated ? yv : $$.width).attr(\"y1\", config.axis_rotated ? 0 : yv).attr(\"y2\", config.axis_rotated ? $$.height : yv).style(\"opacity\", 1);\n    $$.ygridLines.select('text').transition().duration(duration).attr(\"x\", config.axis_rotated ? $$.xGridTextX.bind($$) : $$.yGridTextX.bind($$)).attr(\"y\", yv).text(function (d) {\n      return d.text;\n    }).style(\"opacity\", 1); // exit\n\n    $$.ygridLines.exit().transition().duration(duration).style(\"opacity\", 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawGrid = function (withTransition) {\n    var $$ = this,\n        config = $$.config,\n        xv = $$.xv.bind($$),\n        lines = $$.xgridLines.select('line'),\n        texts = $$.xgridLines.select('text');\n    return [(withTransition ? lines.transition() : lines).attr(\"x1\", config.axis_rotated ? 0 : xv).attr(\"x2\", config.axis_rotated ? $$.width : xv).attr(\"y1\", config.axis_rotated ? xv : 0).attr(\"y2\", config.axis_rotated ? xv : $$.height).style(\"opacity\", 1), (withTransition ? texts.transition() : texts).attr(\"x\", config.axis_rotated ? $$.yGridTextX.bind($$) : $$.xGridTextX.bind($$)).attr(\"y\", xv).text(function (d) {\n      return d.text;\n    }).style(\"opacity\", 1)];\n  };\n\n  c3_chart_internal_fn.showXGridFocus = function (selectedData) {\n    var $$ = this,\n        config = $$.config,\n        dataToShow = selectedData.filter(function (d) {\n      return d && isValue(d.value);\n    }),\n        focusEl = $$.main.selectAll('line.' + CLASS.xgridFocus),\n        xx = $$.xx.bind($$);\n\n    if (!config.tooltip_show) {\n      return;\n    } // Hide when scatter plot exists\n\n\n    if ($$.hasType('scatter') || $$.hasArcType()) {\n      return;\n    }\n\n    focusEl.style(\"visibility\", \"visible\").data([dataToShow[0]]).attr(config.axis_rotated ? 'y1' : 'x1', xx).attr(config.axis_rotated ? 'y2' : 'x2', xx);\n    $$.smoothLines(focusEl, 'grid');\n  };\n\n  c3_chart_internal_fn.hideXGridFocus = function () {\n    this.main.select('line.' + CLASS.xgridFocus).style(\"visibility\", \"hidden\");\n  };\n\n  c3_chart_internal_fn.updateXgridFocus = function () {\n    var $$ = this,\n        config = $$.config;\n    $$.main.select('line.' + CLASS.xgridFocus).attr(\"x1\", config.axis_rotated ? 0 : -10).attr(\"x2\", config.axis_rotated ? $$.width : -10).attr(\"y1\", config.axis_rotated ? -10 : 0).attr(\"y2\", config.axis_rotated ? -10 : $$.height);\n  };\n\n  c3_chart_internal_fn.generateGridData = function (type, scale) {\n    var $$ = this,\n        gridData = [],\n        xDomain,\n        firstYear,\n        lastYear,\n        i,\n        tickNum = $$.main.select(\".\" + CLASS.axisX).selectAll('.tick').size();\n\n    if (type === 'year') {\n      xDomain = $$.getXDomain();\n      firstYear = xDomain[0].getFullYear();\n      lastYear = xDomain[1].getFullYear();\n\n      for (i = firstYear; i <= lastYear; i++) {\n        gridData.push(new Date(i + '-01-01 00:00:00'));\n      }\n    } else {\n      gridData = scale.ticks(10);\n\n      if (gridData.length > tickNum) {\n        // use only int\n        gridData = gridData.filter(function (d) {\n          return (\"\" + d).indexOf('.') < 0;\n        });\n      }\n    }\n\n    return gridData;\n  };\n\n  c3_chart_internal_fn.getGridFilterToRemove = function (params) {\n    return params ? function (line) {\n      var found = false;\n      [].concat(params).forEach(function (param) {\n        if ('value' in param && line.value === param.value || 'class' in param && line['class'] === param['class']) {\n          found = true;\n        }\n      });\n      return found;\n    } : function () {\n      return true;\n    };\n  };\n\n  c3_chart_internal_fn.removeGridLines = function (params, forX) {\n    var $$ = this,\n        config = $$.config,\n        toRemove = $$.getGridFilterToRemove(params),\n        toShow = function toShow(line) {\n      return !toRemove(line);\n    },\n        classLines = forX ? CLASS.xgridLines : CLASS.ygridLines,\n        classLine = forX ? CLASS.xgridLine : CLASS.ygridLine;\n\n    $$.main.select('.' + classLines).selectAll('.' + classLine).filter(toRemove).transition().duration(config.transition_duration).style('opacity', 0).remove();\n\n    if (forX) {\n      config.grid_x_lines = config.grid_x_lines.filter(toShow);\n    } else {\n      config.grid_y_lines = config.grid_y_lines.filter(toShow);\n    }\n  };\n\n  c3_chart_internal_fn.initEventRect = function () {\n    var $$ = this;\n    $$.main.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.eventRects).style('fill-opacity', 0);\n  };\n\n  c3_chart_internal_fn.redrawEventRect = function () {\n    var $$ = this,\n        config = $$.config,\n        eventRectUpdate,\n        maxDataCountTarget,\n        isMultipleX = $$.isMultipleX(); // rects for mouseover\n\n    var eventRects = $$.main.select('.' + CLASS.eventRects).style('cursor', config.zoom_enabled ? config.axis_rotated ? 'ns-resize' : 'ew-resize' : null).classed(CLASS.eventRectsMultiple, isMultipleX).classed(CLASS.eventRectsSingle, !isMultipleX); // clear old rects\n\n    eventRects.selectAll('.' + CLASS.eventRect).remove(); // open as public variable\n\n    $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);\n\n    if (isMultipleX) {\n      eventRectUpdate = $$.eventRect.data([0]); // enter : only one rect will be added\n\n      $$.generateEventRectsForMultipleXs(eventRectUpdate.enter()); // update\n\n      $$.updateEventRect(eventRectUpdate); // exit : not needed because always only one rect exists\n    } else {\n      // Set data and update $$.eventRect\n      maxDataCountTarget = $$.getMaxDataCountTarget($$.data.targets);\n      eventRects.datum(maxDataCountTarget ? maxDataCountTarget.values : []);\n      $$.eventRect = eventRects.selectAll('.' + CLASS.eventRect);\n      eventRectUpdate = $$.eventRect.data(function (d) {\n        return d;\n      }); // enter\n\n      $$.generateEventRectsForSingleX(eventRectUpdate.enter()); // update\n\n      $$.updateEventRect(eventRectUpdate); // exit\n\n      eventRectUpdate.exit().remove();\n    }\n  };\n\n  c3_chart_internal_fn.updateEventRect = function (eventRectUpdate) {\n    var $$ = this,\n        config = $$.config,\n        x,\n        y,\n        w,\n        h,\n        rectW,\n        rectX; // set update selection if null\n\n    eventRectUpdate = eventRectUpdate || $$.eventRect.data(function (d) {\n      return d;\n    });\n\n    if ($$.isMultipleX()) {\n      // TODO: rotated not supported yet\n      x = 0;\n      y = 0;\n      w = $$.width;\n      h = $$.height;\n    } else {\n      if (($$.isCustomX() || $$.isTimeSeries()) && !$$.isCategorized()) {\n        // update index for x that is used by prevX and nextX\n        $$.updateXs();\n\n        rectW = function rectW(d) {\n          var prevX = $$.getPrevX(d.index),\n              nextX = $$.getNextX(d.index); // if there this is a single data point make the eventRect full width (or height)\n\n          if (prevX === null && nextX === null) {\n            return config.axis_rotated ? $$.height : $$.width;\n          }\n\n          if (prevX === null) {\n            prevX = $$.x.domain()[0];\n          }\n\n          if (nextX === null) {\n            nextX = $$.x.domain()[1];\n          }\n\n          return Math.max(0, ($$.x(nextX) - $$.x(prevX)) / 2);\n        };\n\n        rectX = function rectX(d) {\n          var prevX = $$.getPrevX(d.index),\n              nextX = $$.getNextX(d.index),\n              thisX = $$.data.xs[d.id][d.index]; // if there this is a single data point position the eventRect at 0\n\n          if (prevX === null && nextX === null) {\n            return 0;\n          }\n\n          if (prevX === null) {\n            prevX = $$.x.domain()[0];\n          }\n\n          return ($$.x(thisX) + $$.x(prevX)) / 2;\n        };\n      } else {\n        rectW = $$.getEventRectWidth();\n\n        rectX = function rectX(d) {\n          return $$.x(d.x) - rectW / 2;\n        };\n      }\n\n      x = config.axis_rotated ? 0 : rectX;\n      y = config.axis_rotated ? rectX : 0;\n      w = config.axis_rotated ? $$.width : rectW;\n      h = config.axis_rotated ? rectW : $$.height;\n    }\n\n    eventRectUpdate.attr('class', $$.classEvent.bind($$)).attr(\"x\", x).attr(\"y\", y).attr(\"width\", w).attr(\"height\", h);\n  };\n\n  c3_chart_internal_fn.generateEventRectsForSingleX = function (eventRectEnter) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config;\n    eventRectEnter.append(\"rect\").attr(\"class\", $$.classEvent.bind($$)).style(\"cursor\", config.data_selection_enabled && config.data_selection_grouped ? \"pointer\" : null).on('mouseover', function (d) {\n      var index = d.index;\n\n      if ($$.dragging || $$.flowing) {\n        return;\n      } // do nothing while dragging/flowing\n\n\n      if ($$.hasArcType()) {\n        return;\n      } // Expand shapes for selection\n\n\n      if (config.point_focus_expand_enabled) {\n        $$.expandCircles(index, null, true);\n      }\n\n      $$.expandBars(index, null, true); // Call event handler\n\n      $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {\n        config.data_onmouseover.call($$.api, d);\n      });\n    }).on('mouseout', function (d) {\n      var index = d.index;\n\n      if (!$$.config) {\n        return;\n      } // chart is destroyed\n\n\n      if ($$.hasArcType()) {\n        return;\n      }\n\n      $$.hideXGridFocus();\n      $$.hideTooltip(); // Undo expanded shapes\n\n      $$.unexpandCircles();\n      $$.unexpandBars(); // Call event handler\n\n      $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {\n        config.data_onmouseout.call($$.api, d);\n      });\n    }).on('mousemove', function (d) {\n      var selectedData,\n          index = d.index,\n          eventRect = $$.svg.select('.' + CLASS.eventRect + '-' + index);\n\n      if ($$.dragging || $$.flowing) {\n        return;\n      } // do nothing while dragging/flowing\n\n\n      if ($$.hasArcType()) {\n        return;\n      }\n\n      if ($$.isStepType(d) && $$.config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {\n        index -= 1;\n      } // Show tooltip\n\n\n      selectedData = $$.filterTargetsToShow($$.data.targets).map(function (t) {\n        return $$.addName($$.getValueOnIndex(t.values, index));\n      });\n\n      if (config.tooltip_grouped) {\n        $$.showTooltip(selectedData, this);\n        $$.showXGridFocus(selectedData);\n      }\n\n      if (config.tooltip_grouped && (!config.data_selection_enabled || config.data_selection_grouped)) {\n        return;\n      }\n\n      $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function () {\n        d3.select(this).classed(CLASS.EXPANDED, true);\n\n        if (config.data_selection_enabled) {\n          eventRect.style('cursor', config.data_selection_grouped ? 'pointer' : null);\n        }\n\n        if (!config.tooltip_grouped) {\n          $$.hideXGridFocus();\n          $$.hideTooltip();\n\n          if (!config.data_selection_grouped) {\n            $$.unexpandCircles(index);\n            $$.unexpandBars(index);\n          }\n        }\n      }).filter(function (d) {\n        return $$.isWithinShape(this, d);\n      }).each(function (d) {\n        if (config.data_selection_enabled && (config.data_selection_grouped || config.data_selection_isselectable(d))) {\n          eventRect.style('cursor', 'pointer');\n        }\n\n        if (!config.tooltip_grouped) {\n          $$.showTooltip([d], this);\n          $$.showXGridFocus([d]);\n\n          if (config.point_focus_expand_enabled) {\n            $$.expandCircles(index, d.id, true);\n          }\n\n          $$.expandBars(index, d.id, true);\n        }\n      });\n    }).on('click', function (d) {\n      var index = d.index;\n\n      if ($$.hasArcType() || !$$.toggleShape) {\n        return;\n      }\n\n      if ($$.cancelClick) {\n        $$.cancelClick = false;\n        return;\n      }\n\n      if ($$.isStepType(d) && config.line_step_type === 'step-after' && d3.mouse(this)[0] < $$.x($$.getXValue(d.id, index))) {\n        index -= 1;\n      }\n\n      $$.main.selectAll('.' + CLASS.shape + '-' + index).each(function (d) {\n        if (config.data_selection_grouped || $$.isWithinShape(this, d)) {\n          $$.toggleShape(this, d, index);\n          $$.config.data_onclick.call($$.api, d, this);\n        }\n      });\n    }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {\n      $$.drag(d3.mouse(this));\n    }).on('dragstart', function () {\n      $$.dragstart(d3.mouse(this));\n    }).on('dragend', function () {\n      $$.dragend();\n    }) : function () {});\n  };\n\n  c3_chart_internal_fn.generateEventRectsForMultipleXs = function (eventRectEnter) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config;\n\n    function mouseout() {\n      $$.svg.select('.' + CLASS.eventRect).style('cursor', null);\n      $$.hideXGridFocus();\n      $$.hideTooltip();\n      $$.unexpandCircles();\n      $$.unexpandBars();\n    }\n\n    eventRectEnter.append('rect').attr('x', 0).attr('y', 0).attr('width', $$.width).attr('height', $$.height).attr('class', CLASS.eventRect).on('mouseout', function () {\n      if (!$$.config) {\n        return;\n      } // chart is destroyed\n\n\n      if ($$.hasArcType()) {\n        return;\n      }\n\n      mouseout();\n    }).on('mousemove', function () {\n      var targetsToShow = $$.filterTargetsToShow($$.data.targets);\n      var mouse, closest, sameXData, selectedData;\n\n      if ($$.dragging) {\n        return;\n      } // do nothing when dragging\n\n\n      if ($$.hasArcType(targetsToShow)) {\n        return;\n      }\n\n      mouse = d3.mouse(this);\n      closest = $$.findClosestFromTargets(targetsToShow, mouse);\n\n      if ($$.mouseover && (!closest || closest.id !== $$.mouseover.id)) {\n        config.data_onmouseout.call($$.api, $$.mouseover);\n        $$.mouseover = undefined;\n      }\n\n      if (!closest) {\n        mouseout();\n        return;\n      }\n\n      if ($$.isScatterType(closest) || !config.tooltip_grouped) {\n        sameXData = [closest];\n      } else {\n        sameXData = $$.filterByX(targetsToShow, closest.x);\n      } // show tooltip when cursor is close to some point\n\n\n      selectedData = sameXData.map(function (d) {\n        return $$.addName(d);\n      });\n      $$.showTooltip(selectedData, this); // expand points\n\n      if (config.point_focus_expand_enabled) {\n        $$.expandCircles(closest.index, closest.id, true);\n      }\n\n      $$.expandBars(closest.index, closest.id, true); // Show xgrid focus line\n\n      $$.showXGridFocus(selectedData); // Show cursor as pointer if point is close to mouse position\n\n      if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\n        $$.svg.select('.' + CLASS.eventRect).style('cursor', 'pointer');\n\n        if (!$$.mouseover) {\n          config.data_onmouseover.call($$.api, closest);\n          $$.mouseover = closest;\n        }\n      }\n    }).on('click', function () {\n      var targetsToShow = $$.filterTargetsToShow($$.data.targets);\n      var mouse, closest;\n\n      if ($$.hasArcType(targetsToShow)) {\n        return;\n      }\n\n      mouse = d3.mouse(this);\n      closest = $$.findClosestFromTargets(targetsToShow, mouse);\n\n      if (!closest) {\n        return;\n      } // select if selection enabled\n\n\n      if ($$.isBarType(closest.id) || $$.dist(closest, mouse) < config.point_sensitivity) {\n        $$.main.selectAll('.' + CLASS.shapes + $$.getTargetSelectorSuffix(closest.id)).selectAll('.' + CLASS.shape + '-' + closest.index).each(function () {\n          if (config.data_selection_grouped || $$.isWithinShape(this, closest)) {\n            $$.toggleShape(this, closest, closest.index);\n            $$.config.data_onclick.call($$.api, closest, this);\n          }\n        });\n      }\n    }).call(config.data_selection_draggable && $$.drag ? d3.behavior.drag().origin(Object).on('drag', function () {\n      $$.drag(d3.mouse(this));\n    }).on('dragstart', function () {\n      $$.dragstart(d3.mouse(this));\n    }).on('dragend', function () {\n      $$.dragend();\n    }) : function () {});\n  };\n\n  c3_chart_internal_fn.dispatchEvent = function (type, index, mouse) {\n    var $$ = this,\n        selector = '.' + CLASS.eventRect + (!$$.isMultipleX() ? '-' + index : ''),\n        eventRect = $$.main.select(selector).node(),\n        box = eventRect.getBoundingClientRect(),\n        x = box.left + (mouse ? mouse[0] : 0),\n        y = box.top + (mouse ? mouse[1] : 0),\n        event = document.createEvent(\"MouseEvents\");\n    event.initMouseEvent(type, true, true, window, 0, x, y, x, y, false, false, false, false, 0, null);\n    eventRect.dispatchEvent(event);\n  };\n\n  c3_chart_internal_fn.initLegend = function () {\n    var $$ = this;\n    $$.legendItemTextBox = {};\n    $$.legendHasRendered = false;\n    $$.legend = $$.svg.append(\"g\").attr(\"transform\", $$.getTranslate('legend'));\n\n    if (!$$.config.legend_show) {\n      $$.legend.style('visibility', 'hidden');\n      $$.hiddenLegendIds = $$.mapToIds($$.data.targets);\n      return;\n    } // MEMO: call here to update legend box and tranlate for all\n    // MEMO: translate will be upated by this, so transform not needed in updateLegend()\n\n\n    $$.updateLegendWithDefaults();\n  };\n\n  c3_chart_internal_fn.updateLegendWithDefaults = function () {\n    var $$ = this;\n    $$.updateLegend($$.mapToIds($$.data.targets), {\n      withTransform: false,\n      withTransitionForTransform: false,\n      withTransition: false\n    });\n  };\n\n  c3_chart_internal_fn.updateSizeForLegend = function (legendHeight, legendWidth) {\n    var $$ = this,\n        config = $$.config,\n        insetLegendPosition = {\n      top: $$.isLegendTop ? $$.getCurrentPaddingTop() + config.legend_inset_y + 5.5 : $$.currentHeight - legendHeight - $$.getCurrentPaddingBottom() - config.legend_inset_y,\n      left: $$.isLegendLeft ? $$.getCurrentPaddingLeft() + config.legend_inset_x + 0.5 : $$.currentWidth - legendWidth - $$.getCurrentPaddingRight() - config.legend_inset_x + 0.5\n    };\n    $$.margin3 = {\n      top: $$.isLegendRight ? 0 : $$.isLegendInset ? insetLegendPosition.top : $$.currentHeight - legendHeight,\n      right: NaN,\n      bottom: 0,\n      left: $$.isLegendRight ? $$.currentWidth - legendWidth : $$.isLegendInset ? insetLegendPosition.left : 0\n    };\n  };\n\n  c3_chart_internal_fn.transformLegend = function (withTransition) {\n    var $$ = this;\n    (withTransition ? $$.legend.transition() : $$.legend).attr(\"transform\", $$.getTranslate('legend'));\n  };\n\n  c3_chart_internal_fn.updateLegendStep = function (step) {\n    this.legendStep = step;\n  };\n\n  c3_chart_internal_fn.updateLegendItemWidth = function (w) {\n    this.legendItemWidth = w;\n  };\n\n  c3_chart_internal_fn.updateLegendItemHeight = function (h) {\n    this.legendItemHeight = h;\n  };\n\n  c3_chart_internal_fn.getLegendWidth = function () {\n    var $$ = this;\n    return $$.config.legend_show ? $$.isLegendRight || $$.isLegendInset ? $$.legendItemWidth * ($$.legendStep + 1) : $$.currentWidth : 0;\n  };\n\n  c3_chart_internal_fn.getLegendHeight = function () {\n    var $$ = this,\n        h = 0;\n\n    if ($$.config.legend_show) {\n      if ($$.isLegendRight) {\n        h = $$.currentHeight;\n      } else {\n        h = Math.max(20, $$.legendItemHeight) * ($$.legendStep + 1);\n      }\n    }\n\n    return h;\n  };\n\n  c3_chart_internal_fn.opacityForLegend = function (legendItem) {\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 1;\n  };\n\n  c3_chart_internal_fn.opacityForUnfocusedLegend = function (legendItem) {\n    return legendItem.classed(CLASS.legendItemHidden) ? null : 0.3;\n  };\n\n  c3_chart_internal_fn.toggleFocusLegend = function (targetIds, focus) {\n    var $$ = this;\n    targetIds = $$.mapToTargetIds(targetIds);\n    $$.legend.selectAll('.' + CLASS.legendItem).filter(function (id) {\n      return targetIds.indexOf(id) >= 0;\n    }).classed(CLASS.legendItemFocused, focus).transition().duration(100).style('opacity', function () {\n      var opacity = focus ? $$.opacityForLegend : $$.opacityForUnfocusedLegend;\n      return opacity.call($$, $$.d3.select(this));\n    });\n  };\n\n  c3_chart_internal_fn.revertLegend = function () {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemFocused, false).transition().duration(100).style('opacity', function () {\n      return $$.opacityForLegend(d3.select(this));\n    });\n  };\n\n  c3_chart_internal_fn.showLegend = function (targetIds) {\n    var $$ = this,\n        config = $$.config;\n\n    if (!config.legend_show) {\n      config.legend_show = true;\n      $$.legend.style('visibility', 'visible');\n\n      if (!$$.legendHasRendered) {\n        $$.updateLegendWithDefaults();\n      }\n    }\n\n    $$.removeHiddenLegendIds(targetIds);\n    $$.legend.selectAll($$.selectorLegends(targetIds)).style('visibility', 'visible').transition().style('opacity', function () {\n      return $$.opacityForLegend($$.d3.select(this));\n    });\n  };\n\n  c3_chart_internal_fn.hideLegend = function (targetIds) {\n    var $$ = this,\n        config = $$.config;\n\n    if (config.legend_show && isEmpty(targetIds)) {\n      config.legend_show = false;\n      $$.legend.style('visibility', 'hidden');\n    }\n\n    $$.addHiddenLegendIds(targetIds);\n    $$.legend.selectAll($$.selectorLegends(targetIds)).style('opacity', 0).style('visibility', 'hidden');\n  };\n\n  c3_chart_internal_fn.clearLegendItemTextBoxCache = function () {\n    this.legendItemTextBox = {};\n  };\n\n  c3_chart_internal_fn.updateLegend = function (targetIds, options, transitions) {\n    var $$ = this,\n        config = $$.config;\n    var xForLegend, xForLegendText, xForLegendRect, yForLegend, yForLegendText, yForLegendRect, x1ForLegendTile, x2ForLegendTile, yForLegendTile;\n    var paddingTop = 4,\n        paddingRight = 10,\n        maxWidth = 0,\n        maxHeight = 0,\n        posMin = 10,\n        tileWidth = config.legend_item_tile_width + 5;\n    var l,\n        totalLength = 0,\n        offsets = {},\n        widths = {},\n        heights = {},\n        margins = [0],\n        steps = {},\n        step = 0;\n    var withTransition, withTransitionForTransform;\n    var texts, rects, tiles, background; // Skip elements when their name is set to null\n\n    targetIds = targetIds.filter(function (id) {\n      return !isDefined(config.data_names[id]) || config.data_names[id] !== null;\n    });\n    options = options || {};\n    withTransition = getOption(options, \"withTransition\", true);\n    withTransitionForTransform = getOption(options, \"withTransitionForTransform\", true);\n\n    function getTextBox(textElement, id) {\n      if (!$$.legendItemTextBox[id]) {\n        $$.legendItemTextBox[id] = $$.getTextRect(textElement.textContent, CLASS.legendItem, textElement);\n      }\n\n      return $$.legendItemTextBox[id];\n    }\n\n    function updatePositions(textElement, id, index) {\n      var reset = index === 0,\n          isLast = index === targetIds.length - 1,\n          box = getTextBox(textElement, id),\n          itemWidth = box.width + tileWidth + (isLast && !($$.isLegendRight || $$.isLegendInset) ? 0 : paddingRight) + config.legend_padding,\n          itemHeight = box.height + paddingTop,\n          itemLength = $$.isLegendRight || $$.isLegendInset ? itemHeight : itemWidth,\n          areaLength = $$.isLegendRight || $$.isLegendInset ? $$.getLegendHeight() : $$.getLegendWidth(),\n          margin,\n          maxLength; // MEMO: care about condifion of step, totalLength\n\n      function updateValues(id, withoutStep) {\n        if (!withoutStep) {\n          margin = (areaLength - totalLength - itemLength) / 2;\n\n          if (margin < posMin) {\n            margin = (areaLength - itemLength) / 2;\n            totalLength = 0;\n            step++;\n          }\n        }\n\n        steps[id] = step;\n        margins[step] = $$.isLegendInset ? 10 : margin;\n        offsets[id] = totalLength;\n        totalLength += itemLength;\n      }\n\n      if (reset) {\n        totalLength = 0;\n        step = 0;\n        maxWidth = 0;\n        maxHeight = 0;\n      }\n\n      if (config.legend_show && !$$.isLegendToShow(id)) {\n        widths[id] = heights[id] = steps[id] = offsets[id] = 0;\n        return;\n      }\n\n      widths[id] = itemWidth;\n      heights[id] = itemHeight;\n\n      if (!maxWidth || itemWidth >= maxWidth) {\n        maxWidth = itemWidth;\n      }\n\n      if (!maxHeight || itemHeight >= maxHeight) {\n        maxHeight = itemHeight;\n      }\n\n      maxLength = $$.isLegendRight || $$.isLegendInset ? maxHeight : maxWidth;\n\n      if (config.legend_equally) {\n        Object.keys(widths).forEach(function (id) {\n          widths[id] = maxWidth;\n        });\n        Object.keys(heights).forEach(function (id) {\n          heights[id] = maxHeight;\n        });\n        margin = (areaLength - maxLength * targetIds.length) / 2;\n\n        if (margin < posMin) {\n          totalLength = 0;\n          step = 0;\n          targetIds.forEach(function (id) {\n            updateValues(id);\n          });\n        } else {\n          updateValues(id, true);\n        }\n      } else {\n        updateValues(id);\n      }\n    }\n\n    if ($$.isLegendInset) {\n      step = config.legend_inset_step ? config.legend_inset_step : targetIds.length;\n      $$.updateLegendStep(step);\n    }\n\n    if ($$.isLegendRight) {\n      xForLegend = function xForLegend(id) {\n        return maxWidth * steps[id];\n      };\n\n      yForLegend = function yForLegend(id) {\n        return margins[steps[id]] + offsets[id];\n      };\n    } else if ($$.isLegendInset) {\n      xForLegend = function xForLegend(id) {\n        return maxWidth * steps[id] + 10;\n      };\n\n      yForLegend = function yForLegend(id) {\n        return margins[steps[id]] + offsets[id];\n      };\n    } else {\n      xForLegend = function xForLegend(id) {\n        return margins[steps[id]] + offsets[id];\n      };\n\n      yForLegend = function yForLegend(id) {\n        return maxHeight * steps[id];\n      };\n    }\n\n    xForLegendText = function xForLegendText(id, i) {\n      return xForLegend(id, i) + 4 + config.legend_item_tile_width;\n    };\n\n    yForLegendText = function yForLegendText(id, i) {\n      return yForLegend(id, i) + 9;\n    };\n\n    xForLegendRect = function xForLegendRect(id, i) {\n      return xForLegend(id, i);\n    };\n\n    yForLegendRect = function yForLegendRect(id, i) {\n      return yForLegend(id, i) - 5;\n    };\n\n    x1ForLegendTile = function x1ForLegendTile(id, i) {\n      return xForLegend(id, i) - 2;\n    };\n\n    x2ForLegendTile = function x2ForLegendTile(id, i) {\n      return xForLegend(id, i) - 2 + config.legend_item_tile_width;\n    };\n\n    yForLegendTile = function yForLegendTile(id, i) {\n      return yForLegend(id, i) + 4;\n    }; // Define g for legend area\n\n\n    l = $$.legend.selectAll('.' + CLASS.legendItem).data(targetIds).enter().append('g').attr('class', function (id) {\n      return $$.generateClass(CLASS.legendItem, id);\n    }).style('visibility', function (id) {\n      return $$.isLegendToShow(id) ? 'visible' : 'hidden';\n    }).style('cursor', 'pointer').on('click', function (id) {\n      if (config.legend_item_onclick) {\n        config.legend_item_onclick.call($$, id);\n      } else {\n        if ($$.d3.event.altKey) {\n          $$.api.hide();\n          $$.api.show(id);\n        } else {\n          $$.api.toggle(id);\n          $$.isTargetToShow(id) ? $$.api.focus(id) : $$.api.revert();\n        }\n      }\n    }).on('mouseover', function (id) {\n      if (config.legend_item_onmouseover) {\n        config.legend_item_onmouseover.call($$, id);\n      } else {\n        $$.d3.select(this).classed(CLASS.legendItemFocused, true);\n\n        if (!$$.transiting && $$.isTargetToShow(id)) {\n          $$.api.focus(id);\n        }\n      }\n    }).on('mouseout', function (id) {\n      if (config.legend_item_onmouseout) {\n        config.legend_item_onmouseout.call($$, id);\n      } else {\n        $$.d3.select(this).classed(CLASS.legendItemFocused, false);\n        $$.api.revert();\n      }\n    });\n    l.append('text').text(function (id) {\n      return isDefined(config.data_names[id]) ? config.data_names[id] : id;\n    }).each(function (id, i) {\n      updatePositions(this, id, i);\n    }).style(\"pointer-events\", \"none\").attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendText : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendText);\n    l.append('rect').attr(\"class\", CLASS.legendItemEvent).style('fill-opacity', 0).attr('x', $$.isLegendRight || $$.isLegendInset ? xForLegendRect : -200).attr('y', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendRect);\n    l.append('line').attr('class', CLASS.legendItemTile).style('stroke', $$.color).style(\"pointer-events\", \"none\").attr('x1', $$.isLegendRight || $$.isLegendInset ? x1ForLegendTile : -200).attr('y1', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('x2', $$.isLegendRight || $$.isLegendInset ? x2ForLegendTile : -200).attr('y2', $$.isLegendRight || $$.isLegendInset ? -200 : yForLegendTile).attr('stroke-width', config.legend_item_tile_height); // Set background for inset legend\n\n    background = $$.legend.select('.' + CLASS.legendBackground + ' rect');\n\n    if ($$.isLegendInset && maxWidth > 0 && background.size() === 0) {\n      background = $$.legend.insert('g', '.' + CLASS.legendItem).attr(\"class\", CLASS.legendBackground).append('rect');\n    }\n\n    texts = $$.legend.selectAll('text').data(targetIds).text(function (id) {\n      return isDefined(config.data_names[id]) ? config.data_names[id] : id;\n    }) // MEMO: needed for update\n    .each(function (id, i) {\n      updatePositions(this, id, i);\n    });\n    (withTransition ? texts.transition() : texts).attr('x', xForLegendText).attr('y', yForLegendText);\n    rects = $$.legend.selectAll('rect.' + CLASS.legendItemEvent).data(targetIds);\n    (withTransition ? rects.transition() : rects).attr('width', function (id) {\n      return widths[id];\n    }).attr('height', function (id) {\n      return heights[id];\n    }).attr('x', xForLegendRect).attr('y', yForLegendRect);\n    tiles = $$.legend.selectAll('line.' + CLASS.legendItemTile).data(targetIds);\n    (withTransition ? tiles.transition() : tiles).style('stroke', $$.levelColor ? function (id) {\n      return $$.levelColor($$.cache[id].values[0].value);\n    } : $$.color).attr('x1', x1ForLegendTile).attr('y1', yForLegendTile).attr('x2', x2ForLegendTile).attr('y2', yForLegendTile);\n\n    if (background) {\n      (withTransition ? background.transition() : background).attr('height', $$.getLegendHeight() - 12).attr('width', maxWidth * (step + 1) + 10);\n    } // toggle legend state\n\n\n    $$.legend.selectAll('.' + CLASS.legendItem).classed(CLASS.legendItemHidden, function (id) {\n      return !$$.isTargetToShow(id);\n    }); // Update all to reflect change of legend\n\n    $$.updateLegendItemWidth(maxWidth);\n    $$.updateLegendItemHeight(maxHeight);\n    $$.updateLegendStep(step); // Update size and scale\n\n    $$.updateSizes();\n    $$.updateScales();\n    $$.updateSvgSize(); // Update g positions\n\n    $$.transformAll(withTransitionForTransform, transitions);\n    $$.legendHasRendered = true;\n  };\n\n  c3_chart_internal_fn.initRegion = function () {\n    var $$ = this;\n    $$.region = $$.main.append('g').attr(\"clip-path\", $$.clipPath).attr(\"class\", CLASS.regions);\n  };\n\n  c3_chart_internal_fn.updateRegion = function (duration) {\n    var $$ = this,\n        config = $$.config; // hide if arc type\n\n    $$.region.style('visibility', $$.hasArcType() ? 'hidden' : 'visible');\n    $$.mainRegion = $$.main.select('.' + CLASS.regions).selectAll('.' + CLASS.region).data(config.regions);\n    $$.mainRegion.enter().append('g').append('rect').style(\"fill-opacity\", 0);\n    $$.mainRegion.attr('class', $$.classRegion.bind($$));\n    $$.mainRegion.exit().transition().duration(duration).style(\"opacity\", 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawRegion = function (withTransition) {\n    var $$ = this,\n        regions = $$.mainRegion.selectAll('rect').each(function () {\n      // data is binded to g and it's not transferred to rect (child node) automatically,\n      // then data of each rect has to be updated manually.\n      // TODO: there should be more efficient way to solve this?\n      var parentData = $$.d3.select(this.parentNode).datum();\n      $$.d3.select(this).datum(parentData);\n    }),\n        x = $$.regionX.bind($$),\n        y = $$.regionY.bind($$),\n        w = $$.regionWidth.bind($$),\n        h = $$.regionHeight.bind($$);\n    return [(withTransition ? regions.transition() : regions).attr(\"x\", x).attr(\"y\", y).attr(\"width\", w).attr(\"height\", h).style(\"fill-opacity\", function (d) {\n      return isValue(d.opacity) ? d.opacity : 0.1;\n    })];\n  };\n\n  c3_chart_internal_fn.regionX = function (d) {\n    var $$ = this,\n        config = $$.config,\n        xPos,\n        yScale = d.axis === 'y' ? $$.y : $$.y2;\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      xPos = config.axis_rotated ? 'start' in d ? yScale(d.start) : 0 : 0;\n    } else {\n      xPos = config.axis_rotated ? 0 : 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0;\n    }\n\n    return xPos;\n  };\n\n  c3_chart_internal_fn.regionY = function (d) {\n    var $$ = this,\n        config = $$.config,\n        yPos,\n        yScale = d.axis === 'y' ? $$.y : $$.y2;\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      yPos = config.axis_rotated ? 0 : 'end' in d ? yScale(d.end) : 0;\n    } else {\n      yPos = config.axis_rotated ? 'start' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.start) : d.start) : 0 : 0;\n    }\n\n    return yPos;\n  };\n\n  c3_chart_internal_fn.regionWidth = function (d) {\n    var $$ = this,\n        config = $$.config,\n        start = $$.regionX(d),\n        end,\n        yScale = d.axis === 'y' ? $$.y : $$.y2;\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      end = config.axis_rotated ? 'end' in d ? yScale(d.end) : $$.width : $$.width;\n    } else {\n      end = config.axis_rotated ? $$.width : 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.width;\n    }\n\n    return end < start ? 0 : end - start;\n  };\n\n  c3_chart_internal_fn.regionHeight = function (d) {\n    var $$ = this,\n        config = $$.config,\n        start = this.regionY(d),\n        end,\n        yScale = d.axis === 'y' ? $$.y : $$.y2;\n\n    if (d.axis === 'y' || d.axis === 'y2') {\n      end = config.axis_rotated ? $$.height : 'start' in d ? yScale(d.start) : $$.height;\n    } else {\n      end = config.axis_rotated ? 'end' in d ? $$.x($$.isTimeSeries() ? $$.parseDate(d.end) : d.end) : $$.height : $$.height;\n    }\n\n    return end < start ? 0 : end - start;\n  };\n\n  c3_chart_internal_fn.isRegionOnX = function (d) {\n    return !d.axis || d.axis === 'x';\n  };\n\n  c3_chart_internal_fn.getScale = function (min, max, forTimeseries) {\n    return (forTimeseries ? this.d3.time.scale() : this.d3.scale.linear()).range([min, max]);\n  };\n\n  c3_chart_internal_fn.getX = function (min, max, domain, offset) {\n    var $$ = this,\n        scale = $$.getScale(min, max, $$.isTimeSeries()),\n        _scale = domain ? scale.domain(domain) : scale,\n        key; // Define customized scale if categorized axis\n\n\n    if ($$.isCategorized()) {\n      offset = offset || function () {\n        return 0;\n      };\n\n      scale = function scale(d, raw) {\n        var v = _scale(d) + offset(d);\n        return raw ? v : Math.ceil(v);\n      };\n    } else {\n      scale = function scale(d, raw) {\n        var v = _scale(d);\n\n        return raw ? v : Math.ceil(v);\n      };\n    } // define functions\n\n\n    for (key in _scale) {\n      scale[key] = _scale[key];\n    }\n\n    scale.orgDomain = function () {\n      return _scale.domain();\n    }; // define custom domain() for categorized axis\n\n\n    if ($$.isCategorized()) {\n      scale.domain = function (domain) {\n        if (!arguments.length) {\n          domain = this.orgDomain();\n          return [domain[0], domain[1] + 1];\n        }\n\n        _scale.domain(domain);\n\n        return scale;\n      };\n    }\n\n    return scale;\n  };\n\n  c3_chart_internal_fn.getY = function (min, max, domain) {\n    var scale = this.getScale(min, max, this.isTimeSeriesY());\n\n    if (domain) {\n      scale.domain(domain);\n    }\n\n    return scale;\n  };\n\n  c3_chart_internal_fn.getYScale = function (id) {\n    return this.axis.getId(id) === 'y2' ? this.y2 : this.y;\n  };\n\n  c3_chart_internal_fn.getSubYScale = function (id) {\n    return this.axis.getId(id) === 'y2' ? this.subY2 : this.subY;\n  };\n\n  c3_chart_internal_fn.updateScales = function () {\n    var $$ = this,\n        config = $$.config,\n        forInit = !$$.x; // update edges\n\n    $$.xMin = config.axis_rotated ? 1 : 0;\n    $$.xMax = config.axis_rotated ? $$.height : $$.width;\n    $$.yMin = config.axis_rotated ? 0 : $$.height;\n    $$.yMax = config.axis_rotated ? $$.width : 1;\n    $$.subXMin = $$.xMin;\n    $$.subXMax = $$.xMax;\n    $$.subYMin = config.axis_rotated ? 0 : $$.height2;\n    $$.subYMax = config.axis_rotated ? $$.width2 : 1; // update scales\n\n    $$.x = $$.getX($$.xMin, $$.xMax, forInit ? undefined : $$.x.orgDomain(), function () {\n      return $$.xAxis.tickOffset();\n    });\n    $$.y = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y_default : $$.y.domain());\n    $$.y2 = $$.getY($$.yMin, $$.yMax, forInit ? config.axis_y2_default : $$.y2.domain());\n    $$.subX = $$.getX($$.xMin, $$.xMax, $$.orgXDomain, function (d) {\n      return d % 1 ? 0 : $$.subXAxis.tickOffset();\n    });\n    $$.subY = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y_default : $$.subY.domain());\n    $$.subY2 = $$.getY($$.subYMin, $$.subYMax, forInit ? config.axis_y2_default : $$.subY2.domain()); // update axes\n\n    $$.xAxisTickFormat = $$.axis.getXAxisTickFormat();\n    $$.xAxisTickValues = $$.axis.getXAxisTickValues();\n    $$.yAxisTickValues = $$.axis.getYAxisTickValues();\n    $$.y2AxisTickValues = $$.axis.getY2AxisTickValues();\n    $$.xAxis = $$.axis.getXAxis($$.x, $$.xOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);\n    $$.subXAxis = $$.axis.getXAxis($$.subX, $$.subXOrient, $$.xAxisTickFormat, $$.xAxisTickValues, config.axis_x_tick_outer);\n    $$.yAxis = $$.axis.getYAxis($$.y, $$.yOrient, config.axis_y_tick_format, $$.yAxisTickValues, config.axis_y_tick_outer);\n    $$.y2Axis = $$.axis.getYAxis($$.y2, $$.y2Orient, config.axis_y2_tick_format, $$.y2AxisTickValues, config.axis_y2_tick_outer); // Set initialized scales to brush and zoom\n\n    if (!forInit) {\n      if ($$.brush) {\n        $$.brush.scale($$.subX);\n      }\n\n      if (config.zoom_enabled) {\n        $$.zoom.scale($$.x);\n      }\n    } // update for arc\n\n\n    if ($$.updateArc) {\n      $$.updateArc();\n    }\n  };\n\n  c3_chart_internal_fn.selectPoint = function (target, d, i) {\n    var $$ = this,\n        config = $$.config,\n        cx = (config.axis_rotated ? $$.circleY : $$.circleX).bind($$),\n        cy = (config.axis_rotated ? $$.circleX : $$.circleY).bind($$),\n        r = $$.pointSelectR.bind($$);\n    config.data_onselected.call($$.api, d, target.node()); // add selected-circle on low layer g\n\n    $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).data([d]).enter().append('circle').attr(\"class\", function () {\n      return $$.generateClass(CLASS.selectedCircle, i);\n    }).attr(\"cx\", cx).attr(\"cy\", cy).attr(\"stroke\", function () {\n      return $$.color(d);\n    }).attr(\"r\", function (d) {\n      return $$.pointSelectR(d) * 1.4;\n    }).transition().duration(100).attr(\"r\", r);\n  };\n\n  c3_chart_internal_fn.unselectPoint = function (target, d, i) {\n    var $$ = this;\n    $$.config.data_onunselected.call($$.api, d, target.node()); // remove selected-circle from low layer g\n\n    $$.main.select('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(d.id)).selectAll('.' + CLASS.selectedCircle + '-' + i).transition().duration(100).attr('r', 0).remove();\n  };\n\n  c3_chart_internal_fn.togglePoint = function (selected, target, d, i) {\n    selected ? this.selectPoint(target, d, i) : this.unselectPoint(target, d, i);\n  };\n\n  c3_chart_internal_fn.selectPath = function (target, d) {\n    var $$ = this;\n    $$.config.data_onselected.call($$, d, target.node());\n\n    if ($$.config.interaction_brighten) {\n      target.transition().duration(100).style(\"fill\", function () {\n        return $$.d3.rgb($$.color(d)).brighter(0.75);\n      });\n    }\n  };\n\n  c3_chart_internal_fn.unselectPath = function (target, d) {\n    var $$ = this;\n    $$.config.data_onunselected.call($$, d, target.node());\n\n    if ($$.config.interaction_brighten) {\n      target.transition().duration(100).style(\"fill\", function () {\n        return $$.color(d);\n      });\n    }\n  };\n\n  c3_chart_internal_fn.togglePath = function (selected, target, d, i) {\n    selected ? this.selectPath(target, d, i) : this.unselectPath(target, d, i);\n  };\n\n  c3_chart_internal_fn.getToggle = function (that, d) {\n    var $$ = this,\n        toggle;\n\n    if (that.nodeName === 'circle') {\n      if ($$.isStepType(d)) {\n        // circle is hidden in step chart, so treat as within the click area\n        toggle = function toggle() {}; // TODO: how to select step chart?\n\n      } else {\n        toggle = $$.togglePoint;\n      }\n    } else if (that.nodeName === 'path') {\n      toggle = $$.togglePath;\n    }\n\n    return toggle;\n  };\n\n  c3_chart_internal_fn.toggleShape = function (that, d, i) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config,\n        shape = d3.select(that),\n        isSelected = shape.classed(CLASS.SELECTED),\n        toggle = $$.getToggle(that, d).bind($$);\n\n    if (config.data_selection_enabled && config.data_selection_isselectable(d)) {\n      if (!config.data_selection_multiple) {\n        $$.main.selectAll('.' + CLASS.shapes + (config.data_selection_grouped ? $$.getTargetSelectorSuffix(d.id) : \"\")).selectAll('.' + CLASS.shape).each(function (d, i) {\n          var shape = d3.select(this);\n\n          if (shape.classed(CLASS.SELECTED)) {\n            toggle(false, shape.classed(CLASS.SELECTED, false), d, i);\n          }\n        });\n      }\n\n      shape.classed(CLASS.SELECTED, !isSelected);\n      toggle(!isSelected, shape, d, i);\n    }\n  };\n\n  c3_chart_internal_fn.initBar = function () {\n    var $$ = this;\n    $$.main.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartBars);\n  };\n\n  c3_chart_internal_fn.updateTargetsForBar = function (targets) {\n    var $$ = this,\n        config = $$.config,\n        mainBarUpdate,\n        mainBarEnter,\n        classChartBar = $$.classChartBar.bind($$),\n        classBars = $$.classBars.bind($$),\n        classFocus = $$.classFocus.bind($$);\n    mainBarUpdate = $$.main.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', function (d) {\n      return classChartBar(d) + classFocus(d);\n    });\n    mainBarEnter = mainBarUpdate.enter().append('g').attr('class', classChartBar).style(\"pointer-events\", \"none\"); // Bars for each data\n\n    mainBarEnter.append('g').attr(\"class\", classBars).style(\"cursor\", function (d) {\n      return config.data_selection_isselectable(d) ? \"pointer\" : null;\n    });\n  };\n\n  c3_chart_internal_fn.updateBar = function (durationForExit) {\n    var $$ = this,\n        barData = $$.barData.bind($$),\n        classBar = $$.classBar.bind($$),\n        initialOpacity = $$.initialOpacity.bind($$),\n        color = function color(d) {\n      return $$.color(d.id);\n    };\n\n    $$.mainBar = $$.main.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data(barData);\n    $$.mainBar.enter().append('path').attr(\"class\", classBar).style(\"stroke\", color).style(\"fill\", color);\n    $$.mainBar.style(\"opacity\", initialOpacity);\n    $$.mainBar.exit().transition().duration(durationForExit).remove();\n  };\n\n  c3_chart_internal_fn.redrawBar = function (drawBar, withTransition) {\n    return [(withTransition ? this.mainBar.transition(Math.random().toString()) : this.mainBar).attr('d', drawBar).style(\"stroke\", this.color).style(\"fill\", this.color).style(\"opacity\", 1)];\n  };\n\n  c3_chart_internal_fn.getBarW = function (axis, barTargetsNum) {\n    var $$ = this,\n        config = $$.config,\n        w = typeof config.bar_width === 'number' ? config.bar_width : barTargetsNum ? axis.tickInterval() * config.bar_width_ratio / barTargetsNum : 0;\n    return config.bar_width_max && w > config.bar_width_max ? config.bar_width_max : w;\n  };\n\n  c3_chart_internal_fn.getBars = function (i, id) {\n    var $$ = this;\n    return (id ? $$.main.selectAll('.' + CLASS.bars + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.bar + (isValue(i) ? '-' + i : ''));\n  };\n\n  c3_chart_internal_fn.expandBars = function (i, id, reset) {\n    var $$ = this;\n\n    if (reset) {\n      $$.unexpandBars();\n    }\n\n    $$.getBars(i, id).classed(CLASS.EXPANDED, true);\n  };\n\n  c3_chart_internal_fn.unexpandBars = function (i) {\n    var $$ = this;\n    $$.getBars(i).classed(CLASS.EXPANDED, false);\n  };\n\n  c3_chart_internal_fn.generateDrawBar = function (barIndices, isSub) {\n    var $$ = this,\n        config = $$.config,\n        getPoints = $$.generateGetBarPoints(barIndices, isSub);\n    return function (d, i) {\n      // 4 points that make a bar\n      var points = getPoints(d, i); // switch points if axis is rotated, not applicable for sub chart\n\n      var indexX = config.axis_rotated ? 1 : 0;\n      var indexY = config.axis_rotated ? 0 : 1;\n      var path = 'M ' + points[0][indexX] + ',' + points[0][indexY] + ' ' + 'L' + points[1][indexX] + ',' + points[1][indexY] + ' ' + 'L' + points[2][indexX] + ',' + points[2][indexY] + ' ' + 'L' + points[3][indexX] + ',' + points[3][indexY] + ' ' + 'z';\n      return path;\n    };\n  };\n\n  c3_chart_internal_fn.generateGetBarPoints = function (barIndices, isSub) {\n    var $$ = this,\n        axis = isSub ? $$.subXAxis : $$.xAxis,\n        barTargetsNum = barIndices.__max__ + 1,\n        barW = $$.getBarW(axis, barTargetsNum),\n        barX = $$.getShapeX(barW, barTargetsNum, barIndices, !!isSub),\n        barY = $$.getShapeY(!!isSub),\n        barOffset = $$.getShapeOffset($$.isBarType, barIndices, !!isSub),\n        barSpaceOffset = barW * ($$.config.bar_space / 2),\n        yScale = isSub ? $$.getSubYScale : $$.getYScale;\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n          offset = barOffset(d, i) || y0,\n          // offset is for stacked bar chart\n      posX = barX(d),\n          posY = barY(d); // fix posY not to overflow opposite quadrant\n\n      if ($$.config.axis_rotated) {\n        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {\n          posY = y0;\n        }\n      } // 4 points that make a bar\n\n\n      return [[posX + barSpaceOffset, offset], [posX + barSpaceOffset, posY - (y0 - offset)], [posX + barW - barSpaceOffset, posY - (y0 - offset)], [posX + barW - barSpaceOffset, offset]];\n    };\n  };\n\n  c3_chart_internal_fn.isWithinBar = function (that) {\n    var mouse = this.d3.mouse(that),\n        box = that.getBoundingClientRect(),\n        seg0 = that.pathSegList.getItem(0),\n        seg1 = that.pathSegList.getItem(1),\n        x = Math.min(seg0.x, seg1.x),\n        y = Math.min(seg0.y, seg1.y),\n        w = box.width,\n        h = box.height,\n        offset = 2,\n        sx = x - offset,\n        ex = x + w + offset,\n        sy = y + h + offset,\n        ey = y - offset;\n    return sx < mouse[0] && mouse[0] < ex && ey < mouse[1] && mouse[1] < sy;\n  };\n\n  c3_chart_internal_fn.getShapeIndices = function (typeFilter) {\n    var $$ = this,\n        config = $$.config,\n        indices = {},\n        i = 0,\n        j,\n        k;\n    $$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$)).forEach(function (d) {\n      for (j = 0; j < config.data_groups.length; j++) {\n        if (config.data_groups[j].indexOf(d.id) < 0) {\n          continue;\n        }\n\n        for (k = 0; k < config.data_groups[j].length; k++) {\n          if (config.data_groups[j][k] in indices) {\n            indices[d.id] = indices[config.data_groups[j][k]];\n            break;\n          }\n        }\n      }\n\n      if (isUndefined(indices[d.id])) {\n        indices[d.id] = i++;\n      }\n    });\n    indices.__max__ = i - 1;\n    return indices;\n  };\n\n  c3_chart_internal_fn.getShapeX = function (offset, targetsNum, indices, isSub) {\n    var $$ = this,\n        scale = isSub ? $$.subX : $$.x;\n    return function (d) {\n      var index = d.id in indices ? indices[d.id] : 0;\n      return d.x || d.x === 0 ? scale(d.x) - offset * (targetsNum / 2 - index) : 0;\n    };\n  };\n\n  c3_chart_internal_fn.getShapeY = function (isSub) {\n    var $$ = this;\n    return function (d) {\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id);\n      return scale(d.value);\n    };\n  };\n\n  c3_chart_internal_fn.getShapeOffset = function (typeFilter, indices, isSub) {\n    var $$ = this,\n        targets = $$.orderTargets($$.filterTargetsToShow($$.data.targets.filter(typeFilter, $$))),\n        targetIds = targets.map(function (t) {\n      return t.id;\n    });\n    return function (d, i) {\n      var scale = isSub ? $$.getSubYScale(d.id) : $$.getYScale(d.id),\n          y0 = scale(0),\n          offset = y0;\n      targets.forEach(function (t) {\n        var values = $$.isStepType(d) ? $$.convertValuesToStep(t.values) : t.values;\n\n        if (t.id === d.id || indices[t.id] !== indices[d.id]) {\n          return;\n        }\n\n        if (targetIds.indexOf(t.id) < targetIds.indexOf(d.id)) {\n          // check if the x values line up\n          if (typeof values[i] === 'undefined' || +values[i].x !== +d.x) {\n            // \"+\" for timeseries\n            // if not, try to find the value that does line up\n            i = -1;\n            values.forEach(function (v, j) {\n              if (v.x === d.x) {\n                i = j;\n              }\n            });\n          }\n\n          if (i in values && values[i].value * d.value >= 0) {\n            offset += scale(values[i].value) - y0;\n          }\n        }\n      });\n      return offset;\n    };\n  };\n\n  c3_chart_internal_fn.isWithinShape = function (that, d) {\n    var $$ = this,\n        shape = $$.d3.select(that),\n        isWithin;\n\n    if (!$$.isTargetToShow(d.id)) {\n      isWithin = false;\n    } else if (that.nodeName === 'circle') {\n      isWithin = $$.isStepType(d) ? $$.isWithinStep(that, $$.getYScale(d.id)(d.value)) : $$.isWithinCircle(that, $$.pointSelectR(d) * 1.5);\n    } else if (that.nodeName === 'path') {\n      isWithin = shape.classed(CLASS.bar) ? $$.isWithinBar(that) : true;\n    }\n\n    return isWithin;\n  };\n\n  c3_chart_internal_fn.getInterpolate = function (d) {\n    var $$ = this,\n        interpolation = $$.isInterpolationType($$.config.spline_interpolation_type) ? $$.config.spline_interpolation_type : 'cardinal';\n    return $$.isSplineType(d) ? interpolation : $$.isStepType(d) ? $$.config.line_step_type : \"linear\";\n  };\n\n  c3_chart_internal_fn.initLine = function () {\n    var $$ = this;\n    $$.main.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartLines);\n  };\n\n  c3_chart_internal_fn.updateTargetsForLine = function (targets) {\n    var $$ = this,\n        config = $$.config,\n        mainLineUpdate,\n        mainLineEnter,\n        classChartLine = $$.classChartLine.bind($$),\n        classLines = $$.classLines.bind($$),\n        classAreas = $$.classAreas.bind($$),\n        classCircles = $$.classCircles.bind($$),\n        classFocus = $$.classFocus.bind($$);\n    mainLineUpdate = $$.main.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', function (d) {\n      return classChartLine(d) + classFocus(d);\n    });\n    mainLineEnter = mainLineUpdate.enter().append('g').attr('class', classChartLine).style('opacity', 0).style(\"pointer-events\", \"none\"); // Lines for each data\n\n    mainLineEnter.append('g').attr(\"class\", classLines); // Areas\n\n    mainLineEnter.append('g').attr('class', classAreas); // Circles for each data point on lines\n\n    mainLineEnter.append('g').attr(\"class\", function (d) {\n      return $$.generateClass(CLASS.selectedCircles, d.id);\n    });\n    mainLineEnter.append('g').attr(\"class\", classCircles).style(\"cursor\", function (d) {\n      return config.data_selection_isselectable(d) ? \"pointer\" : null;\n    }); // Update date for selected circles\n\n    targets.forEach(function (t) {\n      $$.main.selectAll('.' + CLASS.selectedCircles + $$.getTargetSelectorSuffix(t.id)).selectAll('.' + CLASS.selectedCircle).each(function (d) {\n        d.value = t.values[d.index].value;\n      });\n    }); // MEMO: can not keep same color...\n    //mainLineUpdate.exit().remove();\n  };\n\n  c3_chart_internal_fn.updateLine = function (durationForExit) {\n    var $$ = this;\n    $$.mainLine = $$.main.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));\n    $$.mainLine.enter().append('path').attr('class', $$.classLine.bind($$)).style(\"stroke\", $$.color);\n    $$.mainLine.style(\"opacity\", $$.initialOpacity.bind($$)).style('shape-rendering', function (d) {\n      return $$.isStepType(d) ? 'crispEdges' : '';\n    }).attr('transform', null);\n    $$.mainLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawLine = function (drawLine, withTransition) {\n    return [(withTransition ? this.mainLine.transition(Math.random().toString()) : this.mainLine).attr(\"d\", drawLine).style(\"stroke\", this.color).style(\"opacity\", 1)];\n  };\n\n  c3_chart_internal_fn.generateDrawLine = function (lineIndices, isSub) {\n    var $$ = this,\n        config = $$.config,\n        line = $$.d3.svg.line(),\n        getPoints = $$.generateGetLinePoints(lineIndices, isSub),\n        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\n        xValue = function xValue(d) {\n      return (isSub ? $$.subxx : $$.xx).call($$, d);\n    },\n        yValue = function yValue(d, i) {\n      return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)(d.value);\n    };\n\n    line = config.axis_rotated ? line.x(yValue).y(xValue) : line.x(xValue).y(yValue);\n\n    if (!config.line_connectNull) {\n      line = line.defined(function (d) {\n        return d.value != null;\n      });\n    }\n\n    return function (d) {\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\n          x = isSub ? $$.x : $$.subX,\n          y = yScaleGetter.call($$, d.id),\n          x0 = 0,\n          y0 = 0,\n          path;\n\n      if ($$.isLineType(d)) {\n        if (config.data_regions[d.id]) {\n          path = $$.lineWithRegions(values, x, y, config.data_regions[d.id]);\n        } else {\n          if ($$.isStepType(d)) {\n            values = $$.convertValuesToStep(values);\n          }\n\n          path = line.interpolate($$.getInterpolate(d))(values);\n        }\n      } else {\n        if (values[0]) {\n          x0 = x(values[0].x);\n          y0 = y(values[0].value);\n        }\n\n        path = config.axis_rotated ? \"M \" + y0 + \" \" + x0 : \"M \" + x0 + \" \" + y0;\n      }\n\n      return path ? path : \"M 0 0\";\n    };\n  };\n\n  c3_chart_internal_fn.generateGetLinePoints = function (lineIndices, isSub) {\n    // partial duplication of generateGetBarPoints\n    var $$ = this,\n        config = $$.config,\n        lineTargetsNum = lineIndices.__max__ + 1,\n        x = $$.getShapeX(0, lineTargetsNum, lineIndices, !!isSub),\n        y = $$.getShapeY(!!isSub),\n        lineOffset = $$.getShapeOffset($$.isLineType, lineIndices, !!isSub),\n        yScale = isSub ? $$.getSubYScale : $$.getYScale;\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n          offset = lineOffset(d, i) || y0,\n          // offset is for stacked area chart\n      posX = x(d),\n          posY = y(d); // fix posY not to overflow opposite quadrant\n\n      if (config.axis_rotated) {\n        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {\n          posY = y0;\n        }\n      } // 1 point that marks the line position\n\n\n      return [[posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility\n      [posX, posY - (y0 - offset)], // needed for compatibility\n      [posX, posY - (y0 - offset)] // needed for compatibility\n      ];\n    };\n  };\n\n  c3_chart_internal_fn.lineWithRegions = function (d, x, y, _regions) {\n    var $$ = this,\n        config = $$.config,\n        prev = -1,\n        i,\n        j,\n        s = \"M\",\n        sWithRegion,\n        xp,\n        yp,\n        dx,\n        dy,\n        dd,\n        diff,\n        diffx2,\n        xOffset = $$.isCategorized() ? 0.5 : 0,\n        xValue,\n        yValue,\n        regions = [];\n\n    function isWithinRegions(x, regions) {\n      var i;\n\n      for (i = 0; i < regions.length; i++) {\n        if (regions[i].start < x && x <= regions[i].end) {\n          return true;\n        }\n      }\n\n      return false;\n    } // Check start/end of regions\n\n\n    if (isDefined(_regions)) {\n      for (i = 0; i < _regions.length; i++) {\n        regions[i] = {};\n\n        if (isUndefined(_regions[i].start)) {\n          regions[i].start = d[0].x;\n        } else {\n          regions[i].start = $$.isTimeSeries() ? $$.parseDate(_regions[i].start) : _regions[i].start;\n        }\n\n        if (isUndefined(_regions[i].end)) {\n          regions[i].end = d[d.length - 1].x;\n        } else {\n          regions[i].end = $$.isTimeSeries() ? $$.parseDate(_regions[i].end) : _regions[i].end;\n        }\n      }\n    } // Set scales\n\n\n    xValue = config.axis_rotated ? function (d) {\n      return y(d.value);\n    } : function (d) {\n      return x(d.x);\n    };\n    yValue = config.axis_rotated ? function (d) {\n      return x(d.x);\n    } : function (d) {\n      return y(d.value);\n    }; // Define svg generator function for region\n\n    function generateM(points) {\n      return 'M' + points[0][0] + ' ' + points[0][1] + ' ' + points[1][0] + ' ' + points[1][1];\n    }\n\n    if ($$.isTimeSeries()) {\n      sWithRegion = function sWithRegion(d0, d1, j, diff) {\n        var x0 = d0.x.getTime(),\n            x_diff = d1.x - d0.x,\n            xv0 = new Date(x0 + x_diff * j),\n            xv1 = new Date(x0 + x_diff * (j + diff)),\n            points;\n\n        if (config.axis_rotated) {\n          points = [[y(yp(j)), x(xv0)], [y(yp(j + diff)), x(xv1)]];\n        } else {\n          points = [[x(xv0), y(yp(j))], [x(xv1), y(yp(j + diff))]];\n        }\n\n        return generateM(points);\n      };\n    } else {\n      sWithRegion = function sWithRegion(d0, d1, j, diff) {\n        var points;\n\n        if (config.axis_rotated) {\n          points = [[y(yp(j), true), x(xp(j))], [y(yp(j + diff), true), x(xp(j + diff))]];\n        } else {\n          points = [[x(xp(j), true), y(yp(j))], [x(xp(j + diff), true), y(yp(j + diff))]];\n        }\n\n        return generateM(points);\n      };\n    } // Generate\n\n\n    for (i = 0; i < d.length; i++) {\n      // Draw as normal\n      if (isUndefined(regions) || !isWithinRegions(d[i].x, regions)) {\n        s += \" \" + xValue(d[i]) + \" \" + yValue(d[i]);\n      } // Draw with region // TODO: Fix for horizotal charts\n      else {\n          xp = $$.getScale(d[i - 1].x + xOffset, d[i].x + xOffset, $$.isTimeSeries());\n          yp = $$.getScale(d[i - 1].value, d[i].value);\n          dx = x(d[i].x) - x(d[i - 1].x);\n          dy = y(d[i].value) - y(d[i - 1].value);\n          dd = Math.sqrt(Math.pow(dx, 2) + Math.pow(dy, 2));\n          diff = 2 / dd;\n          diffx2 = diff * 2;\n\n          for (j = diff; j <= 1; j += diffx2) {\n            s += sWithRegion(d[i - 1], d[i], j, diff);\n          }\n        }\n\n      prev = d[i].x;\n    }\n\n    return s;\n  };\n\n  c3_chart_internal_fn.updateArea = function (durationForExit) {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.mainArea = $$.main.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));\n    $$.mainArea.enter().append('path').attr(\"class\", $$.classArea.bind($$)).style(\"fill\", $$.color).style(\"opacity\", function () {\n      $$.orgAreaOpacity = +d3.select(this).style('opacity');\n      return 0;\n    });\n    $$.mainArea.style(\"opacity\", $$.orgAreaOpacity);\n    $$.mainArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawArea = function (drawArea, withTransition) {\n    return [(withTransition ? this.mainArea.transition(Math.random().toString()) : this.mainArea).attr(\"d\", drawArea).style(\"fill\", this.color).style(\"opacity\", this.orgAreaOpacity)];\n  };\n\n  c3_chart_internal_fn.generateDrawArea = function (areaIndices, isSub) {\n    var $$ = this,\n        config = $$.config,\n        area = $$.d3.svg.area(),\n        getPoints = $$.generateGetAreaPoints(areaIndices, isSub),\n        yScaleGetter = isSub ? $$.getSubYScale : $$.getYScale,\n        xValue = function xValue(d) {\n      return (isSub ? $$.subxx : $$.xx).call($$, d);\n    },\n        value0 = function value0(d, i) {\n      return config.data_groups.length > 0 ? getPoints(d, i)[0][1] : yScaleGetter.call($$, d.id)($$.getAreaBaseValue(d.id));\n    },\n        value1 = function value1(d, i) {\n      return config.data_groups.length > 0 ? getPoints(d, i)[1][1] : yScaleGetter.call($$, d.id)(d.value);\n    };\n\n    area = config.axis_rotated ? area.x0(value0).x1(value1).y(xValue) : area.x(xValue).y0(config.area_above ? 0 : value0).y1(value1);\n\n    if (!config.line_connectNull) {\n      area = area.defined(function (d) {\n        return d.value !== null;\n      });\n    }\n\n    return function (d) {\n      var values = config.line_connectNull ? $$.filterRemoveNull(d.values) : d.values,\n          x0 = 0,\n          y0 = 0,\n          path;\n\n      if ($$.isAreaType(d)) {\n        if ($$.isStepType(d)) {\n          values = $$.convertValuesToStep(values);\n        }\n\n        path = area.interpolate($$.getInterpolate(d))(values);\n      } else {\n        if (values[0]) {\n          x0 = $$.x(values[0].x);\n          y0 = $$.getYScale(d.id)(values[0].value);\n        }\n\n        path = config.axis_rotated ? \"M \" + y0 + \" \" + x0 : \"M \" + x0 + \" \" + y0;\n      }\n\n      return path ? path : \"M 0 0\";\n    };\n  };\n\n  c3_chart_internal_fn.getAreaBaseValue = function () {\n    return 0;\n  };\n\n  c3_chart_internal_fn.generateGetAreaPoints = function (areaIndices, isSub) {\n    // partial duplication of generateGetBarPoints\n    var $$ = this,\n        config = $$.config,\n        areaTargetsNum = areaIndices.__max__ + 1,\n        x = $$.getShapeX(0, areaTargetsNum, areaIndices, !!isSub),\n        y = $$.getShapeY(!!isSub),\n        areaOffset = $$.getShapeOffset($$.isAreaType, areaIndices, !!isSub),\n        yScale = isSub ? $$.getSubYScale : $$.getYScale;\n    return function (d, i) {\n      var y0 = yScale.call($$, d.id)(0),\n          offset = areaOffset(d, i) || y0,\n          // offset is for stacked area chart\n      posX = x(d),\n          posY = y(d); // fix posY not to overflow opposite quadrant\n\n      if (config.axis_rotated) {\n        if (0 < d.value && posY < y0 || d.value < 0 && y0 < posY) {\n          posY = y0;\n        }\n      } // 1 point that marks the area position\n\n\n      return [[posX, offset], [posX, posY - (y0 - offset)], [posX, posY - (y0 - offset)], // needed for compatibility\n      [posX, offset] // needed for compatibility\n      ];\n    };\n  };\n\n  c3_chart_internal_fn.updateCircle = function () {\n    var $$ = this;\n    $$.mainCircle = $$.main.selectAll('.' + CLASS.circles).selectAll('.' + CLASS.circle).data($$.lineOrScatterData.bind($$));\n    $$.mainCircle.enter().append(\"circle\").attr(\"class\", $$.classCircle.bind($$)).attr(\"r\", $$.pointR.bind($$)).style(\"fill\", $$.color);\n    $$.mainCircle.style(\"opacity\", $$.initialOpacityForCircle.bind($$));\n    $$.mainCircle.exit().remove();\n  };\n\n  c3_chart_internal_fn.redrawCircle = function (cx, cy, withTransition) {\n    var selectedCircles = this.main.selectAll('.' + CLASS.selectedCircle);\n    return [(withTransition ? this.mainCircle.transition(Math.random().toString()) : this.mainCircle).style('opacity', this.opacityForCircle.bind(this)).style(\"fill\", this.color).attr(\"cx\", cx).attr(\"cy\", cy), (withTransition ? selectedCircles.transition(Math.random().toString()) : selectedCircles).attr(\"cx\", cx).attr(\"cy\", cy)];\n  };\n\n  c3_chart_internal_fn.circleX = function (d) {\n    return d.x || d.x === 0 ? this.x(d.x) : null;\n  };\n\n  c3_chart_internal_fn.updateCircleY = function () {\n    var $$ = this,\n        lineIndices,\n        getPoints;\n\n    if ($$.config.data_groups.length > 0) {\n      lineIndices = $$.getShapeIndices($$.isLineType), getPoints = $$.generateGetLinePoints(lineIndices);\n\n      $$.circleY = function (d, i) {\n        return getPoints(d, i)[0][1];\n      };\n    } else {\n      $$.circleY = function (d) {\n        return $$.getYScale(d.id)(d.value);\n      };\n    }\n  };\n\n  c3_chart_internal_fn.getCircles = function (i, id) {\n    var $$ = this;\n    return (id ? $$.main.selectAll('.' + CLASS.circles + $$.getTargetSelectorSuffix(id)) : $$.main).selectAll('.' + CLASS.circle + (isValue(i) ? '-' + i : ''));\n  };\n\n  c3_chart_internal_fn.expandCircles = function (i, id, reset) {\n    var $$ = this,\n        r = $$.pointExpandedR.bind($$);\n\n    if (reset) {\n      $$.unexpandCircles();\n    }\n\n    $$.getCircles(i, id).classed(CLASS.EXPANDED, true).attr('r', r);\n  };\n\n  c3_chart_internal_fn.unexpandCircles = function (i) {\n    var $$ = this,\n        r = $$.pointR.bind($$);\n    $$.getCircles(i).filter(function () {\n      return $$.d3.select(this).classed(CLASS.EXPANDED);\n    }).classed(CLASS.EXPANDED, false).attr('r', r);\n  };\n\n  c3_chart_internal_fn.pointR = function (d) {\n    var $$ = this,\n        config = $$.config;\n    return $$.isStepType(d) ? 0 : isFunction(config.point_r) ? config.point_r(d) : config.point_r;\n  };\n\n  c3_chart_internal_fn.pointExpandedR = function (d) {\n    var $$ = this,\n        config = $$.config;\n\n    if (config.point_focus_expand_enabled) {\n      return isFunction(config.point_focus_expand_r) ? config.point_focus_expand_r(d) : config.point_focus_expand_r ? config.point_focus_expand_r : $$.pointR(d) * 1.75;\n    } else {\n      return $$.pointR(d);\n    }\n  };\n\n  c3_chart_internal_fn.pointSelectR = function (d) {\n    var $$ = this,\n        config = $$.config;\n    return isFunction(config.point_select_r) ? config.point_select_r(d) : config.point_select_r ? config.point_select_r : $$.pointR(d) * 4;\n  };\n\n  c3_chart_internal_fn.isWithinCircle = function (that, r) {\n    var d3 = this.d3,\n        mouse = d3.mouse(that),\n        d3_this = d3.select(that),\n        cx = +d3_this.attr(\"cx\"),\n        cy = +d3_this.attr(\"cy\");\n    return Math.sqrt(Math.pow(cx - mouse[0], 2) + Math.pow(cy - mouse[1], 2)) < r;\n  };\n\n  c3_chart_internal_fn.isWithinStep = function (that, y) {\n    return Math.abs(y - this.d3.mouse(that)[1]) < 30;\n  };\n\n  c3_chart_internal_fn.getCurrentWidth = function () {\n    var $$ = this,\n        config = $$.config;\n    return config.size_width ? config.size_width : $$.getParentWidth();\n  };\n\n  c3_chart_internal_fn.getCurrentHeight = function () {\n    var $$ = this,\n        config = $$.config,\n        h = config.size_height ? config.size_height : $$.getParentHeight();\n    return h > 0 ? h : 320 / ($$.hasType('gauge') && !config.gauge_fullCircle ? 2 : 1);\n  };\n\n  c3_chart_internal_fn.getCurrentPaddingTop = function () {\n    var $$ = this,\n        config = $$.config,\n        padding = isValue(config.padding_top) ? config.padding_top : 0;\n\n    if ($$.title && $$.title.node()) {\n      padding += $$.getTitlePadding();\n    }\n\n    return padding;\n  };\n\n  c3_chart_internal_fn.getCurrentPaddingBottom = function () {\n    var config = this.config;\n    return isValue(config.padding_bottom) ? config.padding_bottom : 0;\n  };\n\n  c3_chart_internal_fn.getCurrentPaddingLeft = function (withoutRecompute) {\n    var $$ = this,\n        config = $$.config;\n\n    if (isValue(config.padding_left)) {\n      return config.padding_left;\n    } else if (config.axis_rotated) {\n      return !config.axis_x_show || config.axis_x_inner ? 1 : Math.max(ceil10($$.getAxisWidthByAxisId('x', withoutRecompute)), 40);\n    } else if (!config.axis_y_show || config.axis_y_inner) {\n      // && !config.axis_rotated\n      return $$.axis.getYAxisLabelPosition().isOuter ? 30 : 1;\n    } else {\n      return ceil10($$.getAxisWidthByAxisId('y', withoutRecompute));\n    }\n  };\n\n  c3_chart_internal_fn.getCurrentPaddingRight = function () {\n    var $$ = this,\n        config = $$.config,\n        defaultPadding = 10,\n        legendWidthOnRight = $$.isLegendRight ? $$.getLegendWidth() + 20 : 0;\n\n    if (isValue(config.padding_right)) {\n      return config.padding_right + 1; // 1 is needed not to hide tick line\n    } else if (config.axis_rotated) {\n      return defaultPadding + legendWidthOnRight;\n    } else if (!config.axis_y2_show || config.axis_y2_inner) {\n      // && !config.axis_rotated\n      return 2 + legendWidthOnRight + ($$.axis.getY2AxisLabelPosition().isOuter ? 20 : 0);\n    } else {\n      return ceil10($$.getAxisWidthByAxisId('y2')) + legendWidthOnRight;\n    }\n  };\n\n  c3_chart_internal_fn.getParentRectValue = function (key) {\n    var parent = this.selectChart.node(),\n        v;\n\n    while (parent && parent.tagName !== 'BODY') {\n      try {\n        v = parent.getBoundingClientRect()[key];\n      } catch (e) {\n        if (key === 'width') {\n          // In IE in certain cases getBoundingClientRect\n          // will cause an \"unspecified error\"\n          v = parent.offsetWidth;\n        }\n      }\n\n      if (v) {\n        break;\n      }\n\n      parent = parent.parentNode;\n    }\n\n    return v;\n  };\n\n  c3_chart_internal_fn.getParentWidth = function () {\n    return this.getParentRectValue('width');\n  };\n\n  c3_chart_internal_fn.getParentHeight = function () {\n    var h = this.selectChart.style('height');\n    return h.indexOf('px') > 0 ? +h.replace('px', '') : 0;\n  };\n\n  c3_chart_internal_fn.getSvgLeft = function (withoutRecompute) {\n    var $$ = this,\n        config = $$.config,\n        hasLeftAxisRect = config.axis_rotated || !config.axis_rotated && !config.axis_y_inner,\n        leftAxisClass = config.axis_rotated ? CLASS.axisX : CLASS.axisY,\n        leftAxis = $$.main.select('.' + leftAxisClass).node(),\n        svgRect = leftAxis && hasLeftAxisRect ? leftAxis.getBoundingClientRect() : {\n      right: 0\n    },\n        chartRect = $$.selectChart.node().getBoundingClientRect(),\n        hasArc = $$.hasArcType(),\n        svgLeft = svgRect.right - chartRect.left - (hasArc ? 0 : $$.getCurrentPaddingLeft(withoutRecompute));\n    return svgLeft > 0 ? svgLeft : 0;\n  };\n\n  c3_chart_internal_fn.getAxisWidthByAxisId = function (id, withoutRecompute) {\n    var $$ = this,\n        position = $$.axis.getLabelPositionById(id);\n    return $$.axis.getMaxTickWidth(id, withoutRecompute) + (position.isInner ? 20 : 40);\n  };\n\n  c3_chart_internal_fn.getHorizontalAxisHeight = function (axisId) {\n    var $$ = this,\n        config = $$.config,\n        h = 30;\n\n    if (axisId === 'x' && !config.axis_x_show) {\n      return 8;\n    }\n\n    if (axisId === 'x' && config.axis_x_height) {\n      return config.axis_x_height;\n    }\n\n    if (axisId === 'y' && !config.axis_y_show) {\n      return config.legend_show && !$$.isLegendRight && !$$.isLegendInset ? 10 : 1;\n    }\n\n    if (axisId === 'y2' && !config.axis_y2_show) {\n      return $$.rotated_padding_top;\n    } // Calculate x axis height when tick rotated\n\n\n    if (axisId === 'x' && !config.axis_rotated && config.axis_x_tick_rotate) {\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_x_tick_rotate) / 180);\n    } // Calculate y axis height when tick rotated\n\n\n    if (axisId === 'y' && config.axis_rotated && config.axis_y_tick_rotate) {\n      h = 30 + $$.axis.getMaxTickWidth(axisId) * Math.cos(Math.PI * (90 - config.axis_y_tick_rotate) / 180);\n    }\n\n    return h + ($$.axis.getLabelPositionById(axisId).isInner ? 0 : 10) + (axisId === 'y2' ? -10 : 0);\n  };\n\n  c3_chart_internal_fn.getEventRectWidth = function () {\n    return Math.max(0, this.xAxis.tickInterval());\n  };\n\n  c3_chart_internal_fn.initBrush = function () {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.brush = d3.svg.brush().on(\"brush\", function () {\n      $$.redrawForBrush();\n    });\n\n    $$.brush.update = function () {\n      if ($$.context) {\n        $$.context.select('.' + CLASS.brush).call(this);\n      }\n\n      return this;\n    };\n\n    $$.brush.scale = function (scale) {\n      return $$.config.axis_rotated ? this.y(scale) : this.x(scale);\n    };\n  };\n\n  c3_chart_internal_fn.initSubchart = function () {\n    var $$ = this,\n        config = $$.config,\n        context = $$.context = $$.svg.append(\"g\").attr(\"transform\", $$.getTranslate('context')),\n        visibility = config.subchart_show ? 'visible' : 'hidden';\n    context.style('visibility', visibility); // Define g for chart area\n\n    context.append('g').attr(\"clip-path\", $$.clipPathForSubchart).attr('class', CLASS.chart); // Define g for bar chart area\n\n    context.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartBars); // Define g for line chart area\n\n    context.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartLines); // Add extent rect for Brush\n\n    context.append(\"g\").attr(\"clip-path\", $$.clipPath).attr(\"class\", CLASS.brush).call($$.brush); // ATTENTION: This must be called AFTER chart added\n    // Add Axis\n\n    $$.axes.subx = context.append(\"g\").attr(\"class\", CLASS.axisX).attr(\"transform\", $$.getTranslate('subx')).attr(\"clip-path\", config.axis_rotated ? \"\" : $$.clipPathForXAxis).style(\"visibility\", config.subchart_axis_x_show ? visibility : 'hidden');\n  };\n\n  c3_chart_internal_fn.updateTargetsForSubchart = function (targets) {\n    var $$ = this,\n        context = $$.context,\n        config = $$.config,\n        contextLineEnter,\n        contextLineUpdate,\n        contextBarEnter,\n        contextBarUpdate,\n        classChartBar = $$.classChartBar.bind($$),\n        classBars = $$.classBars.bind($$),\n        classChartLine = $$.classChartLine.bind($$),\n        classLines = $$.classLines.bind($$),\n        classAreas = $$.classAreas.bind($$);\n\n    if (config.subchart_show) {\n      //-- Bar --//\n      contextBarUpdate = context.select('.' + CLASS.chartBars).selectAll('.' + CLASS.chartBar).data(targets).attr('class', classChartBar);\n      contextBarEnter = contextBarUpdate.enter().append('g').style('opacity', 0).attr('class', classChartBar); // Bars for each data\n\n      contextBarEnter.append('g').attr(\"class\", classBars); //-- Line --//\n\n      contextLineUpdate = context.select('.' + CLASS.chartLines).selectAll('.' + CLASS.chartLine).data(targets).attr('class', classChartLine);\n      contextLineEnter = contextLineUpdate.enter().append('g').style('opacity', 0).attr('class', classChartLine); // Lines for each data\n\n      contextLineEnter.append(\"g\").attr(\"class\", classLines); // Area\n\n      contextLineEnter.append(\"g\").attr(\"class\", classAreas); //-- Brush --//\n\n      context.selectAll('.' + CLASS.brush + ' rect').attr(config.axis_rotated ? \"width\" : \"height\", config.axis_rotated ? $$.width2 : $$.height2);\n    }\n  };\n\n  c3_chart_internal_fn.updateBarForSubchart = function (durationForExit) {\n    var $$ = this;\n    $$.contextBar = $$.context.selectAll('.' + CLASS.bars).selectAll('.' + CLASS.bar).data($$.barData.bind($$));\n    $$.contextBar.enter().append('path').attr(\"class\", $$.classBar.bind($$)).style(\"stroke\", 'none').style(\"fill\", $$.color);\n    $$.contextBar.style(\"opacity\", $$.initialOpacity.bind($$));\n    $$.contextBar.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawBarForSubchart = function (drawBarOnSub, withTransition, duration) {\n    (withTransition ? this.contextBar.transition(Math.random().toString()).duration(duration) : this.contextBar).attr('d', drawBarOnSub).style('opacity', 1);\n  };\n\n  c3_chart_internal_fn.updateLineForSubchart = function (durationForExit) {\n    var $$ = this;\n    $$.contextLine = $$.context.selectAll('.' + CLASS.lines).selectAll('.' + CLASS.line).data($$.lineData.bind($$));\n    $$.contextLine.enter().append('path').attr('class', $$.classLine.bind($$)).style('stroke', $$.color);\n    $$.contextLine.style(\"opacity\", $$.initialOpacity.bind($$));\n    $$.contextLine.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawLineForSubchart = function (drawLineOnSub, withTransition, duration) {\n    (withTransition ? this.contextLine.transition(Math.random().toString()).duration(duration) : this.contextLine).attr(\"d\", drawLineOnSub).style('opacity', 1);\n  };\n\n  c3_chart_internal_fn.updateAreaForSubchart = function (durationForExit) {\n    var $$ = this,\n        d3 = $$.d3;\n    $$.contextArea = $$.context.selectAll('.' + CLASS.areas).selectAll('.' + CLASS.area).data($$.lineData.bind($$));\n    $$.contextArea.enter().append('path').attr(\"class\", $$.classArea.bind($$)).style(\"fill\", $$.color).style(\"opacity\", function () {\n      $$.orgAreaOpacity = +d3.select(this).style('opacity');\n      return 0;\n    });\n    $$.contextArea.style(\"opacity\", 0);\n    $$.contextArea.exit().transition().duration(durationForExit).style('opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawAreaForSubchart = function (drawAreaOnSub, withTransition, duration) {\n    (withTransition ? this.contextArea.transition(Math.random().toString()).duration(duration) : this.contextArea).attr(\"d\", drawAreaOnSub).style(\"fill\", this.color).style(\"opacity\", this.orgAreaOpacity);\n  };\n\n  c3_chart_internal_fn.redrawSubchart = function (withSubchart, transitions, duration, durationForExit, areaIndices, barIndices, lineIndices) {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config,\n        drawAreaOnSub,\n        drawBarOnSub,\n        drawLineOnSub;\n    $$.context.style('visibility', config.subchart_show ? 'visible' : 'hidden'); // subchart\n\n    if (config.subchart_show) {\n      // reflect main chart to extent on subchart if zoomed\n      if (d3.event && d3.event.type === 'zoom') {\n        $$.brush.extent($$.x.orgDomain()).update();\n      } // update subchart elements if needed\n\n\n      if (withSubchart) {\n        // extent rect\n        if (!$$.brush.empty()) {\n          $$.brush.extent($$.x.orgDomain()).update();\n        } // setup drawer - MEMO: this must be called after axis updated\n\n\n        drawAreaOnSub = $$.generateDrawArea(areaIndices, true);\n        drawBarOnSub = $$.generateDrawBar(barIndices, true);\n        drawLineOnSub = $$.generateDrawLine(lineIndices, true);\n        $$.updateBarForSubchart(duration);\n        $$.updateLineForSubchart(duration);\n        $$.updateAreaForSubchart(duration);\n        $$.redrawBarForSubchart(drawBarOnSub, duration, duration);\n        $$.redrawLineForSubchart(drawLineOnSub, duration, duration);\n        $$.redrawAreaForSubchart(drawAreaOnSub, duration, duration);\n      }\n    }\n  };\n\n  c3_chart_internal_fn.redrawForBrush = function () {\n    var $$ = this,\n        x = $$.x;\n    $$.redraw({\n      withTransition: false,\n      withY: $$.config.zoom_rescale,\n      withSubchart: false,\n      withUpdateXDomain: true,\n      withDimension: false\n    });\n    $$.config.subchart_onbrush.call($$.api, x.orgDomain());\n  };\n\n  c3_chart_internal_fn.transformContext = function (withTransition, transitions) {\n    var $$ = this,\n        subXAxis;\n\n    if (transitions && transitions.axisSubX) {\n      subXAxis = transitions.axisSubX;\n    } else {\n      subXAxis = $$.context.select('.' + CLASS.axisX);\n\n      if (withTransition) {\n        subXAxis = subXAxis.transition();\n      }\n    }\n\n    $$.context.attr(\"transform\", $$.getTranslate('context'));\n    subXAxis.attr(\"transform\", $$.getTranslate('subx'));\n  };\n\n  c3_chart_internal_fn.getDefaultExtent = function () {\n    var $$ = this,\n        config = $$.config,\n        extent = isFunction(config.axis_x_extent) ? config.axis_x_extent($$.getXDomain($$.data.targets)) : config.axis_x_extent;\n\n    if ($$.isTimeSeries()) {\n      extent = [$$.parseDate(extent[0]), $$.parseDate(extent[1])];\n    }\n\n    return extent;\n  };\n\n  c3_chart_internal_fn.initText = function () {\n    var $$ = this;\n    $$.main.select('.' + CLASS.chart).append(\"g\").attr(\"class\", CLASS.chartTexts);\n    $$.mainText = $$.d3.selectAll([]);\n  };\n\n  c3_chart_internal_fn.updateTargetsForText = function (targets) {\n    var $$ = this,\n        mainTextUpdate,\n        mainTextEnter,\n        classChartText = $$.classChartText.bind($$),\n        classTexts = $$.classTexts.bind($$),\n        classFocus = $$.classFocus.bind($$);\n    mainTextUpdate = $$.main.select('.' + CLASS.chartTexts).selectAll('.' + CLASS.chartText).data(targets).attr('class', function (d) {\n      return classChartText(d) + classFocus(d);\n    });\n    mainTextEnter = mainTextUpdate.enter().append('g').attr('class', classChartText).style('opacity', 0).style(\"pointer-events\", \"none\");\n    mainTextEnter.append('g').attr('class', classTexts);\n  };\n\n  c3_chart_internal_fn.updateText = function (durationForExit) {\n    var $$ = this,\n        config = $$.config,\n        barOrLineData = $$.barOrLineData.bind($$),\n        classText = $$.classText.bind($$);\n    $$.mainText = $$.main.selectAll('.' + CLASS.texts).selectAll('.' + CLASS.text).data(barOrLineData);\n    $$.mainText.enter().append('text').attr(\"class\", classText).attr('text-anchor', function (d) {\n      return config.axis_rotated ? d.value < 0 ? 'end' : 'start' : 'middle';\n    }).style(\"stroke\", 'none').style(\"fill\", function (d) {\n      return $$.color(d);\n    }).style(\"fill-opacity\", 0);\n    $$.mainText.text(function (d, i, j) {\n      return $$.dataLabelFormat(d.id)(d.value, d.id, i, j);\n    });\n    $$.mainText.exit().transition().duration(durationForExit).style('fill-opacity', 0).remove();\n  };\n\n  c3_chart_internal_fn.redrawText = function (xForText, yForText, forFlow, withTransition) {\n    return [(withTransition ? this.mainText.transition() : this.mainText).attr('x', xForText).attr('y', yForText).style(\"fill\", this.color).style(\"fill-opacity\", forFlow ? 0 : this.opacityForText.bind(this))];\n  };\n\n  c3_chart_internal_fn.getTextRect = function (text, cls, element) {\n    var dummy = this.d3.select('body').append('div').classed('c3', true),\n        svg = dummy.append(\"svg\").style('visibility', 'hidden').style('position', 'fixed').style('top', 0).style('left', 0),\n        font = this.d3.select(element).style('font'),\n        rect;\n    svg.selectAll('.dummy').data([text]).enter().append('text').classed(cls ? cls : \"\", true).style('font', font).text(text).each(function () {\n      rect = this.getBoundingClientRect();\n    });\n    dummy.remove();\n    return rect;\n  };\n\n  c3_chart_internal_fn.generateXYForText = function (areaIndices, barIndices, lineIndices, forX) {\n    var $$ = this,\n        getAreaPoints = $$.generateGetAreaPoints(areaIndices, false),\n        getBarPoints = $$.generateGetBarPoints(barIndices, false),\n        getLinePoints = $$.generateGetLinePoints(lineIndices, false),\n        getter = forX ? $$.getXForText : $$.getYForText;\n    return function (d, i) {\n      var getPoints = $$.isAreaType(d) ? getAreaPoints : $$.isBarType(d) ? getBarPoints : getLinePoints;\n      return getter.call($$, getPoints(d, i), d, this);\n    };\n  };\n\n  c3_chart_internal_fn.getXForText = function (points, d, textElement) {\n    var $$ = this,\n        box = textElement.getBoundingClientRect(),\n        xPos,\n        padding;\n\n    if ($$.config.axis_rotated) {\n      padding = $$.isBarType(d) ? 4 : 6;\n      xPos = points[2][1] + padding * (d.value < 0 ? -1 : 1);\n    } else {\n      xPos = $$.hasType('bar') ? (points[2][0] + points[0][0]) / 2 : points[0][0];\n    } // show labels regardless of the domain if value is null\n\n\n    if (d.value === null) {\n      if (xPos > $$.width) {\n        xPos = $$.width - box.width;\n      } else if (xPos < 0) {\n        xPos = 4;\n      }\n    }\n\n    return xPos;\n  };\n\n  c3_chart_internal_fn.getYForText = function (points, d, textElement) {\n    var $$ = this,\n        box = textElement.getBoundingClientRect(),\n        yPos;\n\n    if ($$.config.axis_rotated) {\n      yPos = (points[0][0] + points[2][0] + box.height * 0.6) / 2;\n    } else {\n      yPos = points[2][1];\n\n      if (d.value < 0 || d.value === 0 && !$$.hasPositiveValue) {\n        yPos += box.height;\n\n        if ($$.isBarType(d) && $$.isSafari()) {\n          yPos -= 3;\n        } else if (!$$.isBarType(d) && $$.isChrome()) {\n          yPos += 3;\n        }\n      } else {\n        yPos += $$.isBarType(d) ? -3 : -6;\n      }\n    } // show labels regardless of the domain if value is null\n\n\n    if (d.value === null && !$$.config.axis_rotated) {\n      if (yPos < box.height) {\n        yPos = box.height;\n      } else if (yPos > this.height) {\n        yPos = this.height - 4;\n      }\n    }\n\n    return yPos;\n  };\n\n  c3_chart_internal_fn.initTitle = function () {\n    var $$ = this;\n    $$.title = $$.svg.append(\"text\").text($$.config.title_text).attr(\"class\", $$.CLASS.title);\n  };\n\n  c3_chart_internal_fn.redrawTitle = function () {\n    var $$ = this;\n    $$.title.attr(\"x\", $$.xForTitle.bind($$)).attr(\"y\", $$.yForTitle.bind($$));\n  };\n\n  c3_chart_internal_fn.xForTitle = function () {\n    var $$ = this,\n        config = $$.config,\n        position = config.title_position || 'left',\n        x;\n\n    if (position.indexOf('right') >= 0) {\n      x = $$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width - config.title_padding.right;\n    } else if (position.indexOf('center') >= 0) {\n      x = ($$.currentWidth - $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).width) / 2;\n    } else {\n      // left\n      x = config.title_padding.left;\n    }\n\n    return x;\n  };\n\n  c3_chart_internal_fn.yForTitle = function () {\n    var $$ = this;\n    return $$.config.title_padding.top + $$.getTextRect($$.title.node().textContent, $$.CLASS.title, $$.title.node()).height;\n  };\n\n  c3_chart_internal_fn.getTitlePadding = function () {\n    var $$ = this;\n    return $$.yForTitle() + $$.config.title_padding.bottom;\n  };\n\n  c3_chart_internal_fn.initTooltip = function () {\n    var $$ = this,\n        config = $$.config,\n        i;\n    $$.tooltip = $$.selectChart.style(\"position\", \"relative\").append(\"div\").attr('class', CLASS.tooltipContainer).style(\"position\", \"absolute\").style(\"pointer-events\", \"none\").style(\"display\", \"none\"); // Show tooltip if needed\n\n    if (config.tooltip_init_show) {\n      if ($$.isTimeSeries() && isString(config.tooltip_init_x)) {\n        config.tooltip_init_x = $$.parseDate(config.tooltip_init_x);\n\n        for (i = 0; i < $$.data.targets[0].values.length; i++) {\n          if ($$.data.targets[0].values[i].x - config.tooltip_init_x === 0) {\n            break;\n          }\n        }\n\n        config.tooltip_init_x = i;\n      }\n\n      $$.tooltip.html(config.tooltip_contents.call($$, $$.data.targets.map(function (d) {\n        return $$.addName(d.values[config.tooltip_init_x]);\n      }), $$.axis.getXAxisTickFormat(), $$.getYFormat($$.hasArcType()), $$.color));\n      $$.tooltip.style(\"top\", config.tooltip_init_position.top).style(\"left\", config.tooltip_init_position.left).style(\"display\", \"block\");\n    }\n  };\n\n  c3_chart_internal_fn.getTooltipSortFunction = function () {\n    var $$ = this,\n        config = $$.config;\n\n    if (config.data_groups.length === 0 || config.tooltip_order !== undefined) {\n      // if data are not grouped or if an order is specified\n      // for the tooltip values we sort them by their values\n      var order = config.tooltip_order;\n\n      if (order === undefined) {\n        order = config.data_order;\n      }\n\n      var valueOf = function valueOf(obj) {\n        return obj ? obj.value : null;\n      }; // if data are not grouped, we sort them by their value\n\n\n      if (isString(order) && order.toLowerCase() === 'asc') {\n        return function (a, b) {\n          return valueOf(a) - valueOf(b);\n        };\n      } else if (isString(order) && order.toLowerCase() === 'desc') {\n        return function (a, b) {\n          return valueOf(b) - valueOf(a);\n        };\n      } else if (isFunction(order)) {\n        // if the function is from data_order we need\n        // to wrap the returned function in order to format\n        // the sorted value to the expected format\n        var sortFunction = order;\n\n        if (config.tooltip_order === undefined) {\n          sortFunction = function sortFunction(a, b) {\n            return order(a ? {\n              id: a.id,\n              values: [a]\n            } : null, b ? {\n              id: b.id,\n              values: [b]\n            } : null);\n          };\n        }\n\n        return sortFunction;\n      } else if (isArray(order)) {\n        return function (a, b) {\n          return order.indexOf(a.id) - order.indexOf(b.id);\n        };\n      }\n    } else {\n      // if data are grouped, we follow the order of grouped targets\n      var ids = $$.orderTargets($$.data.targets).map(function (i) {\n        return i.id;\n      }); // if it was either asc or desc we need to invert the order\n      // returned by orderTargets\n\n      if ($$.isOrderAsc() || $$.isOrderDesc()) {\n        ids = ids.reverse();\n      }\n\n      return function (a, b) {\n        return ids.indexOf(a.id) - ids.indexOf(b.id);\n      };\n    }\n  };\n\n  c3_chart_internal_fn.getTooltipContent = function (d, defaultTitleFormat, defaultValueFormat, color) {\n    var $$ = this,\n        config = $$.config,\n        titleFormat = config.tooltip_format_title || defaultTitleFormat,\n        nameFormat = config.tooltip_format_name || function (name) {\n      return name;\n    },\n        valueFormat = config.tooltip_format_value || defaultValueFormat,\n        text,\n        i,\n        title,\n        value,\n        name,\n        bgcolor;\n\n    var tooltipSortFunction = this.getTooltipSortFunction();\n\n    if (tooltipSortFunction) {\n      d.sort(tooltipSortFunction);\n    }\n\n    for (i = 0; i < d.length; i++) {\n      if (!(d[i] && (d[i].value || d[i].value === 0))) {\n        continue;\n      }\n\n      if (!text) {\n        title = sanitise(titleFormat ? titleFormat(d[i].x) : d[i].x);\n        text = \"<table class='\" + $$.CLASS.tooltip + \"'>\" + (title || title === 0 ? \"<tr><th colspan='2'>\" + title + \"</th></tr>\" : \"\");\n      }\n\n      value = sanitise(valueFormat(d[i].value, d[i].ratio, d[i].id, d[i].index, d));\n\n      if (value !== undefined) {\n        // Skip elements when their name is set to null\n        if (d[i].name === null) {\n          continue;\n        }\n\n        name = sanitise(nameFormat(d[i].name, d[i].ratio, d[i].id, d[i].index));\n        bgcolor = $$.levelColor ? $$.levelColor(d[i].value) : color(d[i].id);\n        text += \"<tr class='\" + $$.CLASS.tooltipName + \"-\" + $$.getTargetSelectorSuffix(d[i].id) + \"'>\";\n        text += \"<td class='name'><span style='background-color:\" + bgcolor + \"'></span>\" + name + \"</td>\";\n        text += \"<td class='value'>\" + value + \"</td>\";\n        text += \"</tr>\";\n      }\n    }\n\n    return text + \"</table>\";\n  };\n\n  c3_chart_internal_fn.tooltipPosition = function (dataToShow, tWidth, tHeight, element) {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3;\n    var svgLeft, tooltipLeft, tooltipRight, tooltipTop, chartRight;\n    var forArc = $$.hasArcType(),\n        mouse = d3.mouse(element); // Determin tooltip position\n\n    if (forArc) {\n      tooltipLeft = ($$.width - ($$.isLegendRight ? $$.getLegendWidth() : 0)) / 2 + mouse[0];\n      tooltipTop = ($$.hasType('gauge') ? $$.height : $$.height / 2) + mouse[1] + 20;\n    } else {\n      svgLeft = $$.getSvgLeft(true);\n\n      if (config.axis_rotated) {\n        tooltipLeft = svgLeft + mouse[0] + 100;\n        tooltipRight = tooltipLeft + tWidth;\n        chartRight = $$.currentWidth - $$.getCurrentPaddingRight();\n        tooltipTop = $$.x(dataToShow[0].x) + 20;\n      } else {\n        tooltipLeft = svgLeft + $$.getCurrentPaddingLeft(true) + $$.x(dataToShow[0].x) + 20;\n        tooltipRight = tooltipLeft + tWidth;\n        chartRight = svgLeft + $$.currentWidth - $$.getCurrentPaddingRight();\n        tooltipTop = mouse[1] + 15;\n      }\n\n      if (tooltipRight > chartRight) {\n        // 20 is needed for Firefox to keep tooltip width\n        tooltipLeft -= tooltipRight - chartRight + 20;\n      }\n\n      if (tooltipTop + tHeight > $$.currentHeight) {\n        tooltipTop -= tHeight + 30;\n      }\n    }\n\n    if (tooltipTop < 0) {\n      tooltipTop = 0;\n    }\n\n    return {\n      top: tooltipTop,\n      left: tooltipLeft\n    };\n  };\n\n  c3_chart_internal_fn.showTooltip = function (selectedData, element) {\n    var $$ = this,\n        config = $$.config;\n    var tWidth, tHeight, position;\n    var forArc = $$.hasArcType(),\n        dataToShow = selectedData.filter(function (d) {\n      return d && isValue(d.value);\n    }),\n        positionFunction = config.tooltip_position || c3_chart_internal_fn.tooltipPosition;\n\n    if (dataToShow.length === 0 || !config.tooltip_show) {\n      return;\n    }\n\n    $$.tooltip.html(config.tooltip_contents.call($$, selectedData, $$.axis.getXAxisTickFormat(), $$.getYFormat(forArc), $$.color)).style(\"display\", \"block\"); // Get tooltip dimensions\n\n    tWidth = $$.tooltip.property('offsetWidth');\n    tHeight = $$.tooltip.property('offsetHeight');\n    position = positionFunction.call(this, dataToShow, tWidth, tHeight, element); // Set tooltip\n\n    $$.tooltip.style(\"top\", position.top + \"px\").style(\"left\", position.left + 'px');\n  };\n\n  c3_chart_internal_fn.hideTooltip = function () {\n    this.tooltip.style(\"display\", \"none\");\n  };\n\n  c3_chart_internal_fn.setTargetType = function (targetIds, type) {\n    var $$ = this,\n        config = $$.config;\n    $$.mapToTargetIds(targetIds).forEach(function (id) {\n      $$.withoutFadeIn[id] = type === config.data_types[id];\n      config.data_types[id] = type;\n    });\n\n    if (!targetIds) {\n      config.data_type = type;\n    }\n  };\n\n  c3_chart_internal_fn.hasType = function (type, targets) {\n    var $$ = this,\n        types = $$.config.data_types,\n        has = false;\n    targets = targets || $$.data.targets;\n\n    if (targets && targets.length) {\n      targets.forEach(function (target) {\n        var t = types[target.id];\n\n        if (t && t.indexOf(type) >= 0 || !t && type === 'line') {\n          has = true;\n        }\n      });\n    } else if (Object.keys(types).length) {\n      Object.keys(types).forEach(function (id) {\n        if (types[id] === type) {\n          has = true;\n        }\n      });\n    } else {\n      has = $$.config.data_type === type;\n    }\n\n    return has;\n  };\n\n  c3_chart_internal_fn.hasArcType = function (targets) {\n    return this.hasType('pie', targets) || this.hasType('donut', targets) || this.hasType('gauge', targets);\n  };\n\n  c3_chart_internal_fn.isLineType = function (d) {\n    var config = this.config,\n        id = isString(d) ? d : d.id;\n    return !config.data_types[id] || ['line', 'spline', 'area', 'area-spline', 'step', 'area-step'].indexOf(config.data_types[id]) >= 0;\n  };\n\n  c3_chart_internal_fn.isStepType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return ['step', 'area-step'].indexOf(this.config.data_types[id]) >= 0;\n  };\n\n  c3_chart_internal_fn.isSplineType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return ['spline', 'area-spline'].indexOf(this.config.data_types[id]) >= 0;\n  };\n\n  c3_chart_internal_fn.isAreaType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return ['area', 'area-spline', 'area-step'].indexOf(this.config.data_types[id]) >= 0;\n  };\n\n  c3_chart_internal_fn.isBarType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return this.config.data_types[id] === 'bar';\n  };\n\n  c3_chart_internal_fn.isScatterType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return this.config.data_types[id] === 'scatter';\n  };\n\n  c3_chart_internal_fn.isPieType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return this.config.data_types[id] === 'pie';\n  };\n\n  c3_chart_internal_fn.isGaugeType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return this.config.data_types[id] === 'gauge';\n  };\n\n  c3_chart_internal_fn.isDonutType = function (d) {\n    var id = isString(d) ? d : d.id;\n    return this.config.data_types[id] === 'donut';\n  };\n\n  c3_chart_internal_fn.isArcType = function (d) {\n    return this.isPieType(d) || this.isDonutType(d) || this.isGaugeType(d);\n  };\n\n  c3_chart_internal_fn.lineData = function (d) {\n    return this.isLineType(d) ? [d] : [];\n  };\n\n  c3_chart_internal_fn.arcData = function (d) {\n    return this.isArcType(d.data) ? [d] : [];\n  };\n  /* not used\n   function scatterData(d) {\n   return isScatterType(d) ? d.values : [];\n   }\n   */\n\n\n  c3_chart_internal_fn.barData = function (d) {\n    return this.isBarType(d) ? d.values : [];\n  };\n\n  c3_chart_internal_fn.lineOrScatterData = function (d) {\n    return this.isLineType(d) || this.isScatterType(d) ? d.values : [];\n  };\n\n  c3_chart_internal_fn.barOrLineData = function (d) {\n    return this.isBarType(d) || this.isLineType(d) ? d.values : [];\n  };\n\n  c3_chart_internal_fn.isInterpolationType = function (type) {\n    return ['linear', 'linear-closed', 'basis', 'basis-open', 'basis-closed', 'bundle', 'cardinal', 'cardinal-open', 'cardinal-closed', 'monotone'].indexOf(type) >= 0;\n  };\n\n  c3_chart_internal_fn.isSafari = function () {\n    var ua = window.navigator.userAgent;\n    return ua.indexOf('Safari') >= 0 && ua.indexOf('Chrome') < 0;\n  };\n\n  c3_chart_internal_fn.isChrome = function () {\n    var ua = window.navigator.userAgent;\n    return ua.indexOf('Chrome') >= 0;\n  };\n\n  c3_chart_internal_fn.initZoom = function () {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config,\n        startEvent;\n    $$.zoom = d3.behavior.zoom().on(\"zoomstart\", function () {\n      startEvent = d3.event.sourceEvent;\n      $$.zoom.altDomain = d3.event.sourceEvent.altKey ? $$.x.orgDomain() : null;\n      config.zoom_onzoomstart.call($$.api, d3.event.sourceEvent);\n    }).on(\"zoom\", function () {\n      $$.redrawForZoom.call($$);\n    }).on('zoomend', function () {\n      var event = d3.event.sourceEvent; // if click, do nothing. otherwise, click interaction will be canceled.\n\n      if (event && startEvent.clientX === event.clientX && startEvent.clientY === event.clientY) {\n        return;\n      }\n\n      $$.redrawEventRect();\n      $$.updateZoom();\n      config.zoom_onzoomend.call($$.api, $$.x.orgDomain());\n    });\n\n    $$.zoom.scale = function (scale) {\n      return config.axis_rotated ? this.y(scale) : this.x(scale);\n    };\n\n    $$.zoom.orgScaleExtent = function () {\n      var extent = config.zoom_extent ? config.zoom_extent : [1, 10];\n      return [extent[0], Math.max($$.getMaxDataCount() / extent[1], extent[1])];\n    };\n\n    $$.zoom.updateScaleExtent = function () {\n      var ratio = diffDomain($$.x.orgDomain()) / diffDomain($$.getZoomDomain()),\n          extent = this.orgScaleExtent();\n      this.scaleExtent([extent[0] * ratio, extent[1] * ratio]);\n      return this;\n    };\n  };\n\n  c3_chart_internal_fn.getZoomDomain = function () {\n    var $$ = this,\n        config = $$.config,\n        d3 = $$.d3,\n        min = d3.min([$$.orgXDomain[0], config.zoom_x_min]),\n        max = d3.max([$$.orgXDomain[1], config.zoom_x_max]);\n    return [min, max];\n  };\n\n  c3_chart_internal_fn.updateZoom = function () {\n    var $$ = this,\n        z = $$.config.zoom_enabled ? $$.zoom : function () {};\n    $$.main.select('.' + CLASS.zoomRect).call(z).on(\"dblclick.zoom\", null);\n    $$.main.selectAll('.' + CLASS.eventRect).call(z).on(\"dblclick.zoom\", null);\n  };\n\n  c3_chart_internal_fn.redrawForZoom = function () {\n    var $$ = this,\n        d3 = $$.d3,\n        config = $$.config,\n        zoom = $$.zoom,\n        x = $$.x;\n\n    if (!config.zoom_enabled) {\n      return;\n    }\n\n    if ($$.filterTargetsToShow($$.data.targets).length === 0) {\n      return;\n    }\n\n    if (d3.event.sourceEvent.type === 'mousemove' && zoom.altDomain) {\n      x.domain(zoom.altDomain);\n      zoom.scale(x).updateScaleExtent();\n      return;\n    }\n\n    if ($$.isCategorized() && x.orgDomain()[0] === $$.orgXDomain[0]) {\n      x.domain([$$.orgXDomain[0] - 1e-10, x.orgDomain()[1]]);\n    }\n\n    $$.redraw({\n      withTransition: false,\n      withY: config.zoom_rescale,\n      withSubchart: false,\n      withEventRect: false,\n      withDimension: false\n    });\n\n    if (d3.event.sourceEvent.type === 'mousemove') {\n      $$.cancelClick = true;\n    }\n\n    config.zoom_onzoom.call($$.api, x.orgDomain());\n  };\n\n  return c3;\n});","map":null,"metadata":{},"sourceType":"script"}