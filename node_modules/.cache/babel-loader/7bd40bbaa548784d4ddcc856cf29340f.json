{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.rotateXY = undefined;\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _createClass = function () {\n  function defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  return function (Constructor, protoProps, staticProps) {\n    if (protoProps) defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) defineProperties(Constructor, staticProps);\n    return Constructor;\n  };\n}();\n\nexports.identityStack = identityStack;\nexports.drawOnCanvasHelper = drawOnCanvasHelper;\nexports.svgHelper = svgHelper;\nexports.getBarsSVG2 = getBarsSVG2;\nexports.drawOnCanvas2 = drawOnCanvas2;\nexports.getBars = getBars;\n\nvar _react = require(\"react\");\n\nvar _react2 = _interopRequireDefault(_react);\n\nvar _propTypes = require(\"prop-types\");\n\nvar _propTypes2 = _interopRequireDefault(_propTypes);\n\nvar _d3Collection = require(\"d3-collection\");\n\nvar _d3Array = require(\"d3-array\");\n\nvar _d3Shape = require(\"d3-shape\");\n\nvar _GenericChartComponent = require(\"../GenericChartComponent\");\n\nvar _GenericChartComponent2 = _interopRequireDefault(_GenericChartComponent);\n\nvar _GenericComponent = require(\"../GenericComponent\");\n\nvar _utils = require(\"../utils\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\n\nfunction _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nfunction _possibleConstructorReturn(self, call) {\n  if (!self) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self;\n}\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;\n}\n\nvar StackedBarSeries = function (_Component) {\n  _inherits(StackedBarSeries, _Component);\n\n  function StackedBarSeries(props) {\n    _classCallCheck(this, StackedBarSeries);\n\n    var _this = _possibleConstructorReturn(this, (StackedBarSeries.__proto__ || Object.getPrototypeOf(StackedBarSeries)).call(this, props));\n\n    _this.renderSVG = _this.renderSVG.bind(_this);\n    _this.drawOnCanvas = _this.drawOnCanvas.bind(_this);\n    return _this;\n  }\n\n  _createClass(StackedBarSeries, [{\n    key: \"drawOnCanvas\",\n    value: function drawOnCanvas(ctx, moreProps) {\n      var xAccessor = moreProps.xAccessor; // var { xScale, chartConfig: { yScale }, plotData } = moreProps;\n\n      drawOnCanvasHelper(ctx, this.props, moreProps, xAccessor, _d3Shape.stack);\n    }\n  }, {\n    key: \"renderSVG\",\n    value: function renderSVG(moreProps) {\n      var xAccessor = moreProps.xAccessor;\n      return _react2.default.createElement(\"g\", null, svgHelper(this.props, moreProps, xAccessor, _d3Shape.stack));\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var clip = this.props.clip;\n      return _react2.default.createElement(_GenericChartComponent2.default, {\n        clip: clip,\n        svgDraw: this.renderSVG,\n        canvasDraw: this.drawOnCanvas,\n        canvasToDraw: _GenericComponent.getAxisCanvas,\n        drawOn: [\"pan\"]\n      });\n    }\n  }]);\n\n  return StackedBarSeries;\n}(_react.Component);\n\nStackedBarSeries.propTypes = {\n  baseAt: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]).isRequired,\n  direction: _propTypes2.default.oneOf([\"up\", \"down\"]).isRequired,\n  stroke: _propTypes2.default.bool.isRequired,\n  width: _propTypes2.default.oneOfType([_propTypes2.default.number, _propTypes2.default.func]).isRequired,\n  opacity: _propTypes2.default.number.isRequired,\n  fill: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,\n  className: _propTypes2.default.oneOfType([_propTypes2.default.func, _propTypes2.default.string]).isRequired,\n  clip: _propTypes2.default.bool.isRequired\n};\nStackedBarSeries.defaultProps = {\n  baseAt: function baseAt(xScale, yScale\n  /* , d*/\n  ) {\n    return (0, _utils.head)(yScale.range());\n  },\n  direction: \"up\",\n  className: \"bar\",\n  stroke: true,\n  fill: \"#4682B4\",\n  opacity: 0.5,\n  width: _utils.plotDataLengthBarWidth,\n  widthRatio: 0.8,\n  clip: true,\n  swapScales: false\n};\n\nfunction identityStack() {\n  var keys = [];\n\n  function stack(data) {\n    var response = keys.map(function (key, i) {\n      // eslint-disable-next-line prefer-const\n      var arrays = data.map(function (d) {\n        // eslint-disable-next-line prefer-const\n        var array = [0, d[key]];\n        array.data = d;\n        return array;\n      });\n      arrays.key = key;\n      arrays.index = i;\n      return arrays;\n    });\n    return response;\n  }\n\n  stack.keys = function (x) {\n    if (!arguments.length) {\n      return keys;\n    }\n\n    keys = x;\n    return stack;\n  };\n\n  return stack;\n}\n\nfunction drawOnCanvasHelper(ctx, props, moreProps, xAccessor, stackFn) {\n  var defaultPostAction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _utils.identity;\n  var postRotateAction = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : rotateXY;\n  var xScale = moreProps.xScale,\n      yScale = moreProps.chartConfig.yScale,\n      plotData = moreProps.plotData;\n  var bars = doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction);\n  drawOnCanvas2(props, ctx, bars);\n}\n\nfunction convertToArray(item) {\n  return Array.isArray(item) ? item : [item];\n}\n\nfunction svgHelper(props, moreProps, xAccessor, stackFn) {\n  var defaultPostAction = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : _utils.identity;\n  var postRotateAction = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : rotateXY;\n  var xScale = moreProps.xScale,\n      yScale = moreProps.chartConfig.yScale,\n      plotData = moreProps.plotData;\n  var bars = doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction);\n  return getBarsSVG2(props, bars);\n}\n\nfunction doStuff(props, xAccessor, plotData, xScale, yScale, stackFn, postRotateAction, defaultPostAction) {\n  var yAccessor = props.yAccessor,\n      swapScales = props.swapScales;\n  var modifiedYAccessor = swapScales ? convertToArray(props.xAccessor) : convertToArray(yAccessor);\n  var modifiedXAccessor = swapScales ? yAccessor : xAccessor;\n  var modifiedXScale = swapScales ? yScale : xScale;\n  var modifiedYScale = swapScales ? xScale : yScale;\n  var postProcessor = swapScales ? postRotateAction : defaultPostAction;\n  var bars = getBars(props, modifiedXAccessor, modifiedYAccessor, modifiedXScale, modifiedYScale, plotData, stackFn, postProcessor);\n  return bars;\n}\n\nvar rotateXY = exports.rotateXY = function rotateXY(array) {\n  return array.map(function (each) {\n    return _extends({}, each, {\n      x: each.y,\n      y: each.x,\n      height: each.width,\n      width: each.height\n    });\n  });\n};\n\nfunction getBarsSVG2(props, bars) {\n  /* eslint-disable react/prop-types */\n  var opacity = props.opacity;\n  /* eslint-enable react/prop-types */\n\n  return bars.map(function (d, idx) {\n    if (d.width <= 1) {\n      return _react2.default.createElement(\"line\", {\n        key: idx,\n        className: d.className,\n        stroke: d.fill,\n        x1: d.x,\n        y1: d.y,\n        x2: d.x,\n        y2: d.y + d.height\n      });\n    }\n\n    return _react2.default.createElement(\"rect\", {\n      key: idx,\n      className: d.className,\n      stroke: d.stroke,\n      fill: d.fill,\n      x: d.x,\n      y: d.y,\n      width: d.width,\n      fillOpacity: opacity,\n      height: d.height\n    });\n  });\n}\n\nfunction drawOnCanvas2(props, ctx, bars) {\n  var stroke = props.stroke;\n  var nest = (0, _d3Collection.nest)().key(function (d) {\n    return d.fill;\n  }).entries(bars);\n  nest.forEach(function (outer) {\n    var key = outer.key,\n        values = outer.values;\n\n    if ((0, _utils.head)(values).width > 1) {\n      ctx.strokeStyle = key;\n    }\n\n    var fillStyle = (0, _utils.head)(values).width <= 1 ? key : (0, _utils.hexToRGBA)(key, props.opacity);\n    ctx.fillStyle = fillStyle;\n    values.forEach(function (d) {\n      if (d.width <= 1) {\n        /* <line key={idx} className={d.className}\n        \t\t\tstroke={stroke}\n        \t\t\tfill={fill}\n        \t\t\tx1={d.x} y1={d.y}\n        \t\t\tx2={d.x} y2={d.y + d.height} />*/\n\n        /*\n        ctx.beginPath();\n        ctx.moveTo(d.x, d.y);\n        ctx.lineTo(d.x, d.y + d.height);\n        ctx.stroke();\n        */\n        ctx.fillRect(d.x - 0.5, d.y, 1, d.height);\n      } else {\n        /* <rect key={idx} className={d.className}\n        \t\tstroke={stroke}\n        \t\tfill={fill}\n        \t\tx={d.x}\n        \t\ty={d.y}\n        \t\twidth={d.width}\n        \t\theight={d.height} /> */\n\n        /*\n        ctx.beginPath();\n        ctx.rect(d.x, d.y, d.width, d.height);\n        ctx.fill();\n        */\n        ctx.fillRect(d.x, d.y, d.width, d.height);\n        if (stroke) ctx.strokeRect(d.x, d.y, d.width, d.height);\n      }\n    });\n  });\n}\n\nfunction getBars(props, xAccessor, yAccessor, xScale, yScale, plotData) {\n  var stack = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : identityStack;\n  var after = arguments.length > 7 && arguments[7] !== undefined ? arguments[7] : _utils.identity;\n  var baseAt = props.baseAt,\n      className = props.className,\n      fill = props.fill,\n      stroke = props.stroke,\n      _props$spaceBetweenBa = props.spaceBetweenBar,\n      spaceBetweenBar = _props$spaceBetweenBa === undefined ? 0 : _props$spaceBetweenBa;\n  var getClassName = (0, _utils.functor)(className);\n  var getFill = (0, _utils.functor)(fill);\n  var getBase = (0, _utils.functor)(baseAt);\n  var widthFunctor = (0, _utils.functor)(props.width);\n  var width = widthFunctor(props, {\n    xScale: xScale,\n    xAccessor: xAccessor,\n    plotData: plotData\n  });\n  var barWidth = Math.round(width);\n  var eachBarWidth = (barWidth - spaceBetweenBar * (yAccessor.length - 1)) / yAccessor.length;\n  var offset = barWidth === 1 ? 0 : 0.5 * width;\n  var ds = plotData.map(function (each) {\n    // eslint-disable-next-line prefer-const\n    var d = {\n      appearance: {},\n      x: xAccessor(each)\n    };\n    yAccessor.forEach(function (eachYAccessor, i) {\n      var key = \"y\" + i;\n      d[key] = eachYAccessor(each);\n      var appearance = {\n        className: getClassName(each, i),\n        stroke: stroke ? getFill(each, i) : \"none\",\n        fill: getFill(each, i)\n      };\n      d.appearance[key] = appearance;\n    });\n    return d;\n  });\n  var keys = yAccessor.map(function (_, i) {\n    return \"y\" + i;\n  }); // console.log(ds);\n\n  var data = stack().keys(keys)(ds); // console.log(data);\n\n  var newData = data.map(function (each, i) {\n    var key = each.key;\n    return each.map(function (d) {\n      // eslint-disable-next-line prefer-const\n      var array = [d[0], d[1]];\n      array.data = {\n        x: d.data.x,\n        i: i,\n        appearance: d.data.appearance[key]\n      };\n      return array;\n    });\n  }); // console.log(newData);\n  // console.log(merge(newData));\n\n  var bars = (0, _d3Array.merge)(newData) // .filter(d => isDefined(d.y))\n  .map(function (d) {\n    // let baseValue = yScale.invert(getBase(xScale, yScale, d.datum));\n    var y = yScale(d[1]);\n    /* let h = isDefined(d.y0) && d.y0 !== 0 && !isNaN(d.y0)\n    \t\t? yScale(d.y0) - y\n    \t\t: getBase(xScale, yScale, d.datum) - yScale(d.y)*/\n\n    var h = getBase(xScale, yScale, d.data) - yScale(d[1] - d[0]); // console.log(d.y, yScale.domain(), yScale.range())\n    // let h = ;\n    // if (d.y < 0) h = -h;\n    // console.log(d, y, h)\n\n    if (h < 0) {\n      y = y + h;\n      h = -h;\n    } // console.log(d.data.i, Math.round(offset - (d.data.i > 0 ? (eachBarWidth + spaceBetweenBar) * d.data.i : 0)))\n\n    /* console.log(d.series, d.datum.date, d.x,\n    \t\tgetBase(xScale, yScale, d.datum), `d.y=${d.y}, d.y0=${d.y0}, y=${y}, h=${h}`)*/\n\n\n    return _extends({}, d.data.appearance, {\n      // series: d.series,\n      // i: d.x,\n      x: Math.round(xScale(d.data.x) - width / 2),\n      y: y,\n      groupOffset: Math.round(offset - (d.data.i > 0 ? (eachBarWidth + spaceBetweenBar) * d.data.i : 0)),\n      groupWidth: Math.round(eachBarWidth),\n      offset: Math.round(offset),\n      height: h,\n      width: barWidth\n    });\n  }).filter(function (bar) {\n    return !isNaN(bar.y);\n  });\n  return after(bars);\n}\n\nexports.default = StackedBarSeries;","map":null,"metadata":{},"sourceType":"script"}