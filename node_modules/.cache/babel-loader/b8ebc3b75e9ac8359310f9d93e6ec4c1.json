{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nexports.default = function () {\n  var options = _defaultOptionsForComputation.Kagi;\n\n  var dateAccessor = function dateAccessor(d) {\n    return d.date;\n  };\n\n  var dateMutator = function dateMutator(d, date) {\n    d.date = date;\n  };\n\n  function calculator(data) {\n    var _options = options,\n        reversalType = _options.reversalType,\n        windowSize = _options.windowSize,\n        reversal = _options.reversal,\n        sourcePath = _options.sourcePath;\n    var source = (0, _utils.path)(sourcePath);\n    var reversalThreshold = void 0;\n\n    if (reversalType === \"ATR\") {\n      // calculateATR(rawData, period);\n      var atrAlgorithm = (0, _atr2.default)().options({\n        windowSize: windowSize\n      });\n      var atrCalculator = (0, _utils.merge)().algorithm(atrAlgorithm).merge(function (d, c) {\n        d[\"atr\" + windowSize] = c;\n      });\n      atrCalculator(data);\n\n      reversalThreshold = function reversalThreshold(d) {\n        return d[\"atr\" + windowSize];\n      };\n    } else {\n      reversalThreshold = (0, _utils.functor)(reversal);\n    }\n\n    var kagiData = [];\n    var prevPeak = void 0,\n        prevTrough = void 0,\n        direction = void 0;\n    var line = {};\n    data.forEach(function (d) {\n      if ((0, _utils.isNotDefined)(line.from)) {\n        dateMutator(line, dateAccessor(d));\n        line.from = dateAccessor(d);\n        if (!line.open) line.open = d.open;\n        line.high = d.high;\n        line.low = d.low;\n        if (!line.close) line.close = source(d);\n        line.startOfYear = d.startOfYear;\n        line.startOfQuarter = d.startOfQuarter;\n        line.startOfMonth = d.startOfMonth;\n        line.startOfWeek = d.startOfWeek;\n      }\n\n      if (!line.startOfYear) {\n        line.startOfYear = d.startOfYear;\n\n        if (line.startOfYear) {\n          line.date = d.date; // line.displayDate = d.displayDate;\n        }\n      }\n\n      if (!line.startOfQuarter) {\n        line.startOfQuarter = d.startOfQuarter;\n\n        if (line.startOfQuarter && !line.startOfYear) {\n          line.date = d.date; // line.displayDate = d.displayDate;\n        }\n      }\n\n      if (!line.startOfMonth) {\n        line.startOfMonth = d.startOfMonth;\n\n        if (line.startOfMonth && !line.startOfQuarter) {\n          line.date = d.date; // line.displayDate = d.displayDate;\n        }\n      }\n\n      if (!line.startOfWeek) {\n        line.startOfWeek = d.startOfWeek;\n\n        if (line.startOfWeek && !line.startOfMonth) {\n          line.date = d.date; // line.displayDate = d.displayDate;\n        }\n      }\n\n      line.volume = (line.volume || 0) + d.volume;\n      line.high = Math.max(line.high, d.high);\n      line.low = Math.min(line.low, d.low);\n      line.to = dateAccessor(d);\n      var priceMovement = source(d) - line.close; // console.log(source(d), priceMovement)\n\n      if (line.close >= line.open\n      /* going up */\n      && priceMovement > 0\n      /* and moving in same direction */\n      || line.close < line.open\n      /* going down */\n      && priceMovement < 0\n      /* and moving in same direction */\n      ) {\n          line.close = source(d);\n\n          if (prevTrough && line.close < prevTrough) {\n            // going below the prevTrough, so change from yang to yin\n            // A yin line forms when a Kagi line breaks below the prior trough.\n            line.changePoint = prevTrough;\n\n            if (line.startAs !== \"yin\") {\n              line.changeTo = \"yin\"; // line.startAs = \"yang\";\n            }\n          }\n\n          if (prevPeak && line.close > prevPeak) {\n            // going above the prevPeak, so change from yin to yang\n            // A yang line forms when a Kagi line breaks above the prior peak\n            line.changePoint = prevPeak;\n\n            if (line.startAs !== \"yang\") {\n              line.changeTo = \"yang\"; // line.startAs = \"yin\";\n            }\n          }\n        } else if (line.close >= line.open\n      /* going up */\n      && priceMovement < 0\n      /* and moving in other direction */\n      && Math.abs(priceMovement) > reversalThreshold(d)\n      /* and the movement is big enough for reversal */\n      || line.close < line.open\n      /* going down */\n      && priceMovement > 0\n      /* and moving in other direction */\n      && Math.abs(priceMovement) > reversalThreshold(d)\n      /* and the movement is big enough for reversal */\n      ) {\n          // reverse direction\n          var nextLineOpen = line.close;\n          direction = (line.close - line.open) / Math.abs(line.close - line.open);\n          var nextChangePoint = void 0,\n              nextChangeTo = void 0;\n\n          if (direction < 0\n          /* if direction so far has been -ve*/\n          ) {\n              // compare with line.close becomes prevTrough\n              if ((0, _utils.isNotDefined)(prevPeak)) prevPeak = line.open;\n              prevTrough = line.close;\n\n              if (source(d) > prevPeak) {\n                nextChangePoint = prevPeak;\n                nextChangeTo = \"yang\";\n              }\n            } else {\n            if ((0, _utils.isNotDefined)(prevTrough)) prevTrough = line.open;\n            prevPeak = line.close;\n\n            if (source(d) < prevTrough) {\n              nextChangePoint = prevTrough;\n              nextChangeTo = \"yin\";\n            }\n          }\n\n          if ((0, _utils.isNotDefined)(line.startAs)) {\n            line.startAs = direction > 0 ? \"yang\" : \"yin\";\n          }\n\n          var startAs = line.changeTo || line.startAs;\n          line.added = true;\n          kagiData.push(line);\n          direction = -1 * direction; // direction is reversed\n\n          line = _extends({}, line);\n          line.open = nextLineOpen;\n          line.close = source(d);\n          line.startAs = startAs;\n          line.changePoint = nextChangePoint;\n          line.changeTo = nextChangeTo;\n          line.added = false;\n          line.from = undefined;\n          line.volume = 0;\n        } else {// console.log(\"MOVING IN REV DIR BUT..\", line.open, line.close, source(d));\n      }\n\n      line.current = source(d);\n      var dir = line.close - line.open;\n      dir = dir === 0 ? 1 : dir / Math.abs(dir);\n      line.reverseAt = dir > 0 ? line.close - reversalThreshold(d) : line.open - reversalThreshold(d);\n    });\n    if (!line.added) kagiData.push(line);\n    return kagiData;\n  }\n\n  calculator.options = function (x) {\n    if (!arguments.length) {\n      return options;\n    }\n\n    options = _extends({}, _defaultOptionsForComputation.Kagi, x);\n    return calculator;\n  };\n\n  calculator.dateMutator = function (x) {\n    if (!arguments.length) return dateMutator;\n    dateMutator = x;\n    return calculator;\n  };\n\n  calculator.dateAccessor = function (x) {\n    if (!arguments.length) return dateAccessor;\n    dateAccessor = x;\n    return calculator;\n  };\n\n  return calculator;\n};\n\nvar _utils = require(\"../utils\");\n\nvar _atr = require(\"./atr\");\n\nvar _atr2 = _interopRequireDefault(_atr);\n\nvar _defaultOptionsForComputation = require(\"./defaultOptionsForComputation\");\n\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}","map":null,"metadata":{},"sourceType":"script"}