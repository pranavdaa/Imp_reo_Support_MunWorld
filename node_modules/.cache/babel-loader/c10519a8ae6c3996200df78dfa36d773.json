{"ast":null,"code":"var _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n\n  return target;\n};\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nimport React from \"react\";\nimport { extent } from \"d3-array\";\nimport { set } from \"d3-collection\";\nimport flattenDeep from \"lodash.flattendeep\";\nimport Chart from \"../Chart\";\nimport { last, isObject, getClosestItem, zipper, isDefined, isNotDefined, functor, mapObject, find, shallowEqual } from \"./index\";\nexport function getChartOrigin(origin, contextWidth, contextHeight) {\n  var originCoordinates = typeof origin === \"function\" ? origin(contextWidth, contextHeight) : origin;\n  return originCoordinates;\n}\nexport function getDimensions(_ref, chartProps) {\n  var width = _ref.width,\n      height = _ref.height;\n  var chartHeight = chartProps.height || height;\n  return {\n    availableHeight: height,\n    width: width,\n    height: chartHeight\n  };\n}\n\nfunction values(func) {\n  return function (d) {\n    var obj = func(d);\n\n    if (isObject(obj)) {\n      return mapObject(obj);\n    }\n\n    return obj;\n  };\n}\n\nfunction isArraySize2AndNumber(yExtentsProp) {\n  if (Array.isArray(yExtentsProp) && yExtentsProp.length === 2) {\n    var _yExtentsProp = _slicedToArray(yExtentsProp, 2),\n        a = _yExtentsProp[0],\n        b = _yExtentsProp[1];\n\n    return typeof a == \"number\" && typeof b == \"number\";\n  }\n\n  return false;\n}\n\nexport function getNewChartConfig(innerDimension, children) {\n  var existingChartConfig = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  return React.Children.map(children, function (each) {\n    if (each && each.type.toString() === Chart.toString()) {\n      var chartProps = _extends({}, Chart.defaultProps, each.props);\n\n      var id = chartProps.id,\n          origin = chartProps.origin,\n          padding = chartProps.padding,\n          yExtentsProp = chartProps.yExtents,\n          yScaleProp = chartProps.yScale,\n          flipYScale = chartProps.flipYScale,\n          yExtentsCalculator = chartProps.yExtentsCalculator;\n      var yScale = yScaleProp.copy();\n\n      var _getDimensions = getDimensions(innerDimension, chartProps),\n          width = _getDimensions.width,\n          height = _getDimensions.height,\n          availableHeight = _getDimensions.availableHeight;\n\n      var yPan = chartProps.yPan;\n      var yPanEnabled = chartProps.yPanEnabled; // var { yMousePointerRectWidth: rectWidth, yMousePointerRectHeight: rectHeight, yMousePointerArrowWidth: arrowWidth } = each.props;\n      // var mouseCoordinates = { at, yDisplayFormat, rectHeight, rectWidth, arrowWidth };\n\n      var yExtents = isDefined(yExtentsProp) ? (Array.isArray(yExtentsProp) ? yExtentsProp : [yExtentsProp]).map(functor) : undefined;\n      var prevChartConfig = find(existingChartConfig, function (d) {\n        return d.id === id;\n      });\n\n      if (isArraySize2AndNumber(yExtentsProp)) {\n        if (isDefined(prevChartConfig) && prevChartConfig.yPan && prevChartConfig.yPanEnabled && yPan && yPanEnabled && shallowEqual(prevChartConfig.originalYExtentsProp, yExtentsProp)) {\n          // console.log(prevChartConfig.originalYExtentsProp, yExtentsProp)\n          // console.log(prevChartConfig.yScale.domain())\n          yScale.domain(prevChartConfig.yScale.domain());\n        } else {\n          var _yExtentsProp2 = _slicedToArray(yExtentsProp, 2),\n              a = _yExtentsProp2[0],\n              b = _yExtentsProp2[1];\n\n          yScale.domain([a, b]);\n        }\n      } else if (isDefined(prevChartConfig) && prevChartConfig.yPanEnabled) {\n        if (isArraySize2AndNumber(prevChartConfig.originalYExtentsProp)) {// do nothing\n        } else {\n          yScale.domain(prevChartConfig.yScale.domain());\n          yPanEnabled = true;\n        }\n      }\n\n      return {\n        id: id,\n        origin: functor(origin)(width, availableHeight),\n        padding: padding,\n        originalYExtentsProp: yExtentsProp,\n        yExtents: yExtents,\n        yExtentsCalculator: yExtentsCalculator,\n        flipYScale: flipYScale,\n        // yScale: setRange(yScale.copy(), height, padding, flipYScale),\n        yScale: yScale,\n        yPan: yPan,\n        yPanEnabled: yPanEnabled,\n        // mouseCoordinates,\n        width: width,\n        height: height\n      };\n    }\n\n    return undefined;\n  }).filter(function (each) {\n    return isDefined(each);\n  });\n}\nexport function getCurrentCharts(chartConfig, mouseXY) {\n  var currentCharts = chartConfig.filter(function (eachConfig) {\n    var top = eachConfig.origin[1];\n    var bottom = top + eachConfig.height;\n    return mouseXY[1] > top && mouseXY[1] < bottom;\n  }).map(function (config) {\n    return config.id;\n  });\n  return currentCharts;\n}\n\nfunction setRange(scale, height, padding, flipYScale) {\n  if (scale.rangeRoundPoints || isNotDefined(scale.invert)) {\n    if (isNaN(padding)) throw new Error(\"padding has to be a number for ordinal scale\");\n    if (scale.rangeRoundPoints) scale.rangeRoundPoints(flipYScale ? [0, height] : [height, 0], padding);\n    if (scale.rangeRound) scale.range(flipYScale ? [0, height] : [height, 0]).padding(padding);\n  } else {\n    var _ref2 = isNaN(padding) ? padding : {\n      top: padding,\n      bottom: padding\n    },\n        top = _ref2.top,\n        bottom = _ref2.bottom;\n\n    scale.range(flipYScale ? [top, height - bottom] : [height - bottom, top]);\n  }\n\n  return scale;\n}\n\nfunction yDomainFromYExtents(yExtents, yScale, plotData) {\n  var yValues = yExtents.map(function (eachExtent) {\n    return plotData.map(values(eachExtent));\n  });\n  var allYValues = flattenDeep(yValues); // console.log(allYValues)\n\n  var realYDomain = yScale.invert ? extent(allYValues) : set(allYValues).values();\n  return realYDomain;\n}\n\nexport function getChartConfigWithUpdatedYScales(chartConfig, _ref3, xDomain, dy, chartsToPan) {\n  var plotData = _ref3.plotData,\n      xAccessor = _ref3.xAccessor,\n      displayXAccessor = _ref3.displayXAccessor,\n      fullData = _ref3.fullData;\n  var yDomains = chartConfig.map(function (_ref4) {\n    var yExtentsCalculator = _ref4.yExtentsCalculator,\n        yExtents = _ref4.yExtents,\n        yScale = _ref4.yScale;\n    var realYDomain = isDefined(yExtentsCalculator) ? yExtentsCalculator({\n      plotData: plotData,\n      xDomain: xDomain,\n      xAccessor: xAccessor,\n      displayXAccessor: displayXAccessor,\n      fullData: fullData\n    }) : yDomainFromYExtents(yExtents, yScale, plotData); // console.log(\"yScale.domain() ->\", yScale.domain())\n\n    var yDomainDY = isDefined(dy) ? yScale.range().map(function (each) {\n      return each - dy;\n    }).map(yScale.invert) : yScale.domain();\n    return {\n      realYDomain: realYDomain,\n      yDomainDY: yDomainDY,\n      prevYDomain: yScale.domain()\n    };\n  });\n  var combine = zipper().combine(function (config, _ref5) {\n    var realYDomain = _ref5.realYDomain,\n        yDomainDY = _ref5.yDomainDY,\n        prevYDomain = _ref5.prevYDomain;\n    var id = config.id,\n        padding = config.padding,\n        height = config.height,\n        yScale = config.yScale,\n        yPan = config.yPan,\n        flipYScale = config.flipYScale,\n        _config$yPanEnabled = config.yPanEnabled,\n        yPanEnabled = _config$yPanEnabled === undefined ? false : _config$yPanEnabled;\n    var another = isDefined(chartsToPan) ? chartsToPan.indexOf(id) > -1 : true;\n    var domain = yPan && yPanEnabled ? another ? yDomainDY : prevYDomain : realYDomain; // console.log(id, yPan, yPanEnabled, another);\n    // console.log(domain, realYDomain, prevYDomain);\n\n    var newYScale = setRange(yScale.copy().domain(domain), height, padding, flipYScale);\n    return _extends({}, config, {\n      yScale: newYScale,\n      realYDomain: realYDomain\n    }); // return { ...config, yScale: yScale.copy().domain(domain).range([height - padding, padding]) };\n  });\n  var updatedChartConfig = combine(chartConfig, yDomains); // console.error(yDomains, dy, chartsToPan, updatedChartConfig.map(d => d.yScale.domain()));\n  // console.log(updatedChartConfig.map(d => ({ id: d.id, domain: d.yScale.domain() })))\n\n  return updatedChartConfig;\n}\nexport function getCurrentItem(xScale, xAccessor, mouseXY, plotData) {\n  var xValue = void 0,\n      item = void 0;\n\n  if (xScale.invert) {\n    xValue = xScale.invert(mouseXY[0]);\n    item = getClosestItem(plotData, xValue, xAccessor);\n  } else {\n    var d = xScale.range().map(function (d, idx) {\n      return {\n        x: Math.abs(d - mouseXY[0]),\n        idx: idx\n      };\n    }).reduce(function (a, b) {\n      return a.x < b.x ? a : b;\n    });\n    item = isDefined(d) ? plotData[d.idx] : plotData[0]; // console.log(d, item);\n  }\n\n  return item;\n}\nexport function getXValue(xScale, xAccessor, mouseXY, plotData) {\n  var xValue = void 0,\n      item = void 0;\n\n  if (xScale.invert) {\n    xValue = xScale.invert(mouseXY[0]);\n\n    if (xValue > xAccessor(last(plotData)) && xScale.value) {\n      return Math.round(xValue);\n    } else {\n      item = getClosestItem(plotData, xValue, xAccessor);\n    }\n  } else {\n    var d = xScale.range().map(function (d, idx) {\n      return {\n        x: Math.abs(d - mouseXY[0]),\n        idx: idx\n      };\n    }).reduce(function (a, b) {\n      return a.x < b.x ? a : b;\n    });\n    item = isDefined(d) ? plotData[d.idx] : plotData[0]; // console.log(d, item);\n  }\n\n  return xAccessor(item);\n}","map":null,"metadata":{},"sourceType":"module"}