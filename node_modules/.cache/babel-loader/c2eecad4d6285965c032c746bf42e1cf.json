{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\nexports.default = financeDiscontinuousScale;\n\nvar _d3Collection = require(\"d3-collection\");\n\nvar _d3Array = require(\"d3-array\");\n\nvar _d3Scale = require(\"d3-scale\");\n\nvar _utils = require(\"../utils\");\n\nvar _levels = require(\"./levels\");\n\nvar MAX_LEVEL = _levels.levelDefinition.length - 1;\n\nfunction financeDiscontinuousScale(index, futureProvider) {\n  var backingLinearScale = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (0, _d3Scale.scaleLinear)();\n  if ((0, _utils.isNotDefined)(index)) throw new Error(\"Use the discontinuousTimeScaleProvider to create financeDiscontinuousScale\");\n\n  function scale(x) {\n    return backingLinearScale(x);\n  }\n\n  scale.invert = function (x) {\n    var inverted = backingLinearScale.invert(x);\n    return Math.round(inverted * 10000) / 10000;\n  };\n\n  scale.domain = function (x) {\n    if (!arguments.length) return backingLinearScale.domain();\n    backingLinearScale.domain(x);\n    return scale;\n  };\n\n  scale.range = function (x) {\n    if (!arguments.length) return backingLinearScale.range();\n    backingLinearScale.range(x);\n    return scale;\n  };\n\n  scale.rangeRound = function (x) {\n    return backingLinearScale.range(x);\n  };\n\n  scale.clamp = function (x) {\n    if (!arguments.length) return backingLinearScale.clamp();\n    backingLinearScale.clamp(x);\n    return scale;\n  };\n\n  scale.interpolate = function (x) {\n    if (!arguments.length) return backingLinearScale.interpolate();\n    backingLinearScale.interpolate(x);\n    return scale;\n  };\n\n  scale.ticks = function (m, flexTicks) {\n    var backingTicks = backingLinearScale.ticks(m);\n    var ticksMap = (0, _d3Collection.map)();\n\n    var _backingLinearScale$d = backingLinearScale.domain(),\n        _backingLinearScale$d2 = _slicedToArray(_backingLinearScale$d, 2),\n        domainStart = _backingLinearScale$d2[0],\n        domainEnd = _backingLinearScale$d2[1];\n\n    var start = Math.max(Math.ceil(domainStart), (0, _utils.head)(index).index) + Math.abs((0, _utils.head)(index).index);\n    var end = Math.min(Math.floor(domainEnd), (0, _utils.last)(index).index) + Math.abs((0, _utils.head)(index).index);\n\n    if (Math.floor(domainEnd) > end) {// console.log(end, domainEnd, index);\n    }\n\n    var desiredTickCount = Math.ceil((end - start) / (domainEnd - domainStart) * backingTicks.length);\n\n    for (var i = MAX_LEVEL; i >= 0; i--) {\n      var ticksAtLevel = ticksMap.get(i);\n      var temp = (0, _utils.isNotDefined)(ticksAtLevel) ? [] : ticksAtLevel.slice();\n\n      for (var j = start; j <= end; j++) {\n        if (index[j].level === i) {\n          temp.push(index[j]);\n        }\n      }\n\n      ticksMap.set(i, temp);\n    }\n\n    var unsortedTicks = [];\n\n    for (var _i = MAX_LEVEL; _i >= 0; _i--) {\n      if (ticksMap.get(_i).length + unsortedTicks.length > desiredTickCount * 1.5) break;\n      unsortedTicks = unsortedTicks.concat(ticksMap.get(_i).map(function (d) {\n        return d.index;\n      }));\n    }\n\n    var ticks = unsortedTicks.sort(_d3Array.ascending); // console.log(backingTicks.length, desiredTickCount, ticks, ticksMap);\n\n    if (!flexTicks && end - start > ticks.length) {\n      var ticksSet = (0, _d3Collection.set)(ticks);\n      var d = Math.abs((0, _utils.head)(index).index); // ignore ticks within this distance\n\n      var distance = Math.ceil((backingTicks.length > 0 ? ((0, _utils.last)(backingTicks) - (0, _utils.head)(backingTicks)) / backingTicks.length / 4 : 1) * 1.5);\n\n      for (var _i2 = 0; _i2 < ticks.length - 1; _i2++) {\n        for (var _j = _i2 + 1; _j < ticks.length; _j++) {\n          if (ticks[_j] - ticks[_i2] <= distance) {\n            ticksSet.remove(index[ticks[_i2] + d].level >= index[ticks[_j] + d].level ? ticks[_j] : ticks[_i2]);\n          }\n        }\n      }\n\n      var tickValues = ticksSet.values().map(function (d) {\n        return parseInt(d, 10);\n      }); // console.log(ticks.length, tickValues, level);\n      // console.log(ticks, tickValues, distance);\n\n      return tickValues;\n    }\n\n    return ticks;\n  };\n\n  scale.tickFormat = function () {\n    return function (x) {\n      var d = Math.abs((0, _utils.head)(index).index);\n      var _index$Math$floor = index[Math.floor(x + d)],\n          format = _index$Math$floor.format,\n          date = _index$Math$floor.date;\n      return format(date);\n    };\n  };\n\n  scale.value = function (x) {\n    var d = Math.abs((0, _utils.head)(index).index);\n\n    if ((0, _utils.isDefined)(index[Math.floor(x + d)])) {\n      var date = index[Math.floor(x + d)].date;\n      return date;\n    }\n  };\n\n  scale.nice = function (m) {\n    backingLinearScale.nice(m);\n    return scale;\n  };\n\n  scale.index = function (x) {\n    if (!arguments.length) return index;\n    index = x;\n    return scale;\n  };\n\n  scale.copy = function () {\n    return financeDiscontinuousScale(index, futureProvider, backingLinearScale.copy());\n  };\n\n  return scale;\n}","map":null,"metadata":{},"sourceType":"script"}